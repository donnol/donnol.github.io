[{"id":0,"href":"/posts/2021/12/github_action_deploy_hugo_blog/","title":"github action deploy hugo blog","section":"12","content":"why #  为了将视线保持在文章上，减少构建和发布的时间占用。\nwhat #  github action是GitHub推出的持续集成/持续部署工具，只需要在项目中添加workflow.yml配置文件，在其中配置好任务、工作、步骤等，即可在指定动作发生时自动触发编排好的动作。换言之，如果我们在我们的博客仓库里配置了自动将内容打包和发布的workflow.yml，那我们就可以把精力集中在文章的编写，然后轻轻地提交推送，即可完成博客地打包和发布，very easy and smooth。\nhow #  在github准备一个blog仓库，用于存放原始信息；再准备一个github page仓库，用于存放打包数据。\n其中github page仓库已开启page，可以通过github page设置的域名访问。\n 我的blog仓库\n 我的github page仓库\nworkflow #   这是我结合网络各位英豪所总结出来的一个workflow.yml配置文件\nname: blog # 做什么都好，别忘了先起个平凡（kuxuan）的名字 on: # 指定触发动作 push: # 动作是：git push branches: - main # 指定分支： main jobs: build-deploy: runs-on: ubuntu-latest # 基于ubuntu steps: - uses: actions/checkout@v2 # 切换分支：git checkout with: submodules: recursive  # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo # 博客所用的打包和部署工具 uses: peaceiris/actions-hugo@v2 with: hugo-version: latest - name: Build # 打包 run: hugo --minify --baseURL=https://donnol.github.io # 指定base url，确保构建出来的内容里的超链接都在它里面 - name: Deploy # 部署 uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 这个key非常关键，一言两语很难讲清楚 external_repository: donnol/donnol.github.io # 我的github page所在的仓库 PUBLISH_BRANCH: main PUBLISH_DIR: ./public # 将本仓库的public目录下的内容提交到github page仓库 commit_message: ${{ github.event.head_commit.message }} # 提交信息 以铜为镜，可以正衣冠；以人为镜，可以明得失； 以史为镜，可以知兴替。\ndeploy key #    使用ssh-keygen生产一对非对称秘钥（包含有公钥、私钥）\n  在github page(我这里是donnol/donnol.github.io)的仓库的setting里的deploy里添加公钥\n  在blog仓库setting的secrets里添加私钥，注意命名必须是workflow里使用的名称(如上述：ACTIONS_DEPLOY_KEY)\n  Q\u0026amp;A #  遇到问题不要惊慌，阿Q怕的是强者，如果你示弱，结果可想而知。\n当然，实在搞不懂，也可以在issue里提问，本人不负责任地想回就回。\n温馨提示 #  如果想知道更详细的信息，请自行搜索关键词，网络大神比比皆是，学习资料处处有售，生活实践时时待你。\n"},{"id":1,"href":"/posts/2021/01/proxy-between-layer/","title":"go实现AOP","section":"01","content":"go实现AOP #  假设有store，从数据库获取数据，其中有方法IUserStore.GetByID，传入id参数，返回用户信息:\ntype IUserStore interface { GetByID(ctx context.Context, id int) (User, error) } 另外有service，刚好有用户id并且需要拿到用户信息，于是依赖了上述IUserStore：\ntype IUserSrv interface { CheckUser(ctx context.Context, id int) error // 获取用户信息，然后检查用户某些属性 } type userImpl struct { userStore IUserStore } func (impl userImpl) CheckUser(ctx context.Context, id int) error { user, err := impl.userStore.GetByID(ctx, id) if err != nil { return err } // 使用user数据做一些操作  _ = user } 上面所描述的是一个最简单的情况，如果我们要在userImpl.CheckUser里对impl.userStore.GetByID方法调用添加耗时统计，依然十分简单。\nfunc (impl userImpl) CheckUser(ctx context.Context, id int) error { begin := time.Now() user, err := impl.userStore.GetByID(ctx, id) if err != nil { return err } fmt.Println(time.Since(begin)) // 统计耗时  // 使用user数据做一些操作  _ = user } 但是，如果方法里调用的类似impl.userStore.GetByID的方法非常之多，逻辑非常之复杂时，这样一个一个的添加，必然非常麻烦、非常累。\n这时，如果有一个层间代理能帮我们拦截store的方法调用，在调用前后添加上耗时统计，势必能大大提升我们的工作效率。\n比如：\nfunc Around(f func(args []interface{}) []interface{}, args []interface{}) []interface{} { begin := time.Now() r := f(args) fmt.Println(time.Since(begin)) // 统计耗时  return r } 这只是一个简单的包装函数，怎么能将它与上面的接口联系到一起呢？\n有兴趣的话，可以看这里的实现 #  可以看到，主要的方法是Around(provider interface{}, mock interface{}, arounder Arounder) interface{}， 其中provider参数是类似NewXXX() IXXX的函数，而mock是IXXX接口的一个实现，最后的Arounder是 拥有方法Around(pctx ProxyContext, method reflect.Value, args []reflect.Value) []reflect.Value的接口。\n这里的示例 #  可以看到，mock结构是长这样的：\ntype UserMock struct { AddFunc func(name string) int GetHelper func(id int) string `method:\u0026#34;Get\u0026#34;` // 表示这个字段关联的方法是Get \tGetContextFunc func(ctx context.Context, id int) string } 所以，为了提升开发效率，我还写了一个 工具，用来根据接口生成相应的mock结构体。\n"},{"id":2,"href":"/posts/2021/01/hugo-blog/","title":"hugo搭建博客","section":"01","content":"操作 #    安装hugo。\n  使用hugo新建项目\n  添加主题\n  启动博客\n  "},{"id":3,"href":"/posts/2020/12/go-ctx/","title":"go ctx","section":"12","content":"ctx #  1.why\ngoroutine号称百万之众，互相之间盘根错节，难以管理控制。为此，必须提供一种机制来管理控制它们。\n各自为战 #  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // start first  go func() { fmt.Println(1) }() // start second  go func() { fmt.Println(2) }() time.Sleep(time.Second) } 万法归一 #  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { wg := new(sync.WaitGroup) // start first  wg.Add(1) go func() { defer wg.Done() fmt.Println(1) }() // start second  wg.Add(1) go func() { defer wg.Done() fmt.Println(2) }() wg.Wait() } 可以看到使用waitgroup可以控制多个goroutine必须互相等待，直到最后一个完成才会全部完成。\n明修栈道暗度陈仓 #  package main import ( \u0026#34;fmt\u0026#34; ) func main() { ch1 := make(chan int) ch2 := make(chan int) // start first  go func() { fmt.Println(1) \u0026lt;-ch2 ch1 \u0026lt;- 1 }() ch3 := make(chan int) // start second  go func() { fmt.Println(2) ch2 \u0026lt;- 2 \u0026lt;-ch1 // escape  ch3 \u0026lt;- 3 }() n := \u0026lt;-ch3 fmt.Println(n) } 使用chan的话，可以实现goroutine之间的消息同步\n2.what\n Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.\n\u0026ndash; 提供标准库context，定义了Context类型，带有限期、取消信息和其它请求域里的跨API边界和进程间的值。\n3.how\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { var n time.Duration = 2 now := time.Now() ctx, cancel := context.WithDeadline(context.Background(), now.Add(time.Second*n)) _ = cancel fmt.Println(now) // start first  go func(ctx context.Context) { select { case \u0026lt;-ctx.Done(): } fmt.Println(time.Now(), 1) }(ctx) // start second  go func(ctx context.Context) { select { case \u0026lt;-ctx.Done(): } fmt.Println(time.Now(), 2) }(ctx) time.Sleep(time.Second * (n - 1)) fmt.Println(time.Now()) // 一秒钟之后取消的话，两个goroutine会在取消后马上执行；如果等到时间到期了，就会在两秒后执行；  // cancel()  // fmt.Println(time.Now())  time.Sleep(time.Second * (n + 1)) } 4.others\n"},{"id":4,"href":"/posts/2021/01/pstree/","title":"pstree进程树及说明","section":"01","content":"pstree进程树及说明 #   "},{"id":5,"href":"/posts/2021/07/linux-epoll/","title":"Linux Epoll","section":"07","content":"linux epoll #   wiki\n 手册\nwhy #  what #  Linux内核的可扩展I/O事件通知机制。\n于Linux 2.5.44首度登场，它设计目的旨在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能（举例来说：旧有的系统函数所花费的时间复杂度为O(n)，epoll的时间复杂度O(log n)）。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。\nhow #  epoll 通过使用红黑树(RB-tree)搜索被监控的文件描述符(file descriptor)。\n在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。\nint epoll_create(int size); 在内核中创建epoll实例并返回一个epoll文件描述符。\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 向 epfd 对应的内核epoll 实例添加、修改或删除对 fd 上事件 event 的监听。op 可以为 EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别对应的是添加新的事件，修改文件描述符上监听的事件类型，从实例上删除一个事件。如果 event 的 events 属性设置了 EPOLLET flag，那么监听该事件的方式是边缘触发。\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 当 timeout 为 0 时，epoll_wait 永远会立即返回。而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。\n触发模式 #  epoll提供边沿触发及状态触发模式。\n在边沿触发模式中，epoll_wait仅会在新的事件首次被加入epoll队列时返回；在状态触发模式下，epoll_wait在事件状态未变更前将不断被触发。状态触发模式是默认的模式。\n状态触发模式与边沿触发模式有读和写两种情况，我们先来考虑读的情况。假设我们注册了一个读事件到epoll实例上，epoll实例会通过epoll_wait返回值的形式通知我们哪些读事件已经就绪。简单地来说，在状态触发模式下，如果读事件未被处理，该事件对应的内核读缓冲器非空，则每次调用epoll_wait时返回的事件列表都会包含该事件，直到该事件对应的内核读缓冲器为空为止。而在边沿触发模式下，读事件就绪后只会通知一次，不会反复通知。\n然后我们再考虑写的情况。状态触发模式下，只要文件描述符对应的内核写缓冲器未满，就会一直通知可写事件。而在边沿触发模式下，内核写缓冲器由满变为未满后，只会通知一次可写事件。\n举例来说，倘若有一个已经于epoll注册之流水线接获资料，epoll_wait将返回，并发出资料读取的信号。现假设缓冲器的资料仅有部分被读取并处理，在level-triggered(状态触发)模式下，任何对epoll_wait之调用都将即刻返回，直到缓冲器中的资料全部被读取；然而，在edge-triggered(边缘触发)的情境下，epoll_wait仅会于再次接收到新资料(亦即，新资料被写入流水线)时返回。\n边沿触发模式 #  边沿触发模式使得程序有可能在用户态缓存 IO 状态。nginx 使用的是边沿触发模式。\n文件描述符有两种情况是推荐使用边沿触发模式的。\n read 或者 write 系统调用返回了 EAGAIN。 非阻塞的文件描述符。  可能的缺陷：\n如果 IO 空间很大，你要花很多时间才能把它一次读完，这可能会导致饥饿。举个例子，假设你在监听一个文件描述符列表，而某个文件描述符上有大量的输入（不间断的输入流），那么你在读完它的过程中就没空处理其他就绪的文件描述符。（因为边沿触发模式只会通知一次可读事件，所以你往往会想一次把它读完。）一种解决方案是，程序维护一个就绪队列，当 epoll 实例通知某文件描述符就绪时将它在就绪队列数据结构中标记为就绪，这样程序就会记得哪些文件描述符等待处理。Round-Robin 循环处理就绪队列中就绪的文件描述符即可。\n如果你缓存了所有事件，那么一种可能的情况是 A 事件的发生让程序关闭了另一个文件描述符 B。但是内核的 epoll 实例并不知道这件事，需要你从 epoll 删除掉。\n"},{"id":6,"href":"/posts/2021/12/etcd/","title":"Etcd","section":"12","content":"etcd #  raft #  message type #  // For description of different message types, see: // https://pkg.go.dev/go.etcd.io/etcd/raft/v3#hdr-MessageType type MessageType int32 const ( // 选举时使用；  // 如果节点是一个follower或candidate，它在选举超时前没有收到任何心跳，它就回传递MsgHup消息给它自己的Step方法，然后成为（或保持）一个candidate从而开启一个新的选举 \tMsgHup MessageType = 0 // 一个内部类型，它向leader发送一个类型为“MsgHeartbeat”的心跳信号  // 如果节点是一个leader，raft里的tick函数将会是“tickHeartbeat”，触发leader周期性地发送“MsgHeartbeat”消息给它的followers \tMsgBeat MessageType = 1 // 提议往它的日志条目里追加数据；  // 这是一个特别的类型，由follower反推提议给leader（正常是leader提议，follower执行）；  // 发给leader的话，leader调用“appendEntry”方法追加条目到它的日志里，然后调用“bcastAppend”方法发送这些条目给它的远端节点；  // 发给candidate的话，它们直接丢弃该消息  // 发给follower的话，follower会将消息存储到它们的信箱里。会把发送者的id一起存储，然后转发给leader。 \tMsgProp MessageType = 2 // 包含了要复制的日志条目  // leader调用“bcastAppend”（里面调用“sendAppend”），发送“一会要被复制的日志”消息；  // 当candidate收到消息后，在它的Step方法里，它马上回退为follower，因为这条消息表明已经存在一个有效leader了。  // candidate和follower均会返回一条“MsgAppResp”类型消息以作响应。 \tMsgApp MessageType = 3 // 调用“handlerAppendEntries”方法 \tMsgAppResp MessageType = 4 // 请求集群中的节点给自己投票；  // 当节点是follower或candidate，并且它们的Step方法收到了“MsgHup”消息，节点调用“campaign”方法去提议自己成为一个leader。一旦“campaign”方法被调用，节点成为candidate，并发送“MsgVote”给集群中的远端节点请求投票。  // 当leader或candidate的Step方法收到该消息，并且消息的Term比它们的Term小，“MsgVote”将被拒绝。  // 当leader或candidate收到的消息的Term要更大时，它会回退为follower。  // 当follower收到该消息，仅当发送者的最后的term比“MsgVote”的term要大，或发送者的最后term等于“MsgVote”的term（但发送者的最后提交index大于等于follower的）， \tMsgVote MessageType = 5 // 投票响应；  // 当candidate收到后，它会统计选票，如果大于majority（quorum），它成为leader并调用“bcastAppend”。如果candidate收到大量的否决票，它将回退到follower \tMsgVoteResp MessageType = 6 // 请求安装一个快照消息；  // 当一个节点刚成为leader，或者leader收到了“MsgProp”消息，它调用“bcastAppend”方法（里面再调用“sendAppend”）方法到每个follower。在“sendAppend”方法里，如果一个leader获取term或条目失败了，leader通过\u0026#34;MsgSnap\u0026#34;消息请求快照。 \tMsgSnap MessageType = 7 // leader发送心跳；  // 当candidate收到“MsgHeartbeat”，并且消息的term比candidate的大，candidate回退到follower并且更新它的提交index为这次心跳里的值。然后candidate发送消息到它的信箱。  // 当消息发送到follower的Step方法，并且消息的term比follower的大，follower更新它的leader id \tMsgHeartbeat MessageType = 8 // 心跳响应；  // leader收到后就知道有哪些follower响应了。  // 只有当leader的最后提交index比follower的Match index大时，leader执行“sendAppend”方法 \tMsgHeartbeatResp MessageType = 9 // 表明请求没有被交付；  // 当“MsgUnreachable”被传送到leader的Step方法，leader发现follower无法到达，很有可能“MsgApp”都丢失了。当follower的进度状态为复制时，leader设置它回probe（哨兵） \tMsgUnreachable MessageType = 10 // 表明快照安装消息的结果  // 当一个follower拒绝了“MsgSnap”，这显示快照请求失败了--因为网络原因；**leader认为follower成为哨兵了**?(Then leader considers follower\u0026#39;s progress as probe.)；  // 当“MsgSnap”没有被拒绝，它表明快照成功了，leader设置follower的进度为哨兵，并恢复它的日志复制 \tMsgSnapStatus MessageType = 11 MsgCheckQuorum MessageType = 12 MsgTransferLeader MessageType = 13 MsgTimeoutNow MessageType = 14 MsgReadIndex MessageType = 15 MsgReadIndexResp MessageType = 16 // \u0026#34;MsgPreVote\u0026#34;和“MsgPreVoteResp”用在可选的两阶段选举协议上；  // 当Config.PreVote为true，将会进行一次预选举，除非预选举表明竞争节点会赢，否则没有节点会增加它们的term值。  // 这最小化了**一个发生了分区的节点重新加入到集群时**会带来的中断/干扰 \tMsgPreVote MessageType = 17 MsgPreVoteResp MessageType = 18 ) 实现 #  使用 #  "}]