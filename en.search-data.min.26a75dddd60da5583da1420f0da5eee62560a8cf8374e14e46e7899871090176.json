[{"id":0,"href":"/posts/2021/01/proxy-between-layer/","title":"go实现AOP","section":"01","content":"go实现AOP #  假设有store，从数据库获取数据，其中有方法IUserStore.GetByID，传入id参数，返回用户信息:\ntype IUserStore interface { GetByID(ctx context.Context, id int) (User, error) } 另外有service，刚好有用户id并且需要拿到用户信息，于是依赖了上述IUserStore：\ntype IUserSrv interface { CheckUser(ctx context.Context, id int) error // 获取用户信息，然后检查用户某些属性 } type userImpl struct { userStore IUserStore } func (impl userImpl) CheckUser(ctx context.Context, id int) error { user, err := impl.userStore.GetByID(ctx, id) if err != nil { return err } // 使用user数据做一些操作  _ = user } 上面所描述的是一个最简单的情况，如果我们要在userImpl.CheckUser里对impl.userStore.GetByID方法调用添加耗时统计，依然十分简单。\nfunc (impl userImpl) CheckUser(ctx context.Context, id int) error { begin := time.Now() user, err := impl.userStore.GetByID(ctx, id) if err != nil { return err } fmt.Println(time.Since(begin)) // 统计耗时  // 使用user数据做一些操作  _ = user } 但是，如果方法里调用的类似impl.userStore.GetByID的方法非常之多，逻辑非常之复杂时，这样一个一个的添加，必然非常麻烦、非常累。\n这时，如果有一个层间代理能帮我们拦截store的方法调用，在调用前后添加上耗时统计，势必能大大提升我们的工作效率。\n比如：\nfunc Around(f func(args []interface{}) []interface{}, args []interface{}) []interface{} { begin := time.Now() r := f(args) fmt.Println(time.Since(begin)) // 统计耗时  return r } 这只是一个简单的包装函数，怎么能将它与上面的接口联系到一起呢？\n有兴趣的话，可以看这里的实现 #  可以看到，主要的方法是Around(provider interface{}, mock interface{}, arounder Arounder) interface{}， 其中provider参数是类似NewXXX() IXXX的函数，而mock是IXXX接口的一个实现，最后的Arounder是 拥有方法Around(pctx ProxyContext, method reflect.Value, args []reflect.Value) []reflect.Value的接口。\n这里的示例 #  可以看到，mock结构是长这样的：\ntype UserMock struct { AddFunc func(name string) int GetHelper func(id int) string `method:\u0026#34;Get\u0026#34;` // 表示这个字段关联的方法是Get \tGetContextFunc func(ctx context.Context, id int) string } 所以，为了提升开发效率，我还写了一个 工具，用来根据接口生成相应的mock结构体。\n"},{"id":1,"href":"/posts/2021/01/hugo-blog/","title":"hugo搭建博客","section":"01","content":"操作 #    安装hugo。\n  使用hugo新建项目\n  添加主题\n  启动博客\n  "},{"id":2,"href":"/posts/2020/12/go-ctx/","title":"go ctx","section":"12","content":"ctx #  1.why\ngoroutine号称百万之众，互相之间盘根错节，难以管理控制。为此，必须提供一种机制来管理控制它们。\n各自为战 #  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // start first  go func() { fmt.Println(1) }() // start second  go func() { fmt.Println(2) }() time.Sleep(time.Second) } 万法归一 #  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { wg := new(sync.WaitGroup) // start first  wg.Add(1) go func() { defer wg.Done() fmt.Println(1) }() // start second  wg.Add(1) go func() { defer wg.Done() fmt.Println(2) }() wg.Wait() } 可以看到使用waitgroup可以控制多个goroutine必须互相等待，直到最后一个完成才会全部完成。\n明修栈道暗度陈仓 #  package main import ( \u0026#34;fmt\u0026#34; ) func main() { ch1 := make(chan int) ch2 := make(chan int) // start first  go func() { fmt.Println(1) \u0026lt;-ch2 ch1 \u0026lt;- 1 }() ch3 := make(chan int) // start second  go func() { fmt.Println(2) ch2 \u0026lt;- 2 \u0026lt;-ch1 // escape  ch3 \u0026lt;- 3 }() n := \u0026lt;-ch3 fmt.Println(n) } 使用chan的话，可以实现goroutine之间的消息同步\n2.what\n Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.\n\u0026ndash; 提供标准库context，定义了Context类型，带有限期、取消信息和其它请求域里的跨API边界和进程间的值。\n3.how\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { var n time.Duration = 2 now := time.Now() ctx, cancel := context.WithDeadline(context.Background(), now.Add(time.Second*n)) _ = cancel fmt.Println(now) // start first  go func(ctx context.Context) { select { case \u0026lt;-ctx.Done(): } fmt.Println(time.Now(), 1) }(ctx) // start second  go func(ctx context.Context) { select { case \u0026lt;-ctx.Done(): } fmt.Println(time.Now(), 2) }(ctx) time.Sleep(time.Second * (n - 1)) fmt.Println(time.Now()) // 一秒钟之后取消的话，两个goroutine会在取消后马上执行；如果等到时间到期了，就会在两秒后执行；  // cancel()  // fmt.Println(time.Now())  time.Sleep(time.Second * (n + 1)) } 4.others\n"},{"id":3,"href":"/posts/2021/01/pstree/","title":"pstree进程树及说明","section":"01","content":"pstree进程树及说明 #   "},{"id":4,"href":"/posts/2021/07/linux-epoll/","title":"Linux Epoll","section":"07","content":"linux epoll #   wiki\n 手册\nwhy #  what #  Linux内核的可扩展I/O事件通知机制。\n于Linux 2.5.44首度登场，它设计目的旨在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能（举例来说：旧有的系统函数所花费的时间复杂度为O(n)，epoll的时间复杂度O(log n)）。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。\nhow #  epoll 通过使用红黑树(RB-tree)搜索被监控的文件描述符(file descriptor)。\n在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。\nint epoll_create(int size); 在内核中创建epoll实例并返回一个epoll文件描述符。\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 向 epfd 对应的内核epoll 实例添加、修改或删除对 fd 上事件 event 的监听。op 可以为 EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别对应的是添加新的事件，修改文件描述符上监听的事件类型，从实例上删除一个事件。如果 event 的 events 属性设置了 EPOLLET flag，那么监听该事件的方式是边缘触发。\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 当 timeout 为 0 时，epoll_wait 永远会立即返回。而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。\n触发模式 #  epoll提供边沿触发及状态触发模式。\n在边沿触发模式中，epoll_wait仅会在新的事件首次被加入epoll队列时返回；在状态触发模式下，epoll_wait在事件状态未变更前将不断被触发。状态触发模式是默认的模式。\n状态触发模式与边沿触发模式有读和写两种情况，我们先来考虑读的情况。假设我们注册了一个读事件到epoll实例上，epoll实例会通过epoll_wait返回值的形式通知我们哪些读事件已经就绪。简单地来说，在状态触发模式下，如果读事件未被处理，该事件对应的内核读缓冲器非空，则每次调用epoll_wait时返回的事件列表都会包含该事件，直到该事件对应的内核读缓冲器为空为止。而在边沿触发模式下，读事件就绪后只会通知一次，不会反复通知。\n然后我们再考虑写的情况。状态触发模式下，只要文件描述符对应的内核写缓冲器未满，就会一直通知可写事件。而在边沿触发模式下，内核写缓冲器由满变为未满后，只会通知一次可写事件。\n举例来说，倘若有一个已经于epoll注册之流水线接获资料，epoll_wait将返回，并发出资料读取的信号。现假设缓冲器的资料仅有部分被读取并处理，在level-triggered(状态触发)模式下，任何对epoll_wait之调用都将即刻返回，直到缓冲器中的资料全部被读取；然而，在edge-triggered(边缘触发)的情境下，epoll_wait仅会于再次接收到新资料(亦即，新资料被写入流水线)时返回。\n边沿触发模式 #  边沿触发模式使得程序有可能在用户态缓存 IO 状态。nginx 使用的是边沿触发模式。\n文件描述符有两种情况是推荐使用边沿触发模式的。\n read 或者 write 系统调用返回了 EAGAIN。 非阻塞的文件描述符。  可能的缺陷：\n如果 IO 空间很大，你要花很多时间才能把它一次读完，这可能会导致饥饿。举个例子，假设你在监听一个文件描述符列表，而某个文件描述符上有大量的输入（不间断的输入流），那么你在读完它的过程中就没空处理其他就绪的文件描述符。（因为边沿触发模式只会通知一次可读事件，所以你往往会想一次把它读完。）一种解决方案是，程序维护一个就绪队列，当 epoll 实例通知某文件描述符就绪时将它在就绪队列数据结构中标记为就绪，这样程序就会记得哪些文件描述符等待处理。Round-Robin 循环处理就绪队列中就绪的文件描述符即可。\n如果你缓存了所有事件，那么一种可能的情况是 A 事件的发生让程序关闭了另一个文件描述符 B。但是内核的 epoll 实例并不知道这件事，需要你从 epoll 删除掉。\n"},{"id":5,"href":"/posts/2021/12/etcd/","title":"Etcd","section":"12","content":"etcd #  raft #  实现 #  使用 #  "}]