[{"id":0,"href":"/posts/2021/12/dbeaver/","title":"数据库管理工具之dbeaver","section":"12","content":" dbeaver: github\n 下载页\n面向开发者、SQL 编程人员、数据库管理员和分析人员的免费的多平台数据库工具。 支持任何已有 JDBC 驱动的数据库（基本上是任何数据库）。商业版本还额外支持非 JDBC 数据源，比如：MongoDB, Cassandra, Couchbase, Redis, BigTable, DynamoDB 等。\n拥有的特性：元数据编辑、SQL 编辑、富文本编辑、ER 图、数据导出/导入/转译、SQL 执行计划等。 基于 Eclipse 平台。 使用插件架构，为以下数据库提供额外功能：MySQL/MariaDB, PostgreSQL, Greenplum, Oracle, DB2 LUW, Exasol, SQL Server, Sybase/SAP ASE, SQLite, Firebird, H2, HSQLDB, Derby, Teradata, Vertica, Netezza, Informix 等。\n Free multi-platform database tool for developers, SQL programmers, database administrators and analysts. Supports any database which has JDBC driver (which basically means - ANY database). Commercial versions also support non-JDBC datasources such as MongoDB, Cassandra, Couchbase, Redis, BigTable, DynamoDB, etc. You can find the list of all databases supported in commercial versions here.\nHas a lot of features including metadata editor, SQL editor, rich data editor, ERD, data export/import/migration, SQL execution plans, etc. Based on Eclipse platform. Uses plugins architecture and provides additional functionality for the following databases: MySQL/MariaDB, PostgreSQL, Greenplum, Oracle, DB2 LUW, Exasol, SQL Server, Sybase/SAP ASE, SQLite, Firebird, H2, HSQLDB, Derby, Teradata, Vertica, Netezza, Informix, etc.\n "},{"id":1,"href":"/posts/2021/12/domain/","title":"Domain-oriented development","section":"12","content":"面向领域开发。\n将业务复杂度和技术复杂度分开，逐个击破。\n分离领域，各司其职。\n降低复杂度，容易测试。\nDDD 尝试 #  order.go:\npackage domain import ( \u0026#34;crypto/rand\u0026#34; \u0026#34;math/big\u0026#34; \u0026#34;github.com/pkg/errors\u0026#34; ) // 关键词：用户、店铺、商品、订单 // // 场景描述：店铺展示商品，其价格为P、库存为N，用户（余额为Y）看到商品觉得合适，于是下单购买B个； // 购买前，用户余额Y必须不小于P，商品库存N不小于B；购买后，用户余额减少P，库存减少B； // // 先不考虑并发情况，建立此时的领域模型  type User struct { name string // 名称  phone string // 电话  balance Money // 余额 } type Shop struct { name string // 名称  addr string // 地址 } type Product struct { name string // 名称  price Money // 价格  stock int // 库存  ownShop *Shop // 所属商铺 } type Order struct { name string // 名称  user *User // 用户  product *Product // 商品 } type Money int func NewUser(name, phone string, bal Money) *User { return \u0026amp;User{ name: name, phone: phone, balance: bal, } } func (u *User) Balance() Money { return u.balance } func (u *User) DeductBalance(amount Money) { if u.balance \u0026lt; amount { panic(\u0026#34;not enough money\u0026#34;) } u.balance -= amount } func NewShop(name, addr string) *Shop { return \u0026amp;Shop{ name: name, addr: addr, } } func NewProduct(name string, price Money, stock int, shop *Shop) *Product { return \u0026amp;Product{ name: name, price: price, stock: stock, ownShop: shop, } } func (p *Product) Stock() int { return p.stock } func (p *Product) DeductStock(c int) { if p.stock \u0026lt; c { panic(\u0026#34;not enough stock\u0026#34;) } p.stock -= c } // NewOrder 用户对商品下单c个 func NewOrder(user *User, product *Product, c int) *Order { name, err := GenerateRandomString(12) if err != nil { panic(err) } user.DeductBalance(product.price * Money(c)) product.DeductStock(c) return \u0026amp;Order{ name: name, user: user, product: product, } } func (o *Order) User() *User { return o.user } func (o *Order) Product() *Product { return o.product } // GenerateRandomString 随机字符串包含有数字和大小写字母 func GenerateRandomString(n int) (string, error) { const ( letters = \u0026#34;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\u0026#34; ) return generate(n, letters) } func generate(n int, letters string) (string, error) { ret := make([]byte, n) for i := 0; i \u0026lt; n; i++ { num, err := rand.Int(rand.Reader, big.NewInt(int64(len(letters)))) if err != nil { return \u0026#34;\u0026#34;, errors.WithStack(err) } ret[i] = letters[num.Int64()] } return string(ret), nil } order_test.go:\npackage domain_test import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/donnol/blog/demo/go/domain\u0026#34; ) func TestNewOrder(t *testing.T) { type args struct { user *domain.User product *domain.Product c int } tests := []struct { name string args args want *domain.Order }{ {name: \u0026#34;\u0026#34;, args: args{ user: domain.NewUser(\u0026#34;jd\u0026#34;, \u0026#34;123\u0026#34;, 10000), product: domain.NewProduct(\u0026#34;树莓派\u0026#34;, 1000, 10, domain.NewShop(\u0026#34;a shop\u0026#34;, \u0026#34;zhongshan\u0026#34;)), c: 1, }, want: nil}, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := domain.NewOrder( tt.args.user, tt.args.product, tt.args.c, ); got.User().Balance() != 9000 || got.Product().Stock() != 9 { t.Logf(\u0026#34;user: %+v, product: %+v\\n\u0026#34;, got.User(), got.Product()) t.Errorf(\u0026#34;NewOrder() = %v, want %v\u0026#34;, got, tt.want) } }) } } "},{"id":2,"href":"/posts/2021/12/github_action_deploy_hugo_blog/","title":"github action deploy hugo blog","section":"12","content":"why #  为了将视线保持在文章上，减少构建和发布的时间占用。\nwhat #  github action是GitHub推出的持续集成/持续部署工具，只需要在项目中添加workflow.yml配置文件，在其中配置好任务、工作、步骤等，即可在指定动作发生时自动触发编排好的动作。换言之，如果我们在我们的博客仓库里配置了自动将内容打包和发布的workflow.yml，那我们就可以把精力集中在文章的编写，然后轻轻地提交推送，即可完成博客地打包和发布，very easy and smooth。\nhow #  在github准备一个blog仓库，用于存放原始信息；再准备一个github page仓库，用于存放打包数据。\n其中github page仓库已开启page，可以通过github page设置的域名访问。\n 我的blog仓库\n 我的github page仓库\nworkflow #   这是我结合网络各位英豪所总结出来的一个workflow.yml配置文件\nname: blog # 做什么都好，别忘了先起个平凡（kuxuan）的名字 on: # 指定触发动作 push: # 动作是：git push branches: - main # 指定分支： main jobs: build-deploy: runs-on: ubuntu-latest # 基于ubuntu steps: - uses: actions/checkout@v2 # 切换分支：git checkout with: submodules: recursive  # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo # 博客所用的打包和部署工具 uses: peaceiris/actions-hugo@v2 with: hugo-version: latest - name: Build # 打包 run: hugo --minify --baseURL=https://donnol.github.io # 指定base url，确保构建出来的内容里的超链接都在它里面 - name: Deploy # 部署 uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 这个key非常关键，一言两语很难讲清楚 external_repository: donnol/donnol.github.io # 我的github page所在的仓库 PUBLISH_BRANCH: main PUBLISH_DIR: ./public # 将本仓库的public目录下的内容提交到github page仓库 commit_message: ${{ github.event.head_commit.message }} # 提交信息 以铜为镜，可以正衣冠；以人为镜，可以明得失； 以史为镜，可以知兴替。\ndeploy key #    使用ssh-keygen生产一对非对称秘钥（包含有公钥、私钥）\n  在github page(我这里是donnol/donnol.github.io)的仓库的setting里的deploy里添加公钥\n  在blog仓库setting的secrets里添加私钥，注意命名必须是workflow里使用的名称(如上述：ACTIONS_DEPLOY_KEY)\n  Q\u0026amp;A #  遇到问题不要惊慌，阿Q怕的是强者，如果你示弱，结果可想而知。\n当然，实在搞不懂，也可以在issue里提问，本人不负责任地想回就回。\n温馨提示 #  如果想知道更详细的信息，请自行搜索关键词，网络大神比比皆是，学习资料处处有售，生活实践时时待你。\n"},{"id":3,"href":"/posts/2021/01/proxy-between-layer/","title":"go实现AOP","section":"01","content":"go实现AOP #  假设有store，从数据库获取数据，其中有方法IUserStore.GetByID，传入id参数，返回用户信息:\ntype IUserStore interface { GetByID(ctx context.Context, id int) (User, error) } 另外有service，刚好有用户id并且需要拿到用户信息，于是依赖了上述IUserStore：\ntype IUserSrv interface { CheckUser(ctx context.Context, id int) error // 获取用户信息，然后检查用户某些属性 } type userImpl struct { userStore IUserStore } func (impl userImpl) CheckUser(ctx context.Context, id int) error { user, err := impl.userStore.GetByID(ctx, id) if err != nil { return err } // 使用user数据做一些操作  _ = user } 上面所描述的是一个最简单的情况，如果我们要在userImpl.CheckUser里对impl.userStore.GetByID方法调用添加耗时统计，依然十分简单。\nfunc (impl userImpl) CheckUser(ctx context.Context, id int) error { begin := time.Now() user, err := impl.userStore.GetByID(ctx, id) if err != nil { return err } fmt.Println(time.Since(begin)) // 统计耗时  // 使用user数据做一些操作  _ = user } 但是，如果方法里调用的类似impl.userStore.GetByID的方法非常之多，逻辑非常之复杂时，这样一个一个的添加，必然非常麻烦、非常累。\n这时，如果有一个层间代理能帮我们拦截store的方法调用，在调用前后添加上耗时统计，势必能大大提升我们的工作效率。\n比如：\nfunc Around(f func(args []interface{}) []interface{}, args []interface{}) []interface{} { begin := time.Now() r := f(args) fmt.Println(time.Since(begin)) // 统计耗时  return r } 这只是一个简单的包装函数，怎么能将它与上面的接口联系到一起呢？\n有兴趣的话，可以看这里的实现 #  可以看到，主要的方法是Around(provider interface{}, mock interface{}, arounder Arounder) interface{}， 其中provider参数是类似NewXXX() IXXX的函数，而mock是IXXX接口的一个实现，最后的Arounder是 拥有方法Around(pctx ProxyContext, method reflect.Value, args []reflect.Value) []reflect.Value的接口。\n这里的示例 #  可以看到，mock结构是长这样的：\ntype UserMock struct { AddFunc func(name string) int GetHelper func(id int) string `method:\u0026#34;Get\u0026#34;` // 表示这个字段关联的方法是Get \tGetContextFunc func(ctx context.Context, id int) string } 所以，为了提升开发效率，我还写了一个 工具，用来根据接口生成相应的mock结构体。\n"},{"id":4,"href":"/posts/2021/01/hugo-blog/","title":"hugo搭建博客","section":"01","content":"操作 #    安装hugo。\n  使用hugo新建项目\n  添加主题\n  启动博客\n  "},{"id":5,"href":"/posts/2020/12/go-ctx/","title":"go ctx","section":"12","content":"ctx #  1.why\ngoroutine号称百万之众，互相之间盘根错节，难以管理控制。为此，必须提供一种机制来管理控制它们。\n各自为战 #  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // start first  go func() { fmt.Println(1) }() // start second  go func() { fmt.Println(2) }() time.Sleep(time.Second) } 万法归一 #  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { wg := new(sync.WaitGroup) // start first  wg.Add(1) go func() { defer wg.Done() fmt.Println(1) }() // start second  wg.Add(1) go func() { defer wg.Done() fmt.Println(2) }() wg.Wait() } 可以看到使用waitgroup可以控制多个goroutine必须互相等待，直到最后一个完成才会全部完成。\n明修栈道暗度陈仓 #  package main import ( \u0026#34;fmt\u0026#34; ) func main() { ch1 := make(chan int) ch2 := make(chan int) // start first  go func() { fmt.Println(1) \u0026lt;-ch2 ch1 \u0026lt;- 1 }() ch3 := make(chan int) // start second  go func() { fmt.Println(2) ch2 \u0026lt;- 2 \u0026lt;-ch1 // escape  ch3 \u0026lt;- 3 }() n := \u0026lt;-ch3 fmt.Println(n) } 使用chan的话，可以实现goroutine之间的消息同步\n2.what\n Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.\n\u0026ndash; 提供标准库context，定义了Context类型，带有限期、取消信息和其它请求域里的跨API边界和进程间的值。\n3.how\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { var n time.Duration = 2 now := time.Now() ctx, cancel := context.WithDeadline(context.Background(), now.Add(time.Second*n)) _ = cancel fmt.Println(now) // start first  go func(ctx context.Context) { select { case \u0026lt;-ctx.Done(): } fmt.Println(time.Now(), 1) }(ctx) // start second  go func(ctx context.Context) { select { case \u0026lt;-ctx.Done(): } fmt.Println(time.Now(), 2) }(ctx) time.Sleep(time.Second * (n - 1)) fmt.Println(time.Now()) // 一秒钟之后取消的话，两个goroutine会在取消后马上执行；如果等到时间到期了，就会在两秒后执行；  // cancel()  // fmt.Println(time.Now())  time.Sleep(time.Second * (n + 1)) } 4.others\n"},{"id":6,"href":"/posts/2021/01/pstree/","title":"pstree进程树及说明","section":"01","content":"pstree进程树及说明 #   "},{"id":7,"href":"/posts/2021/07/linux-epoll/","title":"Linux Epoll","section":"07","content":"linux epoll #   wiki\n 手册\nwhy #  what #  Linux内核的可扩展I/O事件通知机制。\n于Linux 2.5.44首度登场，它设计目的旨在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能（举例来说：旧有的系统函数所花费的时间复杂度为O(n)，epoll的时间复杂度O(log n)）。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。\nhow #  epoll 通过使用红黑树(RB-tree)搜索被监控的文件描述符(file descriptor)。\n在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。\nint epoll_create(int size); 在内核中创建epoll实例并返回一个epoll文件描述符。\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 向 epfd 对应的内核epoll 实例添加、修改或删除对 fd 上事件 event 的监听。op 可以为 EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别对应的是添加新的事件，修改文件描述符上监听的事件类型，从实例上删除一个事件。如果 event 的 events 属性设置了 EPOLLET flag，那么监听该事件的方式是边缘触发。\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 当 timeout 为 0 时，epoll_wait 永远会立即返回。而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。\n触发模式 #  epoll提供边沿触发及状态触发模式。\n在边沿触发模式中，epoll_wait仅会在新的事件首次被加入epoll队列时返回；在状态触发模式下，epoll_wait在事件状态未变更前将不断被触发。状态触发模式是默认的模式。\n状态触发模式与边沿触发模式有读和写两种情况，我们先来考虑读的情况。假设我们注册了一个读事件到epoll实例上，epoll实例会通过epoll_wait返回值的形式通知我们哪些读事件已经就绪。简单地来说，在状态触发模式下，如果读事件未被处理，该事件对应的内核读缓冲器非空，则每次调用epoll_wait时返回的事件列表都会包含该事件，直到该事件对应的内核读缓冲器为空为止。而在边沿触发模式下，读事件就绪后只会通知一次，不会反复通知。\n然后我们再考虑写的情况。状态触发模式下，只要文件描述符对应的内核写缓冲器未满，就会一直通知可写事件。而在边沿触发模式下，内核写缓冲器由满变为未满后，只会通知一次可写事件。\n举例来说，倘若有一个已经于epoll注册之流水线接获资料，epoll_wait将返回，并发出资料读取的信号。现假设缓冲器的资料仅有部分被读取并处理，在level-triggered(状态触发)模式下，任何对epoll_wait之调用都将即刻返回，直到缓冲器中的资料全部被读取；然而，在edge-triggered(边缘触发)的情境下，epoll_wait仅会于再次接收到新资料(亦即，新资料被写入流水线)时返回。\n边沿触发模式 #  边沿触发模式使得程序有可能在用户态缓存 IO 状态。nginx 使用的是边沿触发模式。\n文件描述符有两种情况是推荐使用边沿触发模式的。\n read 或者 write 系统调用返回了 EAGAIN。 非阻塞的文件描述符。  可能的缺陷：\n如果 IO 空间很大，你要花很多时间才能把它一次读完，这可能会导致饥饿。举个例子，假设你在监听一个文件描述符列表，而某个文件描述符上有大量的输入（不间断的输入流），那么你在读完它的过程中就没空处理其他就绪的文件描述符。（因为边沿触发模式只会通知一次可读事件，所以你往往会想一次把它读完。）一种解决方案是，程序维护一个就绪队列，当 epoll 实例通知某文件描述符就绪时将它在就绪队列数据结构中标记为就绪，这样程序就会记得哪些文件描述符等待处理。Round-Robin 循环处理就绪队列中就绪的文件描述符即可。\n如果你缓存了所有事件，那么一种可能的情况是 A 事件的发生让程序关闭了另一个文件描述符 B。但是内核的 epoll 实例并不知道这件事，需要你从 epoll 删除掉。\n"},{"id":8,"href":"/posts/2021/12/etcd/","title":"Etcd","section":"12","content":"etcd #  raft #  介绍 #   由多个节点组成的集群维护着一个可复制状态机的协议。通过复制日志来保持状态机的同步。 可理解的共识算法\n状态机以消息为输入。消息可以是一个本地定时器更新，或一条网络消息。输出一个3元结构：[]Messages, []LogEntries, NextState，分别是消息列表、日志条目列表、下个状态。同样状态的状态机，在相同输入时总是输出相同结果。\n 插曲 #  人、联系、共识\n人生下来，触摸着这个世界的人和物，做着或有趣或无聊的事，建立起或浅或深的联系。\n当两个人面对面时，就某个想法达成一致或不一致，非常容易。\n如果两个人不是面对面呢？\n如果不只两个人，同坐在祠堂里呢？\n如果不止两个人，还分散在不同地点呢？\n那么，为什么要达成共识呢？\n因为有些事必须达成共识才能执行，比如，两个人双向奔赴。\n如果彼此异心，一个向东，一个往南，事情就办不成了。\n所以，共识是大伙成事的前提。\n共识，除了就某件事所要达成的结果，也要考虑所使用的方法。\n有可能是步步为营，走一步算一步，也就是每走一步再就下一步达成共识。\n也有可能是，一次性就接下来的几步均达成共识，然后各自执行。\nmessage type #  // For description of different message types, see: // https://pkg.go.dev/go.etcd.io/etcd/raft/v3#hdr-MessageType type MessageType int32 const ( // 选举时使用；  // 如果节点是一个follower或candidate，它在选举超时前没有收到任何心跳，它就回传递MsgHup消息给它自己的Step方法，然后成为（或保持）一个candidate从而开启一个新的选举 \tMsgHup MessageType = 0 // 一个内部类型，它向leader发送一个类型为“MsgHeartbeat”的心跳信号  // 如果节点是一个leader，raft里的tick函数将会是“tickHeartbeat”，触发leader周期性地发送“MsgHeartbeat”消息给它的followers \tMsgBeat MessageType = 1 // 提议往它的日志条目里追加数据；  // 这是一个特别的类型，由follower反推提议给leader（正常是leader提议，follower执行）；  // 发给leader的话，leader调用“appendEntry”方法追加条目到它的日志里，然后调用“bcastAppend”方法发送这些条目给它的远端节点；  // 发给candidate的话，它们直接丢弃该消息  // 发给follower的话，follower会将消息存储到它们的信箱里。会把发送者的id一起存储，然后转发给leader。 \tMsgProp MessageType = 2 // 包含了要复制的日志条目  // leader调用“bcastAppend”（里面调用“sendAppend”），发送“一会要被复制的日志”消息；  // 当candidate收到消息后，在它的Step方法里，它马上回退为follower，因为这条消息表明已经存在一个有效leader了。  // candidate和follower均会返回一条“MsgAppResp”类型消息以作响应。 \tMsgApp MessageType = 3 // 调用“handlerAppendEntries”方法 \tMsgAppResp MessageType = 4 // 请求集群中的节点给自己投票；  // 当节点是follower或candidate，并且它们的Step方法收到了“MsgHup”消息，节点调用“campaign”方法去提议自己成为一个leader。一旦“campaign”方法被调用，节点成为candidate，并发送“MsgVote”给集群中的远端节点请求投票。  // 当leader或candidate的Step方法收到该消息，并且消息的Term比它们的Term小，“MsgVote”将被拒绝。  // 当leader或candidate收到的消息的Term要更大时，它会回退为follower。  // 当follower收到该消息，仅当发送者的最后的term比“MsgVote”的term要大，或发送者的最后term等于“MsgVote”的term（但发送者的最后提交index大于等于follower的）， \tMsgVote MessageType = 5 // 投票响应；  // 当candidate收到后，它会统计选票，如果大于majority（quorum），它成为leader并调用“bcastAppend”。如果candidate收到大量的否决票，它将回退到follower \tMsgVoteResp MessageType = 6 // 请求安装一个快照消息；  // 当一个节点刚成为leader，或者leader收到了“MsgProp”消息，它调用“bcastAppend”方法（里面再调用“sendAppend”）方法到每个follower。在“sendAppend”方法里，如果一个leader获取term或条目失败了，leader通过\u0026#34;MsgSnap\u0026#34;消息请求快照。 \tMsgSnap MessageType = 7 // leader发送心跳；  // 当candidate收到“MsgHeartbeat”，并且消息的term比candidate的大，candidate回退到follower并且更新它的提交index为这次心跳里的值。然后candidate发送消息到它的信箱。  // 当消息发送到follower的Step方法，并且消息的term比follower的大，follower更新它的leader id \tMsgHeartbeat MessageType = 8 // 心跳响应；  // leader收到后就知道有哪些follower响应了。  // 只有当leader的最后提交index比follower的Match index大时，leader执行“sendAppend”方法 \tMsgHeartbeatResp MessageType = 9 // 表明请求没有被交付；  // 当“MsgUnreachable”被传送到leader的Step方法，leader发现follower无法到达，很有可能“MsgApp”都丢失了。当follower的进度状态为复制时，leader设置它回probe（哨兵） \tMsgUnreachable MessageType = 10 // 表明快照安装消息的结果  // 当一个follower拒绝了“MsgSnap”，这显示快照请求失败了--因为网络原因；**leader认为follower成为哨兵了**?(Then leader considers follower\u0026#39;s progress as probe.)；  // 当“MsgSnap”没有被拒绝，它表明快照成功了，leader设置follower的进度为哨兵，并恢复它的日志复制 \tMsgSnapStatus MessageType = 11 MsgCheckQuorum MessageType = 12 MsgTransferLeader MessageType = 13 MsgTimeoutNow MessageType = 14 MsgReadIndex MessageType = 15 MsgReadIndexResp MessageType = 16 // \u0026#34;MsgPreVote\u0026#34;和“MsgPreVoteResp”用在可选的两阶段选举协议上；  // 当Config.PreVote为true，将会进行一次预选举，除非预选举表明竞争节点会赢，否则没有节点会增加它们的term值。  // 这最小化了**一个发生了分区的节点重新加入到集群时**会带来的中断/干扰 \tMsgPreVote MessageType = 17 MsgPreVoteResp MessageType = 18 ) raft, Node and RawNode #  type Node interface { // ... } func StartNode(...) Node { rn, err := NewRawNode(...) if err != nil { panic(err) } n := newNode(rn) go n.run() return \u0026amp;n } func NewRawNode(config *Config) (*RawNode, error) { r := newRaft(config) rn := \u0026amp;RawNode{ raft: r, } ... return rn, nil } type node struct { // impl Node interface  ... rn *RawNode } func newNode(rn *RawNode) node { return node{ ... } } 实现 #  使用 #  "},{"id":9,"href":"/posts/aboutme/about-me/","title":"About Me","section":"Posts","content":"一名默默无闻的打工仔，做着后端开发里的一点微末工作。\n当然怀抱着一夜暴富的乐观想法，希望每天平安快乐。\n也对一些事情无比憎恶，时刻提醒自己适可宜止。\n竟然也对各种球类运动感冒，偶尔踢出一片天地或抽出一道弧线。\n"}]