<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>简单博客 on 我的简单博客</title><link>https://donnol.github.io/</link><description>Recent content in 简单博客 on 我的简单博客</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 07 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://donnol.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>dbeaver手动导入驱动</title><link>https://donnol.github.io/posts/2023/12/dbeaver%E6%89%8B%E5%8A%A8%E5%AF%BC%E5%85%A5%E9%A9%B1%E5%8A%A8/</link><pubDate>Thu, 07 Dec 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/12/dbeaver%E6%89%8B%E5%8A%A8%E5%AF%BC%E5%85%A5%E9%A9%B1%E5%8A%A8/</guid><description>因为直接下载dbeaver的时候，是没有带上驱动文件的，所以需要在使用时下载。
但是，如果刚好安装的环境是无法通网的，那么就需要手动传入驱动并安装。
做法如下：
现在本地有网环境下载驱动文件 用dbeaver下载mysql的驱动，会存放在目录：C:\Users\{用户名}\AppData\Roaming\DBeaverData\drivers\maven\maven-central\mysql.
NOTE: 注意替换{用户名}为你本机实际名称。
把下好的文件传入到无网机器上，同样放到以上目录。
打开dbeaver，数据库-&amp;gt;驱动管理器，添加驱动
选中MySQL，然后点击编辑；在弹出框里切到库，将已有内容全部删掉，再点击添加文件夹，然后选择上面驱动存放的目录，即可确定保存。
如此，即可手动导入驱动文件。</description></item><item><title>Mysql 8.0.33在使用窗口函数的同时不能用count(distinct *)</title><link>https://donnol.github.io/posts/2023/10/mysql_count_distinct_with_over/</link><pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/10/mysql_count_distinct_with_over/</guid><description>Mysql 8.0.33在使用窗口函数的同时不能用count(distinct *)
比如，我想在窗口函数里使用字段apply_unit_id分组，然后求project_id列不重复值的数量：
select distinct apply_unit_id, count(distinct project_id) over (partition by apply_unit_id) from weia join weiag on weiag.apply_id = weia.id ; 此时报错：SQL 错误 [1235] [42000]: This version of MySQL doesn't yet support '&amp;lt;window function&amp;gt;(DISTINCT ..)'
怎么办呢？ # 使用 dense_rank()间接计算：
select distinct apply_unit_id, dense_rank() over (partition by apply_unit_id order by project_id) + dense_rank() over (partition by apply_unit_id order by project_id desc) - 1 from weia join weiag on weiag.apply_id = weia.</description></item><item><title>Wezterm极简配置文件</title><link>https://donnol.github.io/posts/2023/10/wezterm/</link><pubDate>Tue, 17 Oct 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/10/wezterm/</guid><description>Wezterm极简配置文件
-- Pull in the wezterm API local wezterm = require &amp;#39;wezterm&amp;#39; -- This table will hold the configuration. local config = {} -- In newer versions of wezterm, use the config_builder which will -- help provide clearer error messages if wezterm.config_builder then config = wezterm.config_builder() end -- This is where you actually apply your config choices -- For example, changing the color scheme: config.color_scheme = &amp;#39;AdventureTime&amp;#39; -- config.color_scheme = &amp;#39;Batman&amp;#39; config.</description></item><item><title>雪花id的时钟回退问题</title><link>https://donnol.github.io/posts/2023/09/%E9%9B%AA%E8%8A%B1id-%E6%97%B6%E9%92%9F%E5%9B%9E%E9%80%80%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 27 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/%E9%9B%AA%E8%8A%B1id-%E6%97%B6%E9%92%9F%E5%9B%9E%E9%80%80%E9%97%AE%E9%A2%98/</guid><description>雪花id由64位二进制组成，转成字符串则长为19. 它依赖于系统时钟，如果出现时钟回退，会导致已经在用的id再次被生成。
怎么办呢？
记录上次生成时间，在本次生成时比较时间，如果当前时间比上次生成时间要小，则认为时钟回拨，直接报错。也可以一直重试，直到当前时间不小于上次生成时间。
采用历史时间则天然的不存在时间回拨问题。但是在超高并发情况下，历史的时间很快用完，时间一直保持在最新时间的话，这个时候还是会出现时间回拨。
Go1.9开始，使用单调时钟: time.Now(), time.Since(), time.Until().
// # Monotonic Clocks
//
// Operating systems provide both a “wall clock,” which is subject to
// changes for clock synchronization, and a “monotonic clock,” which is
// not. The general rule is that the wall clock is for telling time and
// the monotonic clock is for measuring time. Rather than split the API,
// in this package the Time returned by time.</description></item><item><title>Go escape analysis</title><link>https://donnol.github.io/posts/2023/09/go_escape_analysis/</link><pubDate>Wed, 20 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/go_escape_analysis/</guid><description>The meaning of escapes to the heap is variables needs to be shared across the function stack frames [between main() and Println()] &amp;hellip;
&amp;hellip; So globally access variables must be moved to heap as it requires runtime. So the output line 11:2 shows the same as the data variable moved to the heap memory.
From</description></item><item><title>What are you preparing to do?</title><link>https://donnol.github.io/posts/2023/09/do/</link><pubDate>Wed, 20 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/do/</guid><description>他想做的事情，与你想他做的事情，与你在做的事情。
这些事情之间是否存在交集，如果一点都没有，那不就是事与愿违了吗？</description></item><item><title>查找并杀掉运行中事务</title><link>https://donnol.github.io/posts/2023/09/mysql/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/mysql/</guid><description> 查找并杀掉运行中事务 # -- 获取线程id然后杀掉 SELECT * FROM information_schema.innodb_trx; kill 36272; kill 36275; kill 35971; kill 35972; -- 其它 select * from performance_schema.events_statements_current; show processlist; 查看锁使用情况 # SELECT object_name, index_name, lock_type, lock_mode, lock_data FROM performance_schema.data_locks;</description></item><item><title>Vscode go cannot find GOROOT directory</title><link>https://donnol.github.io/posts/2023/09/goenv/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/goenv/</guid><description>今天发现在windows上的vscode一直提示找不到go：go: cannot find GOROOT directory: c:\msys64\mingw64\lib\go。
强制设置了go.goroot也不行，直到查看了GOENV文件（C:\Users\xxx\AppData\Roaming\go\env）之后，才发现里面有一行：GOROOT=c:\msys64\mingw64\lib\go，可能是当时在msys2安装go的时候加上的。
去掉它就恢复正常了。
$ go env set GOENV=C:\Users\xxx\AppData\Roaming\go\env set GOHOSTARCH=amd64 set GOHOSTOS=windows set GOMODCACHE=C:\Users\xxx\go\pkg\mod set GOOS=windows set GOPATH=C:\Users\xxx\go set GOPRIVATE= set GOPROXY=https://goproxy.cn,https://goproxy.io,direct set GOROOT=C:\Program Files\Go 应该是这样的，如果用go env -w 来设置goroot，那么这个值就会保存到GOENV对应的文件里，如果是$env:GOROOT=xxx的方式来设置则不会修改GOENV文件里的内容。这时候，如果vscode是优先从GOENV文件来获取GOROOT的话，就可能会导致与实际的GOROOT不一致。
所以，如果再遇到以上错误，除了echo $env:GOROOT 看一下环境变量值之外，也要看一下GOENV文件。</description></item><item><title>不同系统之间通过网络对接</title><link>https://donnol.github.io/posts/2023/09/%E7%B3%BB%E7%BB%9F%E9%97%B4%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E4%BA%A4%E4%BA%92%E4%BB%A5%E5%AE%8C%E6%88%90%E4%BA%8B%E5%8A%A1/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/%E7%B3%BB%E7%BB%9F%E9%97%B4%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E4%BA%A4%E4%BA%92%E4%BB%A5%E5%AE%8C%E6%88%90%E4%BA%8B%E5%8A%A1/</guid><description>不同系统之间通过网络对接
数据库事件 # 可以用个事件表来做，在事务执行过程中添加事件(确保事务完成时事件也存在)。
在事务提交之后，先尝试做一次事件，如果成功了就把事件状态置为成功；如果失败了也没关系，另外开定时器来扫表进行重试执行。 &amp;ndash; 此时不影响正常业务执行
在事件处理事务里的网络请求里加入超时控制，确保事件不会执行太久，导致接口过慢。
网络请求支持幂等，防止事件处理事务请求成功了，但是事务挂了导致状态未变更，这种情况下会重复请求多次。
skip locked实现 # -- 条件字段必须有索引(status, [name, status])，排序字段必须是主键(id)，此时刚好是所要锁定的行 start transaction; -- select * from w_event we where status in (1) order by create_time asc limit 1 for update skip locked; -- 引入create_time作为排序字段时，会将符合条件的行都锁住，`limit 1`不起作用 select * from w_event we where status in (1) order by id asc limit 1 for update skip locked; -- 使用主键字段作排序时，`limit 1`则起作用 select * from w_event we where name = &amp;#39;测试&amp;#39; and status in (1) order by id asc limit 1 for update skip locked; -- 如果有多个字段作为条件，需要建立组合索引 SELECT object_name, index_name, lock_type, lock_mode, lock_data FROM performance_schema.</description></item><item><title>do</title><link>https://donnol.github.io/posts/2023/09/your_life/</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/your_life/</guid><description>你在做的事情，是在重复已知的东西，还是在探索未知的东西。
这决定了所能达到的高度。</description></item><item><title>Go Empty Struct</title><link>https://donnol.github.io/posts/2023/09/go_empty_struct/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/go_empty_struct/</guid><description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) func main() { type A struct{} type B struct{} // 结构体里的字段都是`Empty Struct`时，占用空间为0 type S struct { A A B B } var s S fmt.Println(unsafe.Sizeof(s)) // prints 0 // 如果是指针，占用空间为8 fmt.Println(unsafe.Sizeof(&amp;amp;s)) // prints 8 var x [1000000000]struct{} // 可以同时存储A和B类型元素 x[0] = A{} x[1] = B{} fmt.Println(unsafe.Sizeof(x)) // prints 0 // 地址一样 fmt.Printf(&amp;#34;%p, %p&amp;#34;, &amp;amp;x[0], &amp;amp;x[1]) // 0x54e3a0, 0x54e3a0 } See also</description></item><item><title>Jupyter notebook</title><link>https://donnol.github.io/posts/2023/07/jupyter/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/07/jupyter/</guid><description>Install: pip install --user jupyter.
Install plugin: jupyter install matplotlib.
Install rust tools: cargo install evcxr_jupyter &amp;amp;&amp;amp; evcxr_jupyter --install.
Install plugin: jupyter install plotters.
Start: jupyter notebook --port 35222.</description></item><item><title>Vscode Translate</title><link>https://donnol.github.io/posts/2023/07/vscode_traslate/</link><pubDate>Tue, 25 Jul 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/07/vscode_traslate/</guid><description>试了几个vscode的翻译插件，包括Google Translate, Comment Translate, Translate Var。
来自intellsmi的Comment Translate最终脱颖而出。
它支持Google, Bing, Baidu等翻译工具。
设置：选择翻译工具Bing，再设置源语言和目标语言。
使用：选中单词即会自动翻译，非常方便。</description></item><item><title>Windows restart remote service</title><link>https://donnol.github.io/posts/2023/07/windows_restart_remote_service/</link><pubDate>Tue, 25 Jul 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/07/windows_restart_remote_service/</guid><description>Windows如何方便的重启远程服务器里的服务，在不使用远程连接的情况下？
注意：服务(名称：service-name)已在远程机器上创建。
在本机新建映射网络驱动器.
打开映射好的文件夹，在其中添加bat和ps1文件:
restart.bat:
@echo off for %%i in (service-name) do ( echo the service &amp;#39;%%i&amp;#39; is being starting... sc query %%i net stop %%i net start %%i sc query %%i echo service &amp;#39;%%i&amp;#39; started. ) pause restart.ps1:
$Username = &amp;#39;Name&amp;#39; $Password = &amp;#39;Password&amp;#39; $pass = ConvertTo-SecureString -AsPlainText $Password -Force $Cred = New-Object System.Management.Automation.PSCredential -ArgumentList $Username,$pass Invoke-Command -ComputerName [Remote-IP] -ScriptBlock { Get-Service WinRM } -credential $Cred Invoke-Command -ComputerName [Remote-IP] -credential $Cred -ScriptBlock { E:\win-dms4\restart.</description></item><item><title>错误的定义和返回</title><link>https://donnol.github.io/posts/2023/07/error/</link><pubDate>Fri, 21 Jul 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/07/error/</guid><description>错误的定义和返回
错误的定义 # 错误粒度：太细则既多又杂，太宽则毫无意义。
个人觉得一般需要的错误有以下：正常、参数错误、业务错误、内部错误、返回错误。业务错误又有：无权限、处理超时、无记录、已经存在。
可参照 GRPC的实现。
Code Number Description OK 0 Not an error; returned on success. CANCELLED 1 The operation was cancelled, typically by the caller. UNKNOWN 2 Unknown error. For example, this error may be returned when a Status value received from another address space belongs to an error space that is not known in this address space. Also errors raised by APIs that do not return enough error information may be converted to this error.</description></item><item><title>Prometheus start failed</title><link>https://donnol.github.io/posts/2023/07/prometheus/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/07/prometheus/</guid><description>Question # prometheus start failed:
... ts=2023-07-06T01:34:43.871Z caller=repair.go:57 level=info component=tsdb msg=&amp;#34;Found healthy block&amp;#34; mint=1688493607159 maxt=1688515200000 ulid=01H4J6TB6NCBZFNR9XZ1R2P67H ts=2023-07-06T01:34:43.871Z caller=repair.go:57 level=info component=tsdb msg=&amp;#34;Found healthy block&amp;#34; mint=1688529607159 maxt=1688536800000 ulid=01H4JDM4YR6J3TJVBY6P6EGZS4 ts=2023-07-06T01:34:43.872Z caller=repair.go:57 level=info component=tsdb msg=&amp;#34;Found healthy block&amp;#34; mint=1688536807159 maxt=1688544000000 ulid=01H4JMFGKWY1MAM7GBFDQ89FRV ts=2023-07-06T01:34:43.872Z caller=main.go:696 level=info msg=&amp;#34;Stopping scrape discovery manager...&amp;#34; ts=2023-07-06T01:34:43.872Z caller=main.go:710 level=info msg=&amp;#34;Stopping notify discovery manager...&amp;#34; ts=2023-07-06T01:34:43.872Z caller=main.go:732 level=info msg=&amp;#34;Stopping scrape manager...&amp;#34; ts=2023-07-06T01:34:43.872Z caller=manager.go:946 level=info component=&amp;#34;rule manager&amp;#34; msg=&amp;#34;Stopping rule manager...&amp;#34; ts=2023-07-06T01:34:43.872Z caller=manager.go:956 level=info component=&amp;#34;rule manager&amp;#34; msg=&amp;#34;Rule manager stopped&amp;#34; ts=2023-07-06T01:34:43.</description></item><item><title>Compare and Order</title><link>https://donnol.github.io/posts/2023/07/compare_order/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/07/compare_order/</guid><description>比，争。
比较，争先。
拿他与她比，让他与她争。
做黄雀，做渔翁。
不比，不争。
不付出无收获？
丛林社会，谈何付出，谈何收获。
有付出也无收获。</description></item><item><title>ml sklearn</title><link>https://donnol.github.io/posts/2023/06/sklearn/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/06/sklearn/</guid><description>尝试 # $ pip install scikit-learn $ python3.10 &amp;gt;&amp;gt;&amp;gt; from sklearn.datasets import load_iris &amp;gt;&amp;gt;&amp;gt; from sklearn.linear_model import LogisticRegression &amp;gt;&amp;gt;&amp;gt; data, y = load_iris(return_X_y=True) &amp;gt;&amp;gt;&amp;gt; clf = LogisticRegression(random_state=0, max_iter=1000).fit(data, y) &amp;gt;&amp;gt;&amp;gt; clf.predict(data[:2, :]) &amp;gt;&amp;gt;&amp;gt; clf.predict_proba(data[:2, :]) &amp;gt;&amp;gt;&amp;gt; clf.score(data, y) 查找操作记录 # cat ~/.python_history.
模型、策略、优化算法 # 模型是输入输出函数：Y = F(X).
策略是拟合过程的损失函数：L(Y, F(X)), 可以是均方误差、对数损失函数、交叉熵损失函数。
优化算法：确定模型和损失函数后，可以加速计算的方法，比如：随机梯度下降法、牛顿法、拟牛顿法。</description></item><item><title>windows route</title><link>https://donnol.github.io/posts/2023/06/route/</link><pubDate>Tue, 13 Jun 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/06/route/</guid><description>Windows通过route命令配置路由 # route add 192.168.0.0 mask 255.255.0.0 192.168.66.254 -p 192.168.0.0: 目标主机的网络地址
mask 255.255.0.0: 掩码，与目标网络地址对应
192.168.66.254: 网关地址
Linux通过ip route命令配置路由 # NOTE: ip route是route命令的升级版本，但route命令仍在大量使用。
# 设置192.168.4.0网段的网关为192.168.166.1,数据走wlan0接口 # /24 is the network prefix. The network prefix is the number of enabled bits in the subnet mask. # 24位子网掩码 ip route add 192.168.4.0/24 via 192.168.166.1 dev wlan0 # 255.255.255.0为子网掩码 # 3*8(255即是8位二进制) ip route add 192.168.0.0/255.255.255.0 dev eth0 子网掩码 # ip地址包含了网络地址和主机地址两部分，怎么区分呢？
这是就需要用到子网掩码了，它是一个与ip地址同位数、连续的数，可以用位数24表示，也可以用地址255.255.255.0表示。
两个地址经过位与运算后，ip中没被掩盖的部分即是网络地址，被掩盖的部分即是主机地址。</description></item><item><title>wsl2初始化Mysql数据库速度非常慢</title><link>https://donnol.github.io/posts/2023/06/wsl2/</link><pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/06/wsl2/</guid><description> wsl2版本 # &amp;gt; wsl.exe -v WSL version: 1.2.5.0 Kernel version: 5.15.90.1 WSLg version: 1.0.51 MSRDC version: 1.2.3770 Direct3D version: 1.608.2-61064218 DXCore version: 10.0.25131.1002-220531-1700.rs-onecore-base2-hyp Windows version: 10.0.19045.3031 使用过程中，因为磁盘空间问题，把子系统安装位置从C盘转移到了其它盘。
操作 # 把sql目录里的*.sql文件逐一导入到8.0.33版本的Mysql。
尽管sql文件不多也不大，但是整个过程非常慢。其中一个有一千个左右的INSERT IGNORE语句，更是用了将近12分钟才完成。
怎么办？ # 改为通过网络访问本机的数据库。
端口 # 一文中提到：
根据我的观察, 如果Windows本地启动了指定端口, 这时WSL2中虽然可以使用相同的端口, 但是localhost:port 将指向Windows的服务, WSL的服务将会被覆盖!
当然了, 如果我们配置了端口转发, 转发的IP是WSL的地址, 而不是localhost, 那么WSL将会覆盖Windows的服务!
而我的观察是，
我发现本地起了数据库服务之后，在wsl2里起数据库服务（mysql服务，端口都是3306）的情况下，是不会报端口重复绑定错误的。
但是如果我在wsl2里先起一个服务，绑定端口14222后，再在主机起相同服务，想绑定相同端口时，则会报错端口已被绑定。
如果我是先在主机起上述服务，然后再在wsl2起该服务，则能正常启动。那在主机访问localhost:[port]时会访问到哪个呢？此时访问到的是主机的服务。
所以端口是否占用会不会还跟服务起的顺序有关呢？
暂时未看到有确切的描述。
但是，经过上面的实验，可以认为：
先在主机起服务，再在wsl2起服务绑定相同端口时，服务可正常启动；在主机访问`localhost:[port]`时访问的是主机的服务；在wsl2里访问的则是wsl2的服务，除非手动指定主机IP。 而如果先在wsl2里起了服务，再在主机起服务（绑定相同端口: 14222），则会报错端口已被绑定。 但是，如果在wsl2里先起的mysql服务，再在主机起，则不会报错，所以还跟端口值有关？</description></item><item><title>flutter Widget Element</title><link>https://donnol.github.io/posts/2023/05/flutter_widget_element/</link><pubDate>Mon, 29 May 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/05/flutter_widget_element/</guid><description>Element # abstract class Element extends DiagnosticableTree implements BuildContext package:flutter/src/widgets/framework.dart
An instantiation of a [Widget] at a particular location in the tree. &amp;ndash; 在树里的特定位置上的一个Widget的实例。
Widgets describe how to configure a subtree but the same widget can be used to configure multiple subtrees simultaneously because widgets are immutable. An [Element] represents the use of a widget to configure a specific location in the tree. Over time, the widget associated with a given element can change, for example, if the parent widget rebuilds and creates a new widget for this location.</description></item><item><title>mysqlrouter使用</title><link>https://donnol.github.io/posts/2023/05/mysqlrouter/</link><pubDate>Tue, 16 May 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/05/mysqlrouter/</guid><description>What # mysqlrouter是一个代理，可以将查询转发到配置好的数据库服务里。
Why # 在办公室网络环境下基于win10 wsl2开发应用时，需要连接到主机所在局域网的其它机器上的数据库服务。
也就是说，存在机器：wsl2、主机、其它机器。
wsl2通过NAT网络模式与主机互通，并且wsl2可以访问外网。
但是wsl2不能访问到其它机器上的数据库服务，不知道是不是办公室网络环境存在限制。
为了使得wsl2能访问到其它机器上的数据库服务成立，在主机启动mysqlrouter充当代理，然后wsl2通过访问代理来访问其它机器。
Install # 可以使用mysql installer选择安装。
简单模式 # 配置文件（mysqlrouter.conf）：
[DEFAULT] logging_folder = D:/Data/mysqlrouter/log plugin_folder = C:/Program Files/MySQL/MySQL Router 8.0/lib # 这里是插件所在目录，必须是mysqlrouter安装路径下的目录，否则报错找不到插件 config_folder = D:/Data/mysqlrouter/etc # 启动配置默认查找目录，会在目录里寻找mysqlrouter.conf文件 runtime_folder = D:/Data/mysqlrouter/run data_folder = D:/Data/mysqlrouter/data [logger] level = DEBUG [routing:primary] bind_address=172.20.96.1 # 主机ip地址 bind_port=6446 # 主机监听端口 destinations = 172.17.39.239:3306 # 目标机器，也就是实际执行查询的数据库服务所在机器的地址 mode = read-write connect_timeout = 10 启动：mysqlrouter -c D:\Data\mysqlrouter\etc\mysqlrouter.conf
关闭防火墙或者配置规则允许端口通过。
在wsl2机器上访问：mysql -h 172.</description></item><item><title>NATS</title><link>https://donnol.github.io/posts/2023/04/nats/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/04/nats/</guid><description>是什么？ # Home, Github
NATS 是一个简单、安全和高性能的通信系统，适用于数字系统、服务和设备。
NATS 是一种允许以消息形式分段的数据交换的基础架构。
基于主题 # 发布者将消息发到主题；订阅者订阅主题，在有消息到来时消费该消息。
主题命名规则：
基本字符：a to z, A to Z and 0 to 9 (区分大小写，不能包含空白字符).
特殊字符: . (分割符，分割不同部分，每部分视为一个token)； * 和 &amp;gt; (通配符，*表示匹配一个token，&amp;gt;表示匹配一或多个token).
保留主题名称: 以 $ 开头的用在系统内部 (如：$SYS, $JS, $KV &amp;hellip;)
发布-订阅 # Core NATS: 一个主题，存在一个发布者，多个订阅者。
消息会复制到多个订阅者。
请求-响应 # A request is sent, and the application either waits on the response with a certain timeout, or receives a response asynchronously.
&amp;ndash; 请求发出后，应用要不等待响应超时，要不就异步收到一个响应。</description></item><item><title>Go Generic Join</title><link>https://donnol.github.io/posts/2023/01/go_generic_join/</link><pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/01/go_generic_join/</guid><description>// NestedJoin like nested loop join func NestedJoin[J, K, R any]( left []J, right []K, match func(J, K) bool, mapper func(J, K) R, ) []R { var r = make([]R, 0, len(left)) for _, j := range left { for _, k := range right { if !match(j, k) { continue } r = append(r, mapper(j, k)) } } return r } // HashJoin like hash join func HashJoin[K comparable, LE, RE, R any]( left []LE, right []RE, lk func(item LE) K, rk func(item RE) K, mapper func(LE, RE) R, ) []R { var r = make([]R, 0, len(left)) rm := KeyBy(right, rk) for _, le := range left { k := lk(le) re := rm[k] r = append(r, mapper(le, re)) } return r } Code From</description></item><item><title>Jump Table</title><link>https://donnol.github.io/posts/2022/07/jump_table/</link><pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/07/jump_table/</guid><description>What&amp;rsquo;s Jump Table? # A jump table can be either an array of pointers to functions or an array of machine code jump instructions. If you have a relatively static set of functions (such as system calls or virtual functions for a class) then you can create this table once and call the functions using a simple index into the array. This would mean retrieving the pointer and calling a function or jumping to the machine code depending on the type of table used.</description></item><item><title>数字计算之分摊</title><link>https://donnol.github.io/posts/2022/07/number_calculate/</link><pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/07/number_calculate/</guid><description>背景：分多次把一批货全部出清。
要求：需要确保这批货多次出清跟一次出清收的钱一样。
现有三个数字(可整数，可小数)：a b c，其中：a 为数量，b 为价格，c 为折扣。
则总额为: t, t = a*b*c
假设分三次，每次数量为：a1 a2 a3，则有：a = a1 + a2 + a3
直接计算： 第 1 次.
a1*b*c 第 2 次.
a2*b*c 第 3 次.
a3*b*c (a1+a2+a3)bc 不就等于 abc 了吗？
但是，如果考虑到小数乘法计算时的精度，比如：1.22*2.33 相乘后再取精度（保留两位小数），不就会导致数量误差了吗？
那如果取精度导致结果误差，那我不取精度，直接用所有小数位数来计算呢。
虽说可以，但小数位数是有可能非常多的，占用的空间也是一笔不小的开销。
引入中间量(可称为&amp;rsquo;余额&amp;rsquo;): x y z x = a y = x*b z = y*c 第 1 次.
x1 = (x-a1) y1 = (y-y*a1/x) z1 = (z-z*a1/x) t1 = z*a1/x 第 2 次.</description></item><item><title>泛型</title><link>https://donnol.github.io/posts/2022/05/generic/</link><pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/05/generic/</guid><description>泛型 # 是什么？ # Type parameter, 类型参数。func Add[T Number](x, y T) (r T)，其中的T就是类型参数，它被接口Number所约束。
type Number interface { int | float32 } 调用方除了可自行决定参数值之外，还可以自行决定参数类型。Add[int](1, 2)，在调用时指定T的类型为int，同时传入参数值1,2必须是int类型。
这样使得代码更灵活，更有扩展性，同时更安全。
Go泛型 # 为什么？ # 静态语言，类型固定，比如这个函数：func Add(x, y int) int就要求参数和结果都必须是整型。
那如果后来又需要一个浮点数的加法呢？
那使用interface{}不也可以吗？
试看：
// 准确的描述出了参数和返回值的类型，非常方便 func Add(x, y int) int // 但也限制了Add函数的参数类型--只能接收`int` // Add(0.1, 0.2) // can&amp;#39;t do that // 那怎么办呢？再写一个针对float64的呗 func AddFloat64(x, y float64) float64 AddFloat64(0.1, 0.2) // it&amp;#39;s ok // 如果还要支持其它类型呢？再加一个吗，每多一种类型，就多加一个。。。 func AddInt8(x, y int8) int8 func AddInt32(x, y int32) int32 func AddFloat32(x, y float32) float32 // more.</description></item><item><title>Find out which Go version built your binary</title><link>https://donnol.github.io/posts/2022/05/find_go_version_the_app_use/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/05/find_go_version_the_app_use/</guid><description>根据二进制文件找出应用构建时使用的Go版本 # 使用 dlv:
dlv exec ./app &amp;gt; p runtime.buildVerion 或者，在代码里调用runtime.Version():
func main() { fmt.Println(&amp;#34;go version:&amp;#34;, runtime.Version()) } 参照</description></item><item><title>k8s是怎么维持pod的运行的呢？</title><link>https://donnol.github.io/posts/2022/05/k8s_how_to_keep_pods/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/05/k8s_how_to_keep_pods/</guid><description>k8s是怎么维持pod的运行的呢？ # 当接收了yaml配置的信息后，是怎么维持pod根据声明一直运行的呢？
让我们沿着命令执行的过程来一睹为快：kubectl apply -f pod.yaml.
源码位置：cmd/kubectl/kubectl.go -&amp;gt; staging/src/k8s.io/kubectl/pkg/cmd/cmd.go -&amp;gt; staging/src/k8s.io/kubectl/pkg/cmd/apply/apply.go
最终的执行方法：
func (o *ApplyOptions) Run() error { // 预处理 if o.PreProcessorFn != nil { klog.V(4).Infof(&amp;#34;Running apply pre-processor function&amp;#34;) if err := o.PreProcessorFn(); err != nil { return err } } // Enforce CLI specified namespace on server request. if o.EnforceNamespace { o.VisitedNamespaces.Insert(o.Namespace) } // Generates the objects using the resource builder if they have not // already been stored by calling &amp;#34;SetObjects()&amp;#34; in the pre-processor.</description></item><item><title>Go enum</title><link>https://donnol.github.io/posts/2022/05/go_enum/</link><pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/05/go_enum/</guid><description>Go enum # Go是没有内置枚举类型的，那么，当需要使用枚举时，该怎么办呢？
枚举说白了，就是一连串互斥的值，每个值代表一样事物或一个类型。
比如，现在需要一个颜色枚举，可以这样定义：
const ( Red = &amp;#34;Red&amp;#34; // 红色 Blue = &amp;#34;Blue&amp;#34; // 蓝色 Green = &amp;#34;Green&amp;#34; // 绿色 ) 也有这样定义的：
type Color string // 定义一个特定类型 // 枚举常量均声明为该类型 const ( Red Color = &amp;#34;Red&amp;#34; // 红色 Blue Color = &amp;#34;Blue&amp;#34; // 蓝色 Green Color = &amp;#34;Green&amp;#34; // 绿色 ) 这样做的好处是可以通过这个类型来更明显的标记出枚举字段来：
type Car struct { Name string Color Color // 颜色字段声明为Color类型，在阅读代码的时候就能知道这个字段正常的可选值范围 } 但是，上面的做法都需要面临一个问题，就是我需要一个返回全部枚举值的集合时，需要这样做：
func All() []Color { return []Color{ Red, Blue, Green, } } func (color Color) Name() string { switch color { case Red: return &amp;#34;红色&amp;#34; case Blue: return &amp;#34;蓝色&amp;#34; case Green: return &amp;#34;绿色&amp;#34; } return &amp;#34;&amp;#34; } 当在定义处新增值时，All和Name也要同步添加，对于开发人员来说，非常容易遗漏。</description></item><item><title>Go1.18 comparable</title><link>https://donnol.github.io/posts/2022/04/go1.18_comparable/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/04/go1.18_comparable/</guid><description>Go 1.18 预定义接口类型 # 先看一个提案: proposal: spec: permit values to have type &amp;ldquo;comparable&amp;rdquo; &amp;ndash; 允许值拥有comparable类型，我的理解是，现在的comparable只能用作泛型里的类型参数的约束，不能像普通类型那样使用，如下：
type Set[E comparable] []E // 可以用做类型参数的约束 // 使用go1.18编译，报错：interface is (or embeds) comparable var A comparable // 变量不可以使用`comparable`类型 那么，结合例子就能更好地理解这个提案了。
这个提案的主要目的就是让例子里的var A comparable成立，也就是允许comparable作为变量的类型，跟其它普通的接口类型(var E error)一样。
// proposal: spec: permit values to have type &amp;#34;comparable&amp;#34; // As part of adding generics, Go 1.18 introduces a new predeclared interface type comparable. That interface type is implemented by any non-interface type that is comparable, and by any interface type that is or embeds comparable.</description></item><item><title>KMP</title><link>https://donnol.github.io/posts/2022/03/kmp/</link><pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/03/kmp/</guid><description>KMP字符串匹配算法
精确匹配
状态机
给定一个pattern，查找其在另一字符串s出现的最早位置。（找不到则返回-1）
func index(s string, pattern string) int { return -1 } 状态推移
func index(s string, pattern string) int { n := len(s) m := len(pattern) // 根据pattern构造dp var dp [n][m]int // 在s上应用dp，判断pattern位置 return -1 }</description></item><item><title>霜之哀伤</title><link>https://donnol.github.io/posts/2022/02/%E9%9C%9C%E4%B9%8B%E5%93%80%E4%BC%A4/</link><pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/02/%E9%9C%9C%E4%B9%8B%E5%93%80%E4%BC%A4/</guid><description>当有人说要在屋里开个窗，一定惹得大伙不开心，无人同意；若要在屋里凿个洞，就有人来协调，愿意开窗了。
看到了吗？这里面有提议的人，有反对的人，有开始反对后面协调的人。看似只有这几种人，实则还有一种人，哪边人多站哪边。恶则落井下石，善则“好言相劝”。
一盆散沙，就算反对，也难以“碍事”。聪明人早就明白这个道理。只要能裹挟着一群人，与自己利益捆绑，那么就能为己所用。至于“所用”是何物，自然无关紧要，只要“为己”即可。
同样地，要击溃捆绑，自然需要强大的力量，也就是另一群人。</description></item><item><title>goroutine vs tokio</title><link>https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/</guid><description>Reddit讨论贴
Go uses a different strategy for blocking systemcalls. It does not run them on a threadpool - it moves all the other goroutines that are queued to run on the current thread to a new worker thread, then runs the blocking systemcall on the current thread. This minimizes context switching.
You can do this in tokio as well, using task::block_in_place. If I change your code to use that instead of tokio::fs, it gets a lot closer to the go numbers.</description></item><item><title>go runtime chan</title><link>https://donnol.github.io/posts/2022/02/go_runtime_chan/</link><pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/02/go_runtime_chan/</guid><description>src/runtime/chan.go:
// Invariants: // At least one of c.sendq and c.recvq is empty, // except for the case of an unbuffered channel with a single goroutine // blocked on it for both sending and receiving using a select statement, // in which case the length of c.sendq and c.recvq is limited only by the // size of the select statement. // // For buffered channels, also: // c.qcount &amp;gt; 0 implies that c.</description></item><item><title>go work</title><link>https://donnol.github.io/posts/2022/02/go_work/</link><pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/02/go_work/</guid><description>go1.18将要推出workspace模式，此举是为了方便在本地开发多个不同module时的依赖管理。
命令说明：
$ go help work Go workspace provides access to operations on workspaces. Note that support for workspaces is built into many other commands, not just &amp;#39;go work&amp;#39;. See &amp;#39;go help modules&amp;#39; for information about Go\&amp;#39;s module system of which workspaces are a part. A workspace is specified by a go.work file that specifies a set of module directories with the &amp;#34;use&amp;#34; directive. These modules are used as root modules by the go command for builds and related operations.</description></item><item><title>杂念</title><link>https://donnol.github.io/posts/2022/02/distractions/</link><pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/02/distractions/</guid><description>情绪绑定 # 先把一样好（好看、好听、好闻）的东西抛出来，收集大众的积极情绪，进而把大家的情绪控制。
当这样东西喜，你就跟着喜；当这样东西悲，你就跟着悲；当这样东西静，你就跟着静。当这样东西动，你却看不到了。
信仰缺失的年代，把自己交付给这样的东西，只为换到一丝“慰挤”。
精神上的追求太难找到共鸣了，不如转而追求物质上的欢喜。每天吃吃喝喝，打打闹闹，不以物喜，不以己悲，不是挺好。
歌好听，那就听，何必在意歌手爱天怼地。如果真的这么较真，最好听歌前做好背景调查，如果不慎那歌手竟信息不详，那只好叫耳朵过滤掉了。若实在忍不住，也不妨在确实之前先恩施一番，以传我宽大之名。当然，如有丝言片语，只要未到石锤之境，自然轻松忽略。毕竟，真假难辨，不如不辩。
万一真的发现了黑历史，这时就要斟酌一番了，继续爱如谦，抑或恨如龙，搞不好就被别人发现你居然喜欢“黑”歌手，承担巨大的社会压力，就得不偿失了。
但是，害怕很难成事，只会坏事。如果只因为怕，那如何能算英雄，或者竟连个孤勇者都算不上，实在于心难安。那何不拉拢一批共同情绪的人，把那位别人先打黑。
嘿，只需证明别人是错的，何苦花费心思证明自己是对呢！
嗯，情绪输出总算有着落了，难受的只要是别人，自己就永远开心了，谁管别人是亲是疏，是喜是恶呢。只要不管不顾，虎牛之力也拿我没辙。对别人施暴，哪怕隔着个屏幕，也能爽到嗨。
别人这时就难受了：我好心劝你们远离毒瘤，居然不识抬举，还要拉帮结派来搞我。真的是越想越气，越气越想。奈何对方人多势众，单拳难敌四手。
自诩孤高者，自然不屑于群斗，但被逼到墙角了，也不得不群起。但标准越高，规模自然越小，苦费心思，依然难以匹敌，最后只好在猪圈方圈里丢三骂四了。
聪明人居然不懂不聪明人的想法，为什么敢自认聪明呢？
懂的话，大抵不会自称聪明人，而要转称愚人了吧。不聪明人也不真的不聪明，只是知道往身上贴上聪明人标签，更多时候只捞得个劳苦功低、得不偿失，活得还不如马屁精。
说到马屁精，我就猜到马屁是香的，或至少在喜爱之人闻来别有一番风味。
马屁精自然是冤枉的，不过说了几句某人爱听的话，或者不小心成了习惯&amp;ndash;见某人说某话，别人就来指责他，并打上马屁精标签，在圈里不断丢三骂四。只是不对你这样说话，你就这么生气，别人真的是坏。
谁怪你不是某人呢？你若竟是某人，想听几句某话，那还不难。只怕你成了某人，你还嫌少呢！
马屁精也不全是敌人，是非精、八卦精等“朋友”是大大的有。而且，精的本事也不能小，至少要在亦敌亦友的关系转变中拿捏得准确无误。不然闹出“人门前弄是非，精面前摆事实”的笑话来，就颜面无存了。
精，未成人之前，或竟不做人，选择做精，自然是如老鼠过街，人人喊打。
既然是精，那就必须没有情绪，笑脸迎臭脸自然是家常便饭。但只要熬出头，拥有一星半点某人之像，好生活自然而至，竟也开始享受到了某话。
路漫漫兮，修就是了。怎么修的，你就别管了。好好的丢三骂四还不够，还敢来管修的事，怕不是吃饱了思起淫欲来。
精在那里，你不骂，你敢往这边看，你怕不是想吃大过年不想吃的饭了。就不怕，我饭都不给你吃，把你饿成精。
原来精是饿出来的！</description></item><item><title>Rust与安全</title><link>https://donnol.github.io/posts/2022/01/rust_safe/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/01/rust_safe/</guid><description>有一些东西，做了一些事情。
有什么东西，做了什么呢？
有文件、结构体、特征、类型，调用了函数、方法，读了文件/读了body，算了结果，写了文件/答了请求。
IO or 计算。
或者说，更强调IO，还是计算。
内存安全 # 并发安全 #</description></item><item><title>wasm运行时wasmtime</title><link>https://donnol.github.io/posts/2022/01/wasmtime/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/01/wasmtime/</guid><description>源码 # # 下载 git clone git@github.com:bytecodealliance/wasmtime.git # 子模块 git submodule update --init --recursive # 安装 cargo build 如果忘了拉子模块，vscode的rust-analyzer会报错，导致智能提示等功能失效。
不过整个初始化过程还是有点长，等了好久才能正常使用。
阅读 # 从build.rs开始，首先映入眼帘的是use anyhow::Context;：
/// Provides the `context` method for `Result`. /// /// This trait is sealed and cannot be implemented for types outside of /// `anyhow`. 这是一个为其它类型（anyhow::Result）引入context方法的特征啊，多么伟大，在anyhow包外面的类型就不要想着去实现它了，你们高攀不起的。
再看anyhow::Context的定义：
// lib.rs:598 pub trait Context&amp;lt;T, E&amp;gt;: context::private::Sealed { // 继承了Sealed，那它又是怎么样的、做什么的呢？ /// Wrap the error value with additional context. -- 给error值包装上下文信息 fn context&amp;lt;C&amp;gt;(self, context: C) -&amp;gt; Result&amp;lt;T, Error&amp;gt; where C: Display + Send + Sync + &amp;#39;static; // 能展示，并发安全，全局可见的类型值 /// Wrap the error value with additional context that is evaluated lazily /// only once an error does occur.</description></item><item><title>容器镜像加密</title><link>https://donnol.github.io/posts/2022/01/container_encrypt/</link><pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/01/container_encrypt/</guid><description>如果我在创建镜像时把源码也打包了进去，要怎么防止别人通过这个镜像把源码给窃取了呢？
加密
镜像加密
源码加密：在COPY源码进去之前先加密；这种适合服务器不是自己的，并且在局域网里的（接过医院系统的应该都懂吧）；留这样一份加密源码也只是在方便有bug时可以快速修复的同时，还可以稍微保护一下源码；
先使用zip压缩源码：`zip -q -r code.zip ./code`； 再使用gpg加密：`gpg --yes --batch --passphrase=123 -c ebpf.zip`； -- 通过`--yes --batch --passphrase`三个选项避免键盘交互，最后生成`ebpf.zip.gpg`。 后续进入容器后，使用gpg解密：`gpg -o ebpf2.zip -d ebpf.zip.gpg`； 再使用unzip解压：`unzip -d ebpf2 ebpf2.zip`。 在镜像构建后，还要防止docker history -H cb0b42c0cb03 --no-trunc=true查看镜像构建历史时，泄露秘钥等信息。&amp;ndash; 可使用多阶段构建：在前一阶段使用密钥加密源码，后一阶段复制加密源码，从而避免密钥泄露。因为一般只需要把后一阶段构建出来的镜像分发出去就好了，而查看后一阶段构建出来的镜像的构建历史，是看不到密钥信息的（查看前一阶段的构建历史才会看到）。
dockerfile COPY before mkdir will get a no such file or directory error # error:
```dockerfile # &amp;hellip;
RUN mkdir -p /abc
COPY &amp;ndash;from=builder /opt/efg /abc/efg ```
没有指定创建/abc/efg目录，会导致后续想读取该目录内容时报错：no such file or directory
success:
```dockerfile # &amp;hellip;</description></item><item><title>智能合约</title><link>https://donnol.github.io/posts/2022/01/smart_contract/</link><pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/01/smart_contract/</guid><description>智能合约 # 智能合约wiki
（英语：Smart contract）是一种特殊协议，在区块链内制定合约时使用，当中内含了代码函数 (Function)，亦能与其他合约进行交互、做决策、存储资料及发送以太币等功能。智能合约主要提供验证及执行合约内所订立的条件。智能合约允许在没有第三方的情况下进行可信交易。这些交易可追踪且不可逆转。
安全问题 # 智能合约是“执行合约条款的计算机交易协议”。区块链上的所有用户都可以看到基于区块链的智能合约。但是，这会导致包括安全漏洞在内的所有漏洞都可见，并且可能无法迅速修复。
这样的攻击难以迅速解决，例如：
2016年6月The DAOEther的漏洞造成损失5000万美元，而开发者试图达成共识的解决方案。DAO的程序在黑客删除资金之前有一段时间的延迟。以太坊软件的一个硬分叉在时限到期之前完成了攻击者的资金回收工作。
以太坊智能合约中的问题包括合约编程Solidity、编译器错误、以太坊虚拟机错误、对区块链网络的攻击、程序错误的不变性以及其他尚无文档记录的攻击。
2018年4月22日， BeautyChain智能合约出现重大漏洞，黑客通过此漏洞无限生成代币，导致 BitEclipse (BEC)的价值接近归零。同月25日，SmartMesh出现疑似重大安全漏洞，宣布暂停所有SMT交易和转账直至另行通知，导致损失约1.4亿美金。28日，EOS被指可能存在BEC代币合约类似的整数溢出漏洞，但没消息详细说明。5月24日， BAI交易存在大量异常问题， 损失金额未知。8月22日， GODGAME 合约被黑客入侵，GOD智能合约上的以太坊总数归零。
合约开发、测试和部署 # eth智能合约文档
vending machine(自动售货机): money + snack selection = snack dispensed, 给钱并选择小吃，小吃就会出来 &amp;ndash; 是给刚好的钱，还是过量的钱，过量了在发放小吃的同时退钱呢？
合约长这样：
// 表明使用的sol版本 pragma solidity 0.8.7; // Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。 contract VendingMachine { // Declare state variables of the contract address public owner; // owner变量 mapping (address =&amp;gt; uint) public cupcakeBalances; // cupcakeBalances变量 // 创建合约时，合约的构造函数会执行一次。构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。 // When &amp;#39;VendingMachine&amp;#39; contract is deployed: // 1.</description></item><item><title>Go快速入门</title><link>https://donnol.github.io/posts/2022/01/learn_go_fast/</link><pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/01/learn_go_fast/</guid><description>源码 # // 所有代码都需要放到包里 package color // 导入其它包 import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) // 枚举 type Color int // 常量 const ( Red Color = 1 // 红 Blue Color = 2 // 蓝 Green Color = 3 // 绿 ) // 函数 func NewCar( name string, rate int, ) *Car { return &amp;amp;Car{ name: name, rate: rate, } } // 类型 type Car struct { // 类型字段 name string // 首字母小写，非导出，只能包内使用 rate int } // 类型方法 func (car *Car) String() string { // 首字母大写，导出，可供其它包使用 return &amp;#34;[Car] name: &amp;#34; + car.</description></item><item><title>consensus</title><link>https://donnol.github.io/posts/2022/01/consensus/</link><pubDate>Mon, 17 Jan 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/01/consensus/</guid><description>在中文里，共表示共同（至少两个人？一个人行不行？），识表示认识，组合一起成为共识，共同的认识，引申出共同的想法、共同的行为。
在英语里，con是一个词根&amp;ndash;表示&amp;quot;共同&amp;quot;，sensus表示感觉，加在一起组成consensus。
人类社会的发展催生了交易，交易的前提是双方达成共识，比如油换盐，比如钱换粮。如果你不承认我的油，不愿意与我交易，那就没办法了。
人与人之间的共识是非常难以达成的，不像歌里唱的：我说一，你说一。很多时候，我说一，他也承诺他会说一，但他没说&amp;ndash;可能因为一些事忘了说，可能因为他突然不想说了，也有可能他被胁迫了不能说。反正就是不一而足的情况导致了意见/行为不一。
在日常生活中，特别是集市上，往往都是一手交钱、一手交货，交易完成就完成了，如果后面出现了问题&amp;ndash;比如货不对版、钱有真伪，那就是另外的问题了。
那如果我们分别在不同的地方，没法面对面交易呢；又或者交易的东西不方便马上拿到面前来交易呢；又或者交易之后发现货不对版不想要了呢？
这时候，为了解决这些问题，某种机构应运而生。结合现在网购流行的社会，大家不难发现有哪些这类的机构。
目前的社会除了网购流行之外，是不是机器也很流行呢。那机器又是什么呢？机器能做什么，从而在这个社会如此流行呢？机器又能不能充当某类机构来完成某些事呢？
共识要素 # 某件事，事的主体，事的具体。比如购物，买卖双方、以钱易物。
机器共识 # 拜占庭将军问题 # wiki
拜占庭将军问题（Byzantine Generals Problem），是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。
在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。
关键词：分布式对等、通信容错、不同计算机通过通讯交换信息从而达成共识、共识达成失败会导致系统一致性被破坏。
问题描述：
一组拜占庭将军分别各率领一支军队共同围困一座城市。
为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。
因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。
因为各位将军分处城市不同方向，他们只能通过信使互相联系。
在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。
面临问题：
系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。&amp;ndash; 出现叛徒，半真半假，选择性投票，（一人投两票） &amp;ndash; 控制投票时间，只要不在其他人都投完之后再投，他就没法知道别人投的什么票；一人投一票，投票之后不能再投；
假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。
由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。因此很难通过保证人员可靠性及通讯可靠性来解决问题。
人可能是假的，信可能是假，空气都可能是假的；
假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。
应用：
在点对点式数字货币系统比特币里，比特币网络的运作是平行的（parallel）。各节点与终端都运算著区块链来达成工作量证明（PoW）。工作量证明的链接是解决比特币系统中拜占庭问题的关键，避免有问题的节点（即前文提到的“反叛的将军”）破坏数字货币系统里交易帐的正确性，是对整个系统的运行状态有着重要的意义。
在一些飞行器（如波音777）的系统中也有使用拜占庭容错。而且由于是即时系统，容错的功能也要能尽快回复，比如即使系统中有错误发生，容错系统也只能做出一微秒以内的延迟。
一些航天飞机的飞行系统甚至将容错功能放到整个系统的设计之中。
拜占庭容错机制是将收到的消息（或是收到的消息的签名）转交到其他的接收者。这类机制都假设它们转交的消息都可能念有拜占庭问题。在高度安全要求的系统中，这些假设甚至要求证明错误能在一个合理的等级下被排除。当然，要证明这点，首先遇到的问题就是如何有效的找出所有可能的、应能被容错的错误。这时候会试着在系统中加入错误插入器。
eth共识 # Beacon # Beacon：信标
eth2将要升级的共识机制，即将使用的基于eth1和PoS算法的共识。
信标链不支持叔块了。
信标链和经典链在校验header时的不同：
(a) The following fields are expected to be constants:
difficulty is expected to be 0 &amp;ndash; 难度固定为0 nonce is expected to be 0 &amp;ndash; 随机数固定为0 unclehash is expected to be Hash(emptyHeader) to be the desired constants &amp;ndash; 叔块哈希固定为空值 (b) the timestamp is not verified anymore (c) the extradata is limited to 32 bytes</description></item><item><title>红黑树</title><link>https://donnol.github.io/posts/2022/01/red_black_tree/</link><pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/01/red_black_tree/</guid><description>树，保持高效在于平衡，高度低。
红黑树如何做到的呢？
定义 # wiki # 红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型用途是实现关联数组。它在1972年由鲁道夫·贝尔发明，被称为&amp;quot;对称二叉B树&amp;quot;，它现代的名字源于Leo J. Guibas和罗伯特·塞奇威克于1978年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在O(log n)时间内完成查找、插入和删除，这里的n是树中元素的数目。
性质 # 红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：
节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是NIL节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 从**任一节点到其每个叶子**的所有简单路径都包含**相同数目的黑色节点**。 一句话概况：或红或黑，首尾皆黑，红子必黑，任一点至所有尾含黑同数。
为确保任一点至所有尾含黑同数，路径中必须插入红点，而在哪个位置插呢（必须考虑红子必黑原则）？
这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。
要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。
在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。为此，本文中我们使用&amp;quot;nil叶子&amp;quot;或&amp;quot;空（null）叶子&amp;quot;，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。
实现 # 操作 # 因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量（O(log n)）的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为O(log n)次。
我们首先以二叉查找树的方法增加节点并标记它为红色。（如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过**颜色调换（color flips）和 树旋转**来调整。） 树旋转 # 对二叉树的一种操作，不影响元素的顺序，但会改变树的结构，将一个节点上移、一个节点下移。树旋转会改变树的形状，因此常被用来将较小的子树下移、较大的子树上移，从而降低树的高度、提升许多树操作的效率。
对一棵树进行旋转时，这棵树的根节点是被旋转的两棵子树的父节点，称为旋转时的根（英语：root）；如果节点在旋转后会成为新的父节点，则该节点为旋转时的转轴（英语：pivot）。
上图中，树的右旋操作以 Q 为根、P 为转轴，会将树顺时针旋转。相应的逆操作为左旋，会以 Q 为转轴，将树逆时针旋转。
理解树旋转过程的关键，在于理解其中不变的约束。旋转操作不会导致叶节点顺序的改变（可以理解为旋转操作前后，树的中序遍历结果是一致的），旋转过程中也始终受二叉搜索树的主要性质约束：右子节点比父节点大、左子节点比父节点小。尤其需要注意的是，进行右旋转时，旋转前根的左节点的右节点（例如上图中以 Q 为根的 B 节点）会变成根的左节点，根本身则在旋转后会变成新的根的右节点，而在这一过程中，整棵树一直遵守着前面提到的几个约束。相反的左旋转操作亦然。
如果将根记为 Root、转轴记为 Pivot、子节点中与旋转方向相同的一侧记为 RS（旋转侧，英语：Rotation Side）、旋转对侧记为 OS（英语：Opposite Side），则上图中 Q 节点的 RS 为 C、OS 为 P，将其右旋转的伪代码为：
Pivot = Root.OS Root.OS = Pivot.RS Pivot.RS = Root Root = Pivot 该操作为常数时间复杂度。</description></item><item><title>Rust常用库</title><link>https://donnol.github.io/posts/2022/01/rust_commonly_used_crate/</link><pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/01/rust_commonly_used_crate/</guid><description>crossbeam # crossbeam: Tools for concurrent programming in Rust.
Atomics
Data structures
Memory management: epoch
Thread synchronization: channel, Parker, ShardedLock, WaitGroup
Utilities
channel example # use crossbeam_channel::unbounded; let (s, r) = unbounded(); s.send(&amp;#34;Hello, world!&amp;#34;).unwrap(); assert_eq!(r.recv(), Ok(&amp;#34;Hello, world!&amp;#34;)); unbounded(无限) channel发送时不用等接收端就绪。
另外还有bounded channel可在新建时指定容量，后续发送的消息数不能超过该数据 &amp;ndash; 除非中间有消息被取走了
当bounded channel容量设为0时，发送前必须等接收端就绪，一般可用于线程间等待。
更多介绍
与标准库的sync::mpsc对比
epoch # Pin 做了什么？
crossbeam在实现无锁并发结构时，采用了基于代的内存回收方式1，这种算法的内存管理开销和数据对象的数量无关，只和线程的数量相关，因此在 以上模型中可以表现出更好的一致性和可预测性。不过Rust中的所有权系统已经保证了内存安全，那为什么还需要做额外的内存回收呢？这个问题的关键点 就在要实现无锁并发结构。如果使用标准库中的Arc自然就不会有内存回收的问题，但对Arc进行读写是需要锁的。
crossbeam-channel文章
digest # This crate provides traits which describe functionality of cryptographic hash functions and Message Authentication algorithms.</description></item><item><title>缓存和数据库如何保持一致</title><link>https://donnol.github.io/posts/2022/01/cache/</link><pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/01/cache/</guid><description>缓存读 # 从缓存读，如果读到了，直接返回；如果读不到，继续去数据库读（singleflight），读到后，更新缓存，返回结果。
缓存写 # 为什么是删缓存，而不是更新缓存呢？
主要是怕两个并发的写操作导致脏数据。
删除缓存和更新磁盘谁先谁后呢？
1.如果先删除缓存，再更新磁盘时的问题：
数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。 &amp;ndash; 删了缓存，未完成数据库修改 另一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。 &amp;ndash; 因为上面的请求里修改数据库的部分还未完成 随后数据变更的程序完成了数据库的修改。&amp;ndash; 这时才完成，可缓存已经填充了之前的旧值了 来到这，数据库和缓存中的数据就不一样了。
2.先更新磁盘，再删除缓存的问题：
先更新数据库，再删除缓存，如果数据库更新了，但是缓存删除失败了，那么缓存中的数据还是旧数据，出现数据不一致
先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。
比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。
但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。
所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。
参照
代码 # package cache // 缓存，一般先将数据从磁盘读出来写到内存里，供用户高速访问，减少读磁盘 -- 快取 // 另有缓冲，将数据先写到内存里，待装满后一次性写入磁盘，可以少写很多次 -- 缓冲 // // 不难看出，无论快取还是缓冲，都涉及到内存和磁盘的读写。 // // 首先，对于缓存，目前使用较多的中间件是redis、memcached等，当然也有自己在程序中内置map充当缓存的。 // 那么，下面来看下如何在内存和磁盘之间同步数据： type Cache interface { // exp表示当前时间后的exp秒后过期，传0则无过期 Set(key, value string, exp int) error Del(key string) error Get(key string) (value string, err error) } type Store interface { Create(key, value string, exp int) error Delete(key string) error Update(key, value string, exp int) error Get(key string) (vlaue string, err error) } // 用户 有增删改查四个操作，在操作时，对应的缓存和磁盘如何变化呢？ type Client struct { cache Cache store Store } func NewClient( cache Cache, store Store, ) *Client { return &amp;amp;Client{ cache: cache, store: store, } } const ( defExp = 300 ) // Add 先写磁盘还是缓存呢？ func (client *Client) Add(key, value string) { // 会不会已经在Store里存在了呢？ // 先从Store Get一次？ // 一般来说，key都是唯一的： // 此时，必须请求一次Store，确认数据不存在；如果此时数据存在，直接返回错误 if v, err := client.</description></item><item><title>ebpf</title><link>https://donnol.github.io/posts/2021/12/ebpf/</link><pubDate>Fri, 24 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/ebpf/</guid><description>ebpf: 扩展伯克利包过滤器。
下面的内容主要来源于 译文。
用处 # 目前，主要有两大组触发器。
第一组用于处理网络数据包和管理网络流量。它们是 XDP、流量控制事件及其他几个事件。
以下情况需要用到这些事件：
创建简单但非常有效的防火墙。Cloudflare 和 Facebook 等公司使用 BPF 程序来过滤掉大量的寄生流量，并打击最大规模的 DDoS 攻击。由于处理发生在数据包生命的最早阶段，直接在内核中进行（BPF 程序的处理有时甚至可以直接推送到网卡中进行），因此可以通过这种方式处理巨量的流量。这些事情过去都是在专门的网络硬件上完成的。
创建更智能、更有针对性、但性能更好的防火墙——这些防火墙可以检查通过的流量是否符合公司的规则、是否存在漏洞模式等。例如，Facebook 在内部进行这种审计，而一些项目则对外销售这类产品。
创建智能负载均衡器。最突出的例子就是 Cilium 项目，它最常被用作 K8s 集群中的网格网络。Cilium 对流量进行管理、均衡、重定向和分析。所有这些都是在内核运行的小型 BPF 程序的帮助下完成的，以响应这个或那个与网络数据包或套接字相关的事件。
这是第一组与网络问题相关并能够影响网络通信行为的触发器。第二组则与更普遍的可观察性相关；在大多数情况下，这组的程序无法影响任何事件，而只能“观察”。这才是我更感兴趣的。
这组的触发器有如下几个：
perf 事件（perf events）——与性能和 perf Linux 分析器相关的事件：硬件处理器计数器、中断处理、小 / 大内存异常拦截等等。例如，我们可以设置一个处理程序，每当内核需要从 swap 读取内存页时，该处理程序就会运行。例如，想象有这样一个实用程序，它显示了当前所有使用 swap 的程序。
跟踪点（tracepoints）——内核源代码中的静态（由开发人员定义）位置，通过附加到这些位置，你可以从中提取静态信息（开发人员先前准备的信息）。在这种情况下，静态似乎是一件坏事，因为我说过，日志的缺点之一就是它们只包含了程序员最初放在那里的内容。从某种意义上说，这是正确的，但跟踪点有三个重要的优势：
有相当多的跟踪点散落在内核中最有趣的地方
当它们不“开启”时，它们不使用任何资源
它们是 API 的一部分，它们是稳定的，不会改变。这非常重要，因为我们将提到的其他触发器缺少稳定的 API。
例如，假设有一个关于显示的实用程序，内核出于某种原因没有给它时间执行。你坐着纳闷为什么它这么慢，而 pprof 却没有显示任何什么有趣的东西。
USDT——与跟踪点相同，但是它适用于用户空间的程序。也就是说，作为程序员，你可以将这些位置添加到你的程序中。并且许多大型且知名的程序和编程语言都已经采用了这些跟踪方法：例如 MySQL、或者 PHP 和 Python 语言。通常，它们的默认设置为“关闭”，如果要打开它们，需要使用 enable-dtrace 参数或类似的参数来重新构建解释器。是的，我们还可以在 Go 中注册这种类跟踪。你可能已经识别出参数名称中的单词 DTrace。关键在于，这些类型的静态跟踪是由 Solaris) 操作系统中诞生的同名系统所推广的。例如，想象一下，何时创建新线程、何时启动 GC 或与特定语言或系统相关的其他内容，我们都能够知道是怎样的一种场景。
这是另一种魔法开始的地方：</description></item><item><title>时间和文字</title><link>https://donnol.github.io/posts/2021/12/time_wenzi/</link><pubDate>Fri, 24 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/time_wenzi/</guid><description>带领，今天突然用到这个“带”字时，觉得它不是我印象中的“带”字，这是为什么呢？
很重的一种陌生感迎面而来，这真的是曾经伴随我历经千测万考的字吗？
这种突然觉得某个曾经很熟悉的字很陌生的感觉，真的很奇怪。</description></item><item><title>etcd</title><link>https://donnol.github.io/posts/2021/12/etcd/</link><pubDate>Mon, 20 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/etcd/</guid><description>etcd # raft # 介绍 # 由多个节点组成的集群维护着一个可复制状态机的协议。通过复制日志来保持状态机的同步。 可理解的共识算法
状态机以消息为输入。消息可以是一个本地定时器更新，或一条网络消息。输出一个3元结构：[]Messages, []LogEntries, NextState，分别是消息列表、日志条目列表、下个状态。同样状态的状态机，在相同输入时总是输出相同结果。
插曲 # 人、联系、共识
人生下来，触摸着这个世界的人和物，做着或有趣或无聊的事，建立起或浅或深的联系。
当两个人面对面时，就某个想法达成一致或不一致，非常容易。
如果两个人不是面对面呢？
如果不只两个人，同坐在祠堂里呢？
如果不止两个人，还分散在不同地点呢？
那么，为什么要达成共识呢？
因为有些事必须达成共识才能执行，比如，两个人双向奔赴。
如果彼此异心，一个向东，一个往南，事情就办不成了。
所以，共识是大伙成事的前提。
共识，除了就某件事所要达成的结果，也要考虑所使用的方法。
有可能是步步为营，走一步算一步，也就是每走一步再就下一步达成共识。
也有可能是，一次性就接下来的几步均达成共识，然后各自执行。
message type # // For description of different message types, see: // https://pkg.go.dev/go.etcd.io/etcd/raft/v3#hdr-MessageType type MessageType int32 const ( // 选举时使用； // 如果节点是一个follower或candidate，它在选举超时前没有收到任何心跳，它就回传递MsgHup消息给它自己的Step方法，然后成为（或保持）一个candidate从而开启一个新的选举 MsgHup MessageType = 0 // 一个内部类型，它向leader发送一个类型为“MsgHeartbeat”的心跳信号 // 如果节点是一个leader，raft里的tick函数将会是“tickHeartbeat”，触发leader周期性地发送“MsgHeartbeat”消息给它的followers MsgBeat MessageType = 1 // 提议往它的日志条目里追加数据； // 这是一个特别的类型，由follower反推提议给leader（正常是leader提议，follower执行）； // 发给leader的话，leader调用“appendEntry”方法追加条目到它的日志里，然后调用“bcastAppend”方法发送这些条目给它的远端节点； // 发给candidate的话，它们直接丢弃该消息 // 发给follower的话，follower会将消息存储到它们的信箱里。会把发送者的id一起存储，然后转发给leader。 MsgProp MessageType = 2 // 包含了要复制的日志条目 // leader调用“bcastAppend”（里面调用“sendAppend”），发送“一会要被复制的日志”消息； // 当candidate收到消息后，在它的Step方法里，它马上回退为follower，因为这条消息表明已经存在一个有效leader了。 // candidate和follower均会返回一条“MsgAppResp”类型消息以作响应。 MsgApp MessageType = 3 // 调用“handlerAppendEntries”方法 MsgAppResp MessageType = 4 // 请求集群中的节点给自己投票； // 当节点是follower或candidate，并且它们的Step方法收到了“MsgHup”消息，节点调用“campaign”方法去提议自己成为一个leader。一旦“campaign”方法被调用，节点成为candidate，并发送“MsgVote”给集群中的远端节点请求投票。 // 当leader或candidate的Step方法收到该消息，并且消息的Term比它们的Term小，“MsgVote”将被拒绝。 // 当leader或candidate收到的消息的Term要更大时，它会回退为follower。 // 当follower收到该消息，仅当发送者的最后的term比“MsgVote”的term要大，或发送者的最后term等于“MsgVote”的term（但发送者的最后提交index大于等于follower的）， MsgVote MessageType = 5 // 投票响应； // 当candidate收到后，它会统计选票，如果大于majority（quorum），它成为leader并调用“bcastAppend”。如果candidate收到大量的否决票，它将回退到follower MsgVoteResp MessageType = 6 // 请求安装一个快照消息； // 当一个节点刚成为leader，或者leader收到了“MsgProp”消息，它调用“bcastAppend”方法（里面再调用“sendAppend”）方法到每个follower。在“sendAppend”方法里，如果一个leader获取term或条目失败了，leader通过&amp;#34;MsgSnap&amp;#34;消息请求快照。 MsgSnap MessageType = 7 // leader发送心跳； // 当candidate收到“MsgHeartbeat”，并且消息的term比candidate的大，candidate回退到follower并且更新它的提交index为这次心跳里的值。然后candidate发送消息到它的信箱。 // 当消息发送到follower的Step方法，并且消息的term比follower的大，follower更新它的leader id MsgHeartbeat MessageType = 8 // 心跳响应； // leader收到后就知道有哪些follower响应了。 // 只有当leader的最后提交index比follower的Match index大时，leader执行“sendAppend”方法 MsgHeartbeatResp MessageType = 9 // 表明请求没有被交付； // 当“MsgUnreachable”被传送到leader的Step方法，leader发现follower无法到达，很有可能“MsgApp”都丢失了。当follower的进度状态为复制时，leader设置它回probe（哨兵） MsgUnreachable MessageType = 10 // 表明快照安装消息的结果 // 当一个follower拒绝了“MsgSnap”，这显示快照请求失败了--因为网络原因；**leader认为follower成为哨兵了**?</description></item><item><title>vscode-go在go.mod在非根目录情况下失效的问题</title><link>https://donnol.github.io/posts/2021/12/vscode-go-module/</link><pubDate>Mon, 20 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/vscode-go-module/</guid><description>问题如图：
解决：
添加配置：
{ // ... &amp;#34;gopls&amp;#34;: { &amp;#34;experimentalWorkspaceModule&amp;#34;: true }, // ... } 等go 1.18的workspace模式推出之后，应该就不需要配置这个了。
参考</description></item><item><title>mqtt</title><link>https://donnol.github.io/posts/2021/12/mqtt/</link><pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/mqtt/</guid><description>物联网消息标准 # 官网
It is designed as an extremely lightweight publish/subscribe messaging transport that is ideal for connecting remote devices with a small code footprint and minimal network bandwidth.
极其轻量的发布/订阅消息传输，使用小量代码脚本和极小网络带宽来连接远程设备。
轻量 高效 双向 大规模（百万设备） 可靠 支持不可靠网络 安全 多个mqtt客户端连接到broker(译为：中间商)，围绕topic来实现发布/订阅操作，某些客户端向topic发布消息，某些客户端订阅topic上的消息，当broker接收到某个topic上的消息时，它会将消息转发到订阅了该topic的客户端。
mqtt 5.0
QoS # Quality of Service
control traffic and ensure the performance of critical applications with limited network capacity
控制交通，确保有限网络容量下的应用性能。
QoS（Quality of Service，服务质量）指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术。QoS 的保证对于容量有限的网络来说是十分重要的，特别是对于流多媒体应用，例如 VoIP 和 IPTV 等，因为这些应用常常需要固定的传输率，对延时也比较敏感。
当网络发生拥塞的时候，所有的数据流都有可能被丢弃；为满足用户对不同应用不同服务质量的要求，就需要网络能根据用户的要求分配和调度资源，对不同的数据流提供不同的服务质量：</description></item><item><title>redis sds</title><link>https://donnol.github.io/posts/2021/12/redis_sds/</link><pubDate>Mon, 13 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/redis_sds/</guid><description>简单动态字符串 # 结构：
len alloc flag buf 长度(已使用空间大小) 分配(总共空间大小：buf 的大小减 1 &amp;ndash; &amp;lsquo;\0&amp;rsquo;字符占用了 1) 标记(sdshdr 的类型) 真正存储字符串的地方 文件：
sds.h, sdsalloc.h, sds.c.
定义：
typedef char *sds; 根据类型获取长度：
static inline size_t sdslen(const sds s) { unsigned char flags = s[-1]; switch(flags&amp;amp;SDS_TYPE_MASK) { case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8,s)-&amp;gt;len; case SDS_TYPE_16: return SDS_HDR(16,s)-&amp;gt;len; case SDS_TYPE_32: return SDS_HDR(32,s)-&amp;gt;len; case SDS_TYPE_64: return SDS_HDR(64,s)-&amp;gt;len; } return 0; } 新建：
/* Create a new sds string with the content specified by the &amp;#39;init&amp;#39; pointer * and &amp;#39;initlen&amp;#39;.</description></item><item><title>k8s</title><link>https://donnol.github.io/posts/2021/12/k8s/</link><pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/k8s/</guid><description>What # docker 带来容器之风，以致容器多不胜数。如何编排和管理众多容器，使得它们同心协力办好事情，即成为了当下最大的课题。
为此，k8s 应运而生。
容器，通讯，存储，配置。
Why # 为编排和管理数量众多的容器。
How # Install # k8s: 集群搭建所需资源 # One or more machines running one of:
Ubuntu 16.04+
Debian 9+
CentOS 7+
Red Hat Enterprise Linux (RHEL) 7+
Fedora 25+
HypriotOS v1.0.1+
Flatcar Container Linux (tested with 2512.3.0)
2 GB or more of RAM per machine (any less will leave little room for your apps).
2 CPUs or more.
Full network connectivity between all machines in the cluster (public or private network is fine).</description></item><item><title>数据密集型应用设计</title><link>https://donnol.github.io/posts/2021/12/ddia/</link><pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/ddia/</guid><description>第一章 可靠性、可扩展性、可维护性 # 数据密集型应用和计算密集型应用
现今很多应用程序都是 数据密集型（data-intensive） 的，而非 计算密集型（compute-intensive） 的。因此CPU很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。
数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程序都需要：
存储数据，以便自己或其他应用程序之后能再次找到 （数据库（database））
记住开销昂贵操作的结果，加快读取速度（缓存（cache））
允许用户按关键字搜索数据，或以各种方式对数据进行过滤（搜索索引（search indexes））
向其他进程发送消息，进行异步处理（流处理（stream processing））
定期处理累积的大批量数据（批处理（batch processing））
对应可选的组件在我映像中可以有：
数据库：mysql, postgresql
缓存: redis, memcached
搜索索引: elastic search, sonic, redis search
流处理: kafka, redis stream
批处理: linux cron, golang timer
使用较小的通用组件创建了一个全新的、专用的数据系统。
如何衡量一个系统的好坏 # 设计数据系统或服务时可能会遇到很多棘手的问题，例如：当系统出问题时，如何确保数据的正确性和完整性？当部分系统退化降级时，如何为客户提供始终如一的良好性能？当负载增加时，如何扩容应对？什么样的 API 才是好的 API？
可靠性（Reliability）
系统在困境（adversity）（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。
故障通常定义为系统的一部分状态偏离其标准，而失效则是系统作为一个整体停止向用户提供服务。故障的概率不可能降到零，因此最好设计容错机制以防因故障而导致失效。
硬件错误的解决：为了减少系统的故障率，第一反应通常都是增加单个硬件的冗余度，例如：磁盘可以组建 RAID，服务器可能有双路电源和热插拔 CPU，数据中心可能有电池和柴油发电机作为后备电源，某个组件挂掉时冗余组件可以立刻接管。
软件错误的解决：仔细考虑系统中的假设和交互；彻底的测试；进程隔离；允许进程崩溃并重启；测量、监控并分析生产环境中的系统行为。
人为错误的解决：
可扩展性（Scalability）
有合理的办法应对系统的增长（数据量、流量、复杂性）
可维护性（Maintainability）
许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。
从人的角度看：可靠就是能共困苦，同富贵；可扩展就是学习能力强，心胸广阔；可维护就是对人对己无偏见、无特例。
2PC（两阶段提交） # 2PC，two-phase commit，两阶段提交。
一种用于实现跨多个节点的原子事务提交的算法，即确保所有节点提交或所有节点中止。
2PC 使用一个通常不会出现在单节点事务中的新组件：协调者（coordinator）（也称为事务管理器（transaction manager））。
正常情况下，2PC 事务以应用在多个数据库节点上读写数据开始。我们称这些数据库节点为参与者（participants）。</description></item><item><title>burn cpu use golang</title><link>https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/</guid><description>虚假的 burn # package main func fakeBurn() { for { } } 真正的 burn # package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;time&amp;#34; ) var ( numBurn int updateInterval int ) func cpuBurn() { for { for i := 0; i &amp;lt; 2147483647; i++ { } // Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically. // Gosched让当前goroutine让出处理器，从而使得其它goroutine可以运行。它不会挂起/暂停当前的goroutine，它会自动恢复执行。 runtime.</description></item><item><title>docker compose使用extra host让容器访问主机服务</title><link>https://donnol.github.io/posts/2021/12/docker_compose_extra_host/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/docker_compose_extra_host/</guid><description>首发于：简单博客
docker compose 如何访问主机服务 # docker compose 里面的容器怎么访问主机自身起的服务呢？
20.10.0 版本在 linux 新增 host.docker.internal 支持： docker run -it --add-host=host.docker.internal:host-gateway alpine cat /etc/hosts
127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.1 host.docker.internal # --add-host的作用就是添加了这行到/etc/hosts 172.17.0.3 cb0565ceea26 相关提交
这个 add-host 的意思是告诉容器，容器对域名 host.docker.internal 的访问都将转发到 host-gateway 去。
也就是容器内部访问这个域名 host.docker.internal 时，就会访问到对应的主机上的 host-gateway 地址。
从而达到容器访问主机上服务的效果。
那么，这个 add-host 怎么用在 compose 上呢？
在 build 里使用 extra_hosts
version: &amp;#34;2.3&amp;#34; # 因为某个bug的存在，只能用version2，不能用version3 services: tmp: build: context: .</description></item><item><title>数据库管理工具之dbeaver</title><link>https://donnol.github.io/posts/2021/12/dbeaver/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/dbeaver/</guid><description>dbeaver: github
下载页
面向开发者、SQL 编程人员、数据库管理员和分析人员的免费的多平台数据库工具。 支持任何已有 JDBC 驱动的数据库（基本上是任何数据库）。商业版本还额外支持非 JDBC 数据源，比如：MongoDB, Cassandra, Couchbase, Redis, BigTable, DynamoDB 等。
拥有的特性：元数据编辑、SQL 编辑、富文本编辑、ER 图、数据导出/导入/转译、SQL 执行计划等。 基于 Eclipse 平台。 使用插件架构，为以下数据库提供额外功能：MySQL/MariaDB, PostgreSQL, Greenplum, Oracle, DB2 LUW, Exasol, SQL Server, Sybase/SAP ASE, SQLite, Firebird, H2, HSQLDB, Derby, Teradata, Vertica, Netezza, Informix 等。
Free multi-platform database tool for developers, SQL programmers, database administrators and analysts. Supports any database which has JDBC driver (which basically means - ANY database). Commercial versions also support non-JDBC datasources such as MongoDB, Cassandra, Couchbase, Redis, BigTable, DynamoDB, etc.</description></item><item><title>Domain-oriented development</title><link>https://donnol.github.io/posts/2021/12/domain/</link><pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/domain/</guid><description>面向领域开发。
将业务复杂度和技术复杂度分开，逐个击破。
分离领域，各司其职。
降低复杂度，容易测试。
DDD 尝试 # order.go:
package domain import ( &amp;#34;crypto/rand&amp;#34; &amp;#34;math/big&amp;#34; &amp;#34;github.com/pkg/errors&amp;#34; ) // 关键词：用户、店铺、商品、订单 // // 场景描述：店铺展示商品，其价格为P、库存为N，用户（余额为Y）看到商品觉得合适，于是下单购买B个； // 购买前，用户余额Y必须不小于P，商品库存N不小于B；购买后，用户余额减少P，库存减少B； // // 先不考虑并发情况，建立此时的领域模型 type User struct { name string // 名称 phone string // 电话 balance Money // 余额 } type Shop struct { name string // 名称 addr string // 地址 } type Product struct { name string // 名称 price Money // 价格 stock int // 库存 ownShop *Shop // 所属商铺 } type Order struct { name string // 名称 user *User // 用户 product *Product // 商品 } type Money int func NewUser(name, phone string, bal Money) *User { return &amp;amp;User{ name: name, phone: phone, balance: bal, } } func (u *User) Balance() Money { return u.</description></item><item><title>关于我</title><link>https://donnol.github.io/posts/aboutme/about-me/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/aboutme/about-me/</guid><description>听说读写想想干，吃喝玩乐洗洗睡。
思前想后成伟绩，轻描淡写道至理。
鹏程万里追无穷，法天象地铸有道。
生老病死自当然，功名利禄也枉然</description></item><item><title>github action deploy hugo blog</title><link>https://donnol.github.io/posts/2021/12/github_action_deploy_hugo_blog/</link><pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/github_action_deploy_hugo_blog/</guid><description>why # 为了将视线保持在文章上，减少构建和发布的时间占用。
what # github action是GitHub推出的持续集成/持续部署工具，只需要在项目中添加workflow.yml配置文件，在其中配置好任务、工作、步骤等，即可在指定动作发生时自动触发编排好的动作。换言之，如果我们在我们的博客仓库里配置了自动将内容打包和发布的workflow.yml，那我们就可以把精力集中在文章的编写，然后轻轻地提交推送，即可完成博客地打包和发布，very easy and smooth。
how # 在github准备一个blog仓库，用于存放原始信息；再准备一个github page仓库，用于存放打包数据。
其中github page仓库已开启page，可以通过github page设置的域名访问。
我的blog仓库
我的github page仓库
workflow # 这是我结合网络各位英豪所总结出来的一个workflow.yml配置文件
name: blog # 做什么都好，别忘了先起个平凡（kuxuan）的名字 on: # 指定触发动作 push: # 动作是：git push branches: - main # 指定分支： main jobs: build-deploy: runs-on: ubuntu-latest # 基于ubuntu steps: - uses: actions/checkout@v2 # 切换分支：git checkout with: submodules: recursive # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .</description></item><item><title>linux epoll</title><link>https://donnol.github.io/posts/2021/07/linux-epoll/</link><pubDate>Sat, 17 Jul 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/07/linux-epoll/</guid><description>linux epoll # wiki
手册
why # what # Linux内核的可扩展I/O事件通知机制。
于Linux 2.5.44首度登场，它设计目的旨在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能（举例来说：旧有的系统函数所花费的时间复杂度为O(n)，epoll的时间复杂度O(log n)）。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。
how # epoll 通过使用红黑树(RB-tree)搜索被监控的文件描述符(file descriptor)。
在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。
int epoll_create(int size); 在内核中创建epoll实例并返回一个epoll文件描述符。
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 向 epfd 对应的内核epoll 实例添加、修改或删除对 fd 上事件 event 的监听。op 可以为 EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别对应的是添加新的事件，修改文件描述符上监听的事件类型，从实例上删除一个事件。如果 event 的 events 属性设置了 EPOLLET flag，那么监听该事件的方式是边缘触发。
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 当 timeout 为 0 时，epoll_wait 永远会立即返回。而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。</description></item><item><title>Go实现AOP</title><link>https://donnol.github.io/posts/2021/01/proxy-between-layer/</link><pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/01/proxy-between-layer/</guid><description>AOP # 面向切面编程（AOP: Aspect Oriented Program）。
划分，重复，复用 # 我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。
出现的问题：
但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。
想法1：
也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。
那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？
这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。
有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。
OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。
从技术上来说，AOP基本上是通过代理机制实现的。
Go实现AOP &amp;ndash; 层间代理 # 假设有store，从数据库获取数据，其中有方法IUserStore.GetByID，传入id参数，返回用户信息:
type IUserStore interface { GetByID(ctx context.Context, id int) (User, error) } 另外有service，刚好有用户id并且需要拿到用户信息，于是依赖了上述IUserStore：
type IUserSrv interface { CheckUser(ctx context.Context, id int) error // 获取用户信息，然后检查用户某些属性 } type userImpl struct { userStore IUserStore } func (impl userImpl) CheckUser(ctx context.Context, id int) error { user, err := impl.userStore.GetByID(ctx, id) if err !</description></item><item><title>hugo搭建博客</title><link>https://donnol.github.io/posts/2021/01/hugo-blog/</link><pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/01/hugo-blog/</guid><description>操作 # 安装hugo。
使用hugo新建项目
添加主题
启动博客</description></item><item><title>go ctx</title><link>https://donnol.github.io/posts/2020/12/go-ctx/</link><pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2020/12/go-ctx/</guid><description>ctx # 1.why
goroutine号称百万之众，互相之间盘根错节，难以管理控制。为此，必须提供一种机制来管理控制它们。
各自为战 # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { // start first go func() { fmt.Println(1) }() // start second go func() { fmt.Println(2) }() time.Sleep(time.Second) } 万法归一 # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) func main() { wg := new(sync.WaitGroup) // start first wg.Add(1) go func() { defer wg.Done() fmt.Println(1) }() // start second wg.Add(1) go func() { defer wg.Done() fmt.</description></item><item><title>pstree进程树及说明</title><link>https://donnol.github.io/posts/2021/01/pstree/</link><pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/01/pstree/</guid><description> pstree进程树及说明 #</description></item><item><title/><link>https://donnol.github.io/posts/2023/09/%E4%B8%BA%E4%BA%86%E4%BB%96%E6%98%AF%E8%87%AA%E5%B7%B1%E8%BD%AF%E5%BC%B1%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%9F%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/%E4%B8%BA%E4%BA%86%E4%BB%96%E6%98%AF%E8%87%AA%E5%B7%B1%E8%BD%AF%E5%BC%B1%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%9F%E5%8F%A3/</guid><description>软弱如绵羊，却生造出老虎护幼崽的形象，只需一句“都是为了他”。</description></item><item><title/><link>https://donnol.github.io/posts/2023/11/go_template_dot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/11/go_template_dot/</guid><description>dot: 在模板里表示为.，表示当前作用域。
{{range}}, {{if}}, {{with}}均有自己的作用域。
{{if pipeline}}和{{with pipeline}}的区别是，前者不会修改.的值，而后者会。
with # with设置.的值：
{{with pipeline}} T1 {{end}} {{with pipeline}} T1 {{else}} T0 {{end}} 当pipeline不为0值时，点.设置为pipeline运算的值，否则跳过。
例如：
{{with &amp;#34;hello&amp;#34;}} {{println .}} {{end}} 将输入hello，因为.被设置为了hello.</description></item><item><title/><link>https://donnol.github.io/posts/2023/11/lllj/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/11/lllj/</guid><description>亮灯明途， 亮剑征服。 丽景慰人， 君芳抚世。</description></item><item><title/><link>https://donnol.github.io/posts/2023/11/%E4%B9%B0%E8%B5%8C%E6%8A%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/11/%E4%B9%B0%E8%B5%8C%E6%8A%A2/</guid><description>分-&amp;gt;买-&amp;gt;赌-&amp;gt;抢</description></item><item><title/><link>https://donnol.github.io/posts/2023/11/%E5%90%91%E5%BE%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/11/%E5%90%91%E5%BE%80/</guid><description>向往 # 营造一个环境，演绎一段故事，打造一个向往。
来使我消费。
现实的边际效用低了，就用想象中的来补充。</description></item><item><title/><link>https://donnol.github.io/posts/2023/11/%E5%B1%95%E5%BC%80%E5%AE%8F%E4%BB%A5%E6%96%B9%E4%BE%BF%E9%98%85%E8%AF%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/11/%E5%B1%95%E5%BC%80%E5%AE%8F%E4%BB%A5%E6%96%B9%E4%BE%BF%E9%98%85%E8%AF%BB/</guid><description> 展开宏以方便阅读 # gcc -E macro.c -o macro_expand.c.
-E Preprocess only; do not compile, assemble or link.
macro.c:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define SUM(a, b) ((a) + (b)) #define SUB(a, b) ((a) - (b)) int main() { int a = 2; int b = 1; int c = 0; c = SUM(a, b) + SUB(a, b); printf(&amp;#34;%d\n&amp;#34;, c); } 生成的macro_expand.c:
// 生成的文件里包含了非常多内容，这里就不一一展示了，有兴趣的可以自己试一下 // 其中关键的部分： # 7 &amp;#34;macro.c&amp;#34; int main() { int a = 2; int b = 1; int c = 0; c = ((a) + (b)) + ((a) - (b)); printf(&amp;#34;%d\n&amp;#34;, c); }</description></item><item><title/><link>https://donnol.github.io/posts/2023/11/%E7%90%86%E6%83%B3%E5%92%8C%E7%8E%B0%E5%AE%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/11/%E7%90%86%E6%83%B3%E5%92%8C%E7%8E%B0%E5%AE%9E/</guid><description>做的时候从现实出发，没人手、没时间、没资源，但是必须限期做出来；&amp;ndash; 死也死出来
评的时候从理想出发，这里应该、那里必须，依然还有好多要优化。&amp;ndash; 这点东西不够看</description></item><item><title/><link>https://donnol.github.io/posts/2023/12/do/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/12/do/</guid><description>做 # 直到烦躁、厌倦。
休息、转移。
然后继续。</description></item><item><title/><link>https://donnol.github.io/posts/2023/12/%E5%8F%8C%E6%A0%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/12/%E5%8F%8C%E6%A0%87/</guid><description>双标的进入 # 通过反问的方式来面对别人的质问。
如果对方拒绝回答，只顾质问，就开始进入双标了。
此时还讲道理，已无意义。
发动情绪，更为明智。</description></item><item><title/><link>https://donnol.github.io/posts/2023/12/%E5%8F%96%E4%B8%8E%E4%BA%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/12/%E5%8F%96%E4%B8%8E%E4%BA%A4/</guid><description>一人向他人索取
一人向他人提交
他人向他人索取
他人向他人征收</description></item><item><title/><link>https://donnol.github.io/posts/2023/12/%E6%83%85%E6%99%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/12/%E6%83%85%E6%99%AF/</guid><description>和煦的风，轻抚岸边的你。
生怕你不知，又怕被别人知道。
叫唤多少声，才能引起你注意。跳跃多少次，才能吸引你目光。
呱，呱呱······</description></item><item><title/><link>https://donnol.github.io/posts/2023/12/%E6%9A%96%E5%BA%8A%E5%92%8C%E6%B3%A1%E6%B5%B4%E7%BC%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/12/%E6%9A%96%E5%BA%8A%E5%92%8C%E6%B3%A1%E6%B5%B4%E7%BC%B8/</guid><description>docker和vm # docker是暖床，把环境warmup后，就离开了；
vm则是泡浴缸，得一直泡着。</description></item><item><title/><link>https://donnol.github.io/posts/2023/12/%E6%9C%AA%E6%9D%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/12/%E6%9C%AA%E6%9D%A5/</guid><description>未来 # 未来会是怎样，会有什么？
我如何在未来生存、发展？
二极分化 # 财富、心智、观念。
分化加深，则意味着断层；断层则意味着落差。
不小心的俯视，看到了令人作呕的景象，急忙躲闪；
不小心的仰望，目睹了令人艳羡的风景，急忙刹车。
左边是自己一样的厌恶，右边是别人一样的匆忙。
想停下来，却没有落脚之地。想飞起来，找不到可行航线。
枯萎、败亡、凋零。
终于有了新花，忍不住包裹、装饰、密封，最后依然破落。
新花说：“我想感受世界”。却终于被“保护”在铜墙铁壁，等待枯萎。
越珍贵，越保护；越保护，越顽固。
活力 # 做己所想，志趣之友。事尽心，人尽礼。辩理，尽情。
图文音画展俗世，琴棋诗画诉衷肠。</description></item><item><title/><link>https://donnol.github.io/posts/2023/12/%E8%A7%84%E7%9F%A9%E7%9A%84%E8%AE%A2%E7%AB%8B%E5%92%8C%E6%89%A7%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/12/%E8%A7%84%E7%9F%A9%E7%9A%84%E8%AE%A2%E7%AB%8B%E5%92%8C%E6%89%A7%E8%A1%8C/</guid><description>规矩：
名词 画圆形和方形的两种工具；比喻一定的标准、准则或惯例。 「要按 规矩办事」
形容词 符合标准或常理；老实本分。
何时订立、何时执行？
何地订立、何地执行？
何人订立、何人执行？
如何订立、如何执行？</description></item><item><title/><link>https://donnol.github.io/posts/2023/12/%E9%A9%B1%E8%99%8E%E5%90%9E%E7%8B%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/12/%E9%A9%B1%E8%99%8E%E5%90%9E%E7%8B%BC/</guid><description>驱虎吞狼与驱狼吞虎
什么能又驱虎，又驱狼呢？</description></item><item><title/><link>https://donnol.github.io/posts/2024/01/gopls-hightlight-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/01/gopls-hightlight-template/</guid><description>Gopls高亮template # 配置 # { &amp;#34;gopls&amp;#34;: { &amp;#34;templateExtensions&amp;#34;: [ &amp;#34;tpl&amp;#34;, &amp;#34;tmpl&amp;#34;, ], &amp;#34;ui.semanticTokens&amp;#34;: true }, &amp;#34;files.associations&amp;#34;: { &amp;#34;*.tpl&amp;#34;: &amp;#34;gotmpl&amp;#34;, &amp;#34;*.tmpl&amp;#34;: &amp;#34;gotmpl&amp;#34; } // ... } 当文件扩展名为tpl, tmpl时，均会视为是符合Go的template文件。
在编辑器里会有变量的高亮和智能提示。</description></item><item><title/><link>https://donnol.github.io/posts/2024/01/vscode%E9%80%89%E4%B8%AD%E6%89%80%E6%9C%89%E5%8C%B9%E9%85%8D%E9%A1%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/01/vscode%E9%80%89%E4%B8%AD%E6%89%80%E6%9C%89%E5%8C%B9%E9%85%8D%E9%A1%B9/</guid><description> vscode选中所有匹配项 # 快捷键：ctrl+shift+l
使用ctrl+f，找到匹配内容后，使用上述快捷键即可将所有匹配内容选中。</description></item><item><title/><link>https://donnol.github.io/posts/2024/01/wsl2_config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/01/wsl2_config/</guid><description>wsl2的一些配置 # 以下是在wsl虚拟机里面的配置
配置 # $ cat /etc/wsl.conf [boot] systemd=true # 启用systemd [interop] appendWindowsPath = false [network] generateResolvConf = false # 关闭自动生成resolv.conf 更新resolv.conf # $ cat Script/generateResolvConf.sh #!/bin/sh echo &amp;#39;nameserver 192.168.8.44&amp;#39; &amp;gt; /etc/resolv.conf 以systemd service在开机时执行脚本：
$ cat /etc/systemd/system/generateResolvConf.service [Unit] Description=Run generateResolvConf.sh to set dns of wsl2 at Startup [Service] ExecStart=/home/jd/Script/generateResolvConf.sh [Install] WantedBy=default.target 更新wslhost # wsl启动时，注册虚拟机ip到主机hosts：
$ cat Script/wsl2host.sh #!/bin/bash HOSTS_FILE_WIN=&amp;#39;/mnt/c/Windows/System32/drivers/etc/hosts&amp;#39; TEMP_DIR_PATH=&amp;#39;~/tmp/dns&amp;#39; TEMP_FILE_PATH=${TEMP_DIR_PATH}&amp;#39;/dns_back&amp;#39; # inetIp=`ifconfig eth0 | grep -o &amp;#34;inet [0-9]*\.</description></item><item><title/><link>https://donnol.github.io/posts/2024/01/%E5%88%BA%E7%A0%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/01/%E5%88%BA%E7%A0%B4/</guid><description>刺破的过程 # 拥挤，互相推搡；
往外走，发现气壁；
尝试推，遭遇阻挠；
用力打，鼻青脸肿；
怎么办？陷入迷茫&amp;hellip;
带路人，合力突刺。
更多人，集齐元气！</description></item><item><title/><link>https://donnol.github.io/posts/2024/01/%E5%A5%BD%E5%9D%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/01/%E5%A5%BD%E5%9D%8F/</guid><description>如果世界真的有好坏，那么坏人的猖狂就来源于好人的软弱。</description></item><item><title/><link>https://donnol.github.io/posts/2024/01/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/01/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8C%96/</guid><description>模块化和服务化 # 面向接口
模块化 # type I interface { A() B() C() } 服务化 # GET /user POST /user PUT /user DELETE /user 在多人协作开发过程中，先定义接口，达到并行开发的目的。
存在单人单服务的开发模式，也存在单人单模块的开发模式。
存在多人单服务的开发模式，也存在多人单模块的开发模式。
更存在存在多人多服务的开发模式，也存在多人多模块的开发模式。</description></item><item><title/><link>https://donnol.github.io/posts/2024/01/%E7%AE%97%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/01/%E7%AE%97%E6%95%B0/</guid><description>算数 # 定义（数）
计算（数）
使用（数）
期望和方差 # 定义 期望(Expectation)：度量一个随机变量取值的集中位置或平均水平。
方差(Variance)：是表示随机变量取值的分散性的一个数字特征。
怎么算？ 怎么用？ 方差越大，说明随机变量的取值分布越不均匀，变化性越强；方差越小，说明随机变量的取值越趋近于均值，即期望值。</description></item><item><title/><link>https://donnol.github.io/posts/2024/01/%E8%BD%AC%E5%90%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/01/%E8%BD%AC%E5%90%91/</guid><description>技术 -&amp;gt; 图文音画的技术 图文音画的技术 -&amp;gt; 内容</description></item><item><title/><link>https://donnol.github.io/posts/2024/01/%E8%BD%AF%E5%BC%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/01/%E8%BD%AF%E5%BC%B1/</guid><description>软弱 # 容易被包装为心慈仁善，实则是放虎归山、助纣为虐。</description></item><item><title/><link>https://donnol.github.io/posts/2024/02/%E5%A8%81%E6%9C%9B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/02/%E5%A8%81%E6%9C%9B/</guid><description>威望 # 权力、财富、名声。
威望带来威亚。
可以快速达成一致，也会阻碍想象和实践。</description></item><item><title/><link>https://donnol.github.io/posts/2024/02/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/02/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</guid><description>排列组合 # 可能出现的情况总数。
排列：是指从给定个数的元素中取出指定个数的元素进行排序。&amp;ndash; n个中取m个，需要考虑排序：n!/(n-m)!
组合：是指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序。&amp;ndash; n个中取m个，不考虑排序：n!/m!*(n-m)!
例如 # 3个球里取1个，有多少种排列呢？根据公式有：3*2*1/2*1 = 3，跟直觉一致。组合呢？根据公式有：3*2*1/1*2*1 = 3. 当取1个的时候，排列和组合是一样的，因为此时m! = 1.
3个球里取2个，排列：3*2*1/(3-2) = 6; 组合：3*2*1/2*1*1 = 3. 此时，排列数比组合数多。
如果用A、B、C分别表示3个球，则排列情况有：AB、AC、BC、BA、CA、CB；组合情况有：AB、AC、BC。
当n和m都很大时，需要借助计算机来计算： package main func factorial(n int) (s int) { s = 1 for i := 1; i &amp;lt;= n; i++ { s *= i } return } func main() { s := factorial(10) / factorial(10-4) println(&amp;#34;10个取4个的排列&amp;#34;, s) // 10个取4个的排列 5040 p := factorial(10) / factorial(10-4) * factorial(4) println(&amp;#34;10个取4个的组合&amp;#34;, p) // 10个取4个的组合 120960 } 执行</description></item><item><title/><link>https://donnol.github.io/posts/2024/02/%E7%89%A9%E6%9E%81%E5%BF%85%E5%8F%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/02/%E7%89%A9%E6%9E%81%E5%BF%85%E5%8F%8D/</guid><description>物极必反 # 追求极限的方法：
以人的意志，忽略自然规律。
尊重自然规律，科学寻找。
尽情发挥想象力，实现时必须遵循规律。</description></item><item><title/><link>https://donnol.github.io/posts/2024/03/%E5%85%B1%E6%80%A7%E5%92%8C%E4%B8%AA%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/03/%E5%85%B1%E6%80%A7%E5%92%8C%E4%B8%AA%E6%80%A7/</guid><description>共性 # 人物属性，天生造就。
个性 # 知行技能，后天培训。</description></item><item><title/><link>https://donnol.github.io/posts/2024/03/%E8%B6%85%E8%B5%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2024/03/%E8%B6%85%E8%B5%B6/</guid><description>超赶 # 一来就提超赶，不就承认自己落后了吗？
而且必须跟在别人屁股后面，屁颠屁颠的追赶。
后面发现跟不合适，进而出来了弯道超车。
再来就是遥遥领先了。
既然领先了，为什么还是那么焦虑？
因为又害怕被别人超赶了。
所以竞争到底是为了什么，为了焦虑，还是为了享受。
还是为了自己享受，让别人焦虑呢？</description></item></channel></rss>