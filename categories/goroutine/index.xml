<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Goroutine on 我的简单博客</title><link>https://donnol.github.io/categories/goroutine/</link><description>Recent content in Goroutine on 我的简单博客</description><generator>Hugo 0.125.2</generator><language>en</language><lastBuildDate>Wed, 16 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://donnol.github.io/categories/goroutine/index.xml" rel="self" type="application/rss+xml"/><item><title>goroutine vs tokio</title><link>https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/</guid><description>Reddit讨论贴
Go uses a different strategy for blocking systemcalls. It does not run them on a threadpool - it moves all the other goroutines that are queued to run on the current thread to a new worker thread, then runs the blocking systemcall on the current thread. This minimizes context switching.
You can do this in tokio as well, using task::block_in_place. If I change your code to use that instead of tokio::fs, it gets a lot closer to the go numbers.</description></item></channel></rss>