<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on 我的简单博客</title><link>https://donnol.github.io/categories/go/</link><description>Recent content in Go on 我的简单博客</description><generator>Hugo 0.125.2</generator><language>en</language><lastBuildDate>Wed, 20 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://donnol.github.io/categories/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go escape analysis</title><link>https://donnol.github.io/posts/2023/09/go_escape_analysis/</link><pubDate>Wed, 20 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/go_escape_analysis/</guid><description>The meaning of escapes to the heap is variables needs to be shared across the function stack frames [between main() and Println()] &amp;hellip;
&amp;hellip; So globally access variables must be moved to heap as it requires runtime. So the output line 11:2 shows the same as the data variable moved to the heap memory.
From</description></item><item><title>Vscode go cannot find GOROOT directory</title><link>https://donnol.github.io/posts/2023/09/goenv/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/goenv/</guid><description>今天发现在windows上的vscode一直提示找不到go：go: cannot find GOROOT directory: c:\msys64\mingw64\lib\go。
强制设置了go.goroot也不行，直到查看了GOENV文件（C:\Users\xxx\AppData\Roaming\go\env）之后，才发现里面有一行：GOROOT=c:\msys64\mingw64\lib\go，可能是当时在msys2安装go的时候加上的。
去掉它就恢复正常了。
$ go env set GOENV=C:\Users\xxx\AppData\Roaming\go\env set GOHOSTARCH=amd64 set GOHOSTOS=windows set GOMODCACHE=C:\Users\xxx\go\pkg\mod set GOOS=windows set GOPATH=C:\Users\xxx\go set GOPRIVATE= set GOPROXY=https://goproxy.cn,https://goproxy.io,direct set GOROOT=C:\Program Files\Go 应该是这样的，如果用go env -w 来设置goroot，那么这个值就会保存到GOENV对应的文件里，如果是$env:GOROOT=xxx的方式来设置则不会修改GOENV文件里的内容。这时候，如果vscode是优先从GOENV文件来获取GOROOT的话，就可能会导致与实际的GOROOT不一致。
所以，如果再遇到以上错误，除了echo $env:GOROOT 看一下环境变量值之外，也要看一下GOENV文件。</description></item><item><title>不同系统之间通过网络对接</title><link>https://donnol.github.io/posts/2023/09/%E7%B3%BB%E7%BB%9F%E9%97%B4%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E4%BA%A4%E4%BA%92%E4%BB%A5%E5%AE%8C%E6%88%90%E4%BA%8B%E5%8A%A1/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/%E7%B3%BB%E7%BB%9F%E9%97%B4%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E4%BA%A4%E4%BA%92%E4%BB%A5%E5%AE%8C%E6%88%90%E4%BA%8B%E5%8A%A1/</guid><description>不同系统之间通过网络对接
数据库事件 # 可以用个事件表来做，在事务执行过程中添加事件(确保事务完成时事件也存在)。
在事务提交之后，先尝试做一次事件，如果成功了就把事件状态置为成功；如果失败了也没关系，另外开定时器来扫表进行重试执行。 &amp;ndash; 此时不影响正常业务执行
在事件处理事务里的网络请求里加入超时控制，确保事件不会执行太久，导致接口过慢。
网络请求支持幂等，防止事件处理事务请求成功了，但是事务挂了导致状态未变更，这种情况下会重复请求多次。
skip locked实现 # -- 条件字段必须有索引(status, [name, status])，排序字段必须是主键(id)，此时刚好是所要锁定的行 start transaction; -- select * from w_event we where status in (1) order by create_time asc limit 1 for update skip locked; -- 引入create_time作为排序字段时，会将符合条件的行都锁住，`limit 1`不起作用 select * from w_event we where status in (1) order by id asc limit 1 for update skip locked; -- 使用主键字段作排序时，`limit 1`则起作用 select * from w_event we where name = &amp;#39;测试&amp;#39; and status in (1) order by id asc limit 1 for update skip locked; -- 如果有多个字段作为条件，需要建立组合索引 SELECT object_name, index_name, lock_type, lock_mode, lock_data FROM performance_schema.</description></item><item><title>Go Empty Struct</title><link>https://donnol.github.io/posts/2023/09/go_empty_struct/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/09/go_empty_struct/</guid><description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) func main() { type A struct{} type B struct{} // 结构体里的字段都是`Empty Struct`时，占用空间为0 type S struct { A A B B } var s S fmt.Println(unsafe.Sizeof(s)) // prints 0 // 如果是指针，占用空间为8 fmt.Println(unsafe.Sizeof(&amp;amp;s)) // prints 8 var x [1000000000]struct{} // 可以同时存储A和B类型元素 x[0] = A{} x[1] = B{} fmt.Println(unsafe.Sizeof(x)) // prints 0 // 地址一样 fmt.Printf(&amp;#34;%p, %p&amp;#34;, &amp;amp;x[0], &amp;amp;x[1]) // 0x54e3a0, 0x54e3a0 } See also</description></item><item><title>NATS</title><link>https://donnol.github.io/posts/2023/04/nats/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/04/nats/</guid><description>是什么？ # Home, Github
NATS 是一个简单、安全和高性能的通信系统，适用于数字系统、服务和设备。
NATS 是一种允许以消息形式分段的数据交换的基础架构。
基于主题 # 发布者将消息发到主题；订阅者订阅主题，在有消息到来时消费该消息。
主题命名规则：
基本字符：a to z, A to Z and 0 to 9 (区分大小写，不能包含空白字符).
特殊字符: . (分割符，分割不同部分，每部分视为一个token)； * 和 &amp;gt; (通配符，*表示匹配一个token，&amp;gt;表示匹配一或多个token).
保留主题名称: 以 $ 开头的用在系统内部 (如：$SYS, $JS, $KV &amp;hellip;)
发布-订阅 # Core NATS: 一个主题，存在一个发布者，多个订阅者。
消息会复制到多个订阅者。
请求-响应 # A request is sent, and the application either waits on the response with a certain timeout, or receives a response asynchronously.
&amp;ndash; 请求发出后，应用要不等待响应超时，要不就异步收到一个响应。</description></item><item><title>Go Generic Join</title><link>https://donnol.github.io/posts/2023/01/go_generic_join/</link><pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2023/01/go_generic_join/</guid><description>// NestedJoin like nested loop join func NestedJoin[J, K, R any]( left []J, right []K, match func(J, K) bool, mapper func(J, K) R, ) []R { var r = make([]R, 0, len(left)) for _, j := range left { for _, k := range right { if !match(j, k) { continue } r = append(r, mapper(j, k)) } } return r } // HashJoin like hash join func HashJoin[K comparable, LE, RE, R any]( left []LE, right []RE, lk func(item LE) K, rk func(item RE) K, mapper func(LE, RE) R, ) []R { var r = make([]R, 0, len(left)) rm := KeyBy(right, rk) for _, le := range left { k := lk(le) re := rm[k] r = append(r, mapper(le, re)) } return r } Code From</description></item><item><title>泛型</title><link>https://donnol.github.io/posts/2022/05/generic/</link><pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/05/generic/</guid><description>泛型 # 是什么？ # Type parameter, 类型参数。func Add[T Number](x, y T) (r T)，其中的T就是类型参数，它被接口Number所约束。
type Number interface { int | float32 } 调用方除了可自行决定参数值之外，还可以自行决定参数类型。Add[int](1, 2)，在调用时指定T的类型为int，同时传入参数值1,2必须是int类型。
这样使得代码更灵活，更有扩展性，同时更安全。
Go泛型 # 为什么？ # 静态语言，类型固定，比如这个函数：func Add(x, y int) int就要求参数和结果都必须是整型。
那如果后来又需要一个浮点数的加法呢？
那使用interface{}不也可以吗？
试看：
// 准确的描述出了参数和返回值的类型，非常方便 func Add(x, y int) int // 但也限制了Add函数的参数类型--只能接收`int` // Add(0.1, 0.2) // can&amp;#39;t do that // 那怎么办呢？再写一个针对float64的呗 func AddFloat64(x, y float64) float64 AddFloat64(0.1, 0.2) // it&amp;#39;s ok // 如果还要支持其它类型呢？再加一个吗，每多一种类型，就多加一个。。。 func AddInt8(x, y int8) int8 func AddInt32(x, y int32) int32 func AddFloat32(x, y float32) float32 // more.</description></item><item><title>Find out which Go version built your binary</title><link>https://donnol.github.io/posts/2022/05/find_go_version_the_app_use/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/05/find_go_version_the_app_use/</guid><description>根据二进制文件找出应用构建时使用的Go版本 # 使用 dlv:
dlv exec ./app &amp;gt; p runtime.buildVerion 或者，在代码里调用runtime.Version():
func main() { fmt.Println(&amp;#34;go version:&amp;#34;, runtime.Version()) } 参照</description></item><item><title>Go enum</title><link>https://donnol.github.io/posts/2022/05/go_enum/</link><pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/05/go_enum/</guid><description>Go enum # Go是没有内置枚举类型的，那么，当需要使用枚举时，该怎么办呢？
枚举说白了，就是一连串互斥的值，每个值代表一样事物或一个类型。
比如，现在需要一个颜色枚举，可以这样定义：
const ( Red = &amp;#34;Red&amp;#34; // 红色 Blue = &amp;#34;Blue&amp;#34; // 蓝色 Green = &amp;#34;Green&amp;#34; // 绿色 ) 也有这样定义的：
type Color string // 定义一个特定类型 // 枚举常量均声明为该类型 const ( Red Color = &amp;#34;Red&amp;#34; // 红色 Blue Color = &amp;#34;Blue&amp;#34; // 蓝色 Green Color = &amp;#34;Green&amp;#34; // 绿色 ) 这样做的好处是可以通过这个类型来更明显的标记出枚举字段来：
type Car struct { Name string Color Color // 颜色字段声明为Color类型，在阅读代码的时候就能知道这个字段正常的可选值范围 } 但是，上面的做法都需要面临一个问题，就是我需要一个返回全部枚举值的集合时，需要这样做：
func All() []Color { return []Color{ Red, Blue, Green, } } func (color Color) Name() string { switch color { case Red: return &amp;#34;红色&amp;#34; case Blue: return &amp;#34;蓝色&amp;#34; case Green: return &amp;#34;绿色&amp;#34; } return &amp;#34;&amp;#34; } 当在定义处新增值时，All和Name也要同步添加，对于开发人员来说，非常容易遗漏。</description></item><item><title>Go1.18 comparable</title><link>https://donnol.github.io/posts/2022/04/go1.18_comparable/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/04/go1.18_comparable/</guid><description>Go 1.18 预定义接口类型 # 先看一个提案: proposal: spec: permit values to have type &amp;ldquo;comparable&amp;rdquo; &amp;ndash; 允许值拥有comparable类型，我的理解是，现在的comparable只能用作泛型里的类型参数的约束，不能像普通类型那样使用，如下：
type Set[E comparable] []E // 可以用做类型参数的约束 // 使用go1.18编译，报错：interface is (or embeds) comparable var A comparable // 变量不可以使用`comparable`类型 那么，结合例子就能更好地理解这个提案了。
这个提案的主要目的就是让例子里的var A comparable成立，也就是允许comparable作为变量的类型，跟其它普通的接口类型(var E error)一样。
// proposal: spec: permit values to have type &amp;#34;comparable&amp;#34; // As part of adding generics, Go 1.18 introduces a new predeclared interface type comparable. That interface type is implemented by any non-interface type that is comparable, and by any interface type that is or embeds comparable.</description></item><item><title>goroutine vs tokio</title><link>https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/</guid><description>Reddit讨论贴
Go uses a different strategy for blocking systemcalls. It does not run them on a threadpool - it moves all the other goroutines that are queued to run on the current thread to a new worker thread, then runs the blocking systemcall on the current thread. This minimizes context switching.
You can do this in tokio as well, using task::block_in_place. If I change your code to use that instead of tokio::fs, it gets a lot closer to the go numbers.</description></item><item><title>go runtime chan</title><link>https://donnol.github.io/posts/2022/02/go_runtime_chan/</link><pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/02/go_runtime_chan/</guid><description>src/runtime/chan.go:
// Invariants: // At least one of c.sendq and c.recvq is empty, // except for the case of an unbuffered channel with a single goroutine // blocked on it for both sending and receiving using a select statement, // in which case the length of c.sendq and c.recvq is limited only by the // size of the select statement. // // For buffered channels, also: // c.qcount &amp;gt; 0 implies that c.</description></item><item><title>go work</title><link>https://donnol.github.io/posts/2022/02/go_work/</link><pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/02/go_work/</guid><description>go1.18将要推出workspace模式，此举是为了方便在本地开发多个不同module时的依赖管理。
命令说明：
$ go help work Go workspace provides access to operations on workspaces. Note that support for workspaces is built into many other commands, not just &amp;#39;go work&amp;#39;. See &amp;#39;go help modules&amp;#39; for information about Go\&amp;#39;s module system of which workspaces are a part. A workspace is specified by a go.work file that specifies a set of module directories with the &amp;#34;use&amp;#34; directive. These modules are used as root modules by the go command for builds and related operations.</description></item><item><title>Go快速入门</title><link>https://donnol.github.io/posts/2022/01/learn_go_fast/</link><pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/01/learn_go_fast/</guid><description>源码 # // 所有代码都需要放到包里 package color // 导入其它包 import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) // 枚举 type Color int // 常量 const ( Red Color = 1 // 红 Blue Color = 2 // 蓝 Green Color = 3 // 绿 ) // 函数 func NewCar( name string, rate int, ) *Car { return &amp;amp;Car{ name: name, rate: rate, } } // 类型 type Car struct { // 类型字段 name string // 首字母小写，非导出，只能包内使用 rate int } // 类型方法 func (car *Car) String() string { // 首字母大写，导出，可供其它包使用 return &amp;#34;[Car] name: &amp;#34; + car.</description></item><item><title>burn cpu use golang</title><link>https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/</guid><description>虚假的 burn # package main func fakeBurn() { for { } } 真正的 burn # package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;time&amp;#34; ) var ( numBurn int updateInterval int ) func cpuBurn() { for { for i := 0; i &amp;lt; 2147483647; i++ { } // Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically. // Gosched让当前goroutine让出处理器，从而使得其它goroutine可以运行。它不会挂起/暂停当前的goroutine，它会自动恢复执行。 runtime.</description></item><item><title>Go实现AOP</title><link>https://donnol.github.io/posts/2021/01/proxy-between-layer/</link><pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/01/proxy-between-layer/</guid><description>AOP # 面向切面编程（AOP: Aspect Oriented Program）。
划分，重复，复用 # 我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。
出现的问题：
但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。
想法1：
也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。
那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？
这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。
有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。
OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。
从技术上来说，AOP基本上是通过代理机制实现的。
Go实现AOP &amp;ndash; 层间代理 # 假设有store，从数据库获取数据，其中有方法IUserStore.GetByID，传入id参数，返回用户信息:
type IUserStore interface { GetByID(ctx context.Context, id int) (User, error) } 另外有service，刚好有用户id并且需要拿到用户信息，于是依赖了上述IUserStore：
type IUserSrv interface { CheckUser(ctx context.Context, id int) error // 获取用户信息，然后检查用户某些属性 } type userImpl struct { userStore IUserStore } func (impl userImpl) CheckUser(ctx context.Context, id int) error { user, err := impl.userStore.GetByID(ctx, id) if err !</description></item><item><title>go ctx</title><link>https://donnol.github.io/posts/2020/12/go-ctx/</link><pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2020/12/go-ctx/</guid><description>ctx # 1.why
goroutine号称百万之众，互相之间盘根错节，难以管理控制。为此，必须提供一种机制来管理控制它们。
各自为战 # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { // start first go func() { fmt.Println(1) }() // start second go func() { fmt.Println(2) }() time.Sleep(time.Second) } 万法归一 # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) func main() { wg := new(sync.WaitGroup) // start first wg.Add(1) go func() { defer wg.Done() fmt.Println(1) }() // start second wg.Add(1) go func() { defer wg.Done() fmt.</description></item></channel></rss>