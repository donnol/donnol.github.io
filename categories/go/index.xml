<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on 我的简单博客</title><link>https://donnol.github.io/categories/go/</link><description>Recent content in go on 我的简单博客</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 10 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://donnol.github.io/categories/go/index.xml" rel="self" type="application/rss+xml"/><item><title>go work</title><link>https://donnol.github.io/posts/2022/02/go_work/</link><pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/02/go_work/</guid><description>go1.18将要推出workspace模式，此举是为了方便在本地开发多个不同module时的依赖管理。
命令说明：
$ go help work Go workspace provides access to operations on workspaces. Note that support for workspaces is built into many other commands, not just &amp;#39;go work&amp;#39;. See &amp;#39;go help modules&amp;#39; for information about Go\&amp;#39;s module system of which workspaces are a part. A workspace is specified by a go.work file that specifies a set of module directories with the &amp;#34;use&amp;#34; directive. These modules are used as root modules by the go command for builds and related operations.</description></item><item><title>Go快速入门</title><link>https://donnol.github.io/posts/2022/01/learn_go_fast/</link><pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/01/learn_go_fast/</guid><description>源码 # // 所有代码都需要放到包里 package color // 导入其它包 import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) // 枚举 type Color int // 常量 const ( Red Color = 1 // 红 Blue Color = 2 // 蓝 Green Color = 3 // 绿 ) // 函数 func NewCar( name string, rate int, ) *Car { return &amp;amp;Car{ name: name, rate: rate, } } // 类型 type Car struct { // 类型字段 name string // 首字母小写，非导出，只能包内使用 rate int } // 类型方法 func (car *Car) String() string { // 首字母大写，导出，可供其它包使用 return &amp;#34;[Car] name: &amp;#34; + car.</description></item><item><title>burn cpu use golang</title><link>https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/</guid><description>虚假的 burn # package main func fakeBurn() { for { } } 真正的 burn # package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;time&amp;#34; ) var ( numBurn int updateInterval int ) func cpuBurn() { for { for i := 0; i &amp;lt; 2147483647; i++ { } // Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically. // Gosched让当前goroutine让出处理器，从而使得其它goroutine可以运行。它不会挂起/暂停当前的goroutine，它会自动恢复执行。 runtime.</description></item><item><title>go实现AOP</title><link>https://donnol.github.io/posts/2021/01/proxy-between-layer/</link><pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2021/01/proxy-between-layer/</guid><description>go实现AOP # 假设有store，从数据库获取数据，其中有方法IUserStore.GetByID，传入id参数，返回用户信息:
type IUserStore interface { GetByID(ctx context.Context, id int) (User, error) } 另外有service，刚好有用户id并且需要拿到用户信息，于是依赖了上述IUserStore：
type IUserSrv interface { CheckUser(ctx context.Context, id int) error // 获取用户信息，然后检查用户某些属性 } type userImpl struct { userStore IUserStore } func (impl userImpl) CheckUser(ctx context.Context, id int) error { user, err := impl.userStore.GetByID(ctx, id) if err != nil { return err } // 使用user数据做一些操作 _ = user } 上面所描述的是一个最简单的情况，如果我们要在userImpl.CheckUser里对impl.userStore.GetByID方法调用添加耗时统计，依然十分简单。
func (impl userImpl) CheckUser(ctx context.Context, id int) error { begin := time.</description></item><item><title>go ctx</title><link>https://donnol.github.io/posts/2020/12/go-ctx/</link><pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2020/12/go-ctx/</guid><description>ctx # 1.why
goroutine号称百万之众，互相之间盘根错节，难以管理控制。为此，必须提供一种机制来管理控制它们。
各自为战 # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { // start first go func() { fmt.Println(1) }() // start second go func() { fmt.Println(2) }() time.Sleep(time.Second) } 万法归一 # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) func main() { wg := new(sync.WaitGroup) // start first wg.Add(1) go func() { defer wg.Done() fmt.Println(1) }() // start second wg.</description></item></channel></rss>