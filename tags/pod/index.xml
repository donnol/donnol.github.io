<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pod on 我的简单博客</title><link>https://donnol.github.io/tags/pod/</link><description>Recent content in pod on 我的简单博客</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 13 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://donnol.github.io/tags/pod/index.xml" rel="self" type="application/rss+xml"/><item><title>k8s是怎么维持pod的运行的呢？</title><link>https://donnol.github.io/posts/2022/05/k8s_how_to_keep_pods/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/05/k8s_how_to_keep_pods/</guid><description>k8s是怎么维持pod的运行的呢？ # 当接收了yaml配置的信息后，是怎么维持pod根据声明一直运行的呢？
让我们沿着命令执行的过程来一睹为快：kubectl apply -f pod.yaml.
源码位置：cmd/kubectl/kubectl.go -&amp;gt; staging/src/k8s.io/kubectl/pkg/cmd/cmd.go -&amp;gt; staging/src/k8s.io/kubectl/pkg/cmd/apply/apply.go
最终的执行方法：
func (o *ApplyOptions) Run() error { // 预处理 if o.PreProcessorFn != nil { klog.V(4).Infof(&amp;#34;Running apply pre-processor function&amp;#34;) if err := o.PreProcessorFn(); err != nil { return err } } // Enforce CLI specified namespace on server request. if o.EnforceNamespace { o.VisitedNamespaces.Insert(o.Namespace) } // Generates the objects using the resource builder if they have not // already been stored by calling &amp;#34;SetObjects()&amp;#34; in the pre-processor.</description></item></channel></rss>