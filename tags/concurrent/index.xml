<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concurrent on 我的简单博客</title><link>https://donnol.github.io/tags/concurrent/</link><description>Recent content in Concurrent on 我的简单博客</description><generator>Hugo</generator><language>en</language><lastBuildDate>Wed, 16 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://donnol.github.io/tags/concurrent/index.xml" rel="self" type="application/rss+xml"/><item><title>goroutine vs tokio</title><link>https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/</guid><description>&lt;p>
 &lt;a href="https://www.reddit.com/r/rust/comments/lg0a7b/benchmarking_tokio_tasks_and_goroutines/">Reddit讨论贴&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>Go uses a different strategy for blocking systemcalls. It does not run them on a threadpool - it moves all the other goroutines that are queued to run on the current thread to a new worker thread, then runs the blocking systemcall on the current thread. &lt;strong>This minimizes context switching&lt;/strong>.&lt;/p>
&lt;p>You can do this in tokio as well, using &lt;strong>task::block_in_place&lt;/strong>. If I change your code to use that instead of tokio::fs, it gets a lot closer to the go numbers. Note that using block_in_place is not without caveats, and it only works on the multi-threaded runtime, not the single-threaded one. That&amp;rsquo;s why it&amp;rsquo;s not used in the implementation of tokio::fs.&lt;/p></description></item></channel></rss>