<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="src/runtime/chan.go:
// Invariants: // At least one of c.sendq and c.recvq is empty, // except for the case of an unbuffered channel with a single goroutine // blocked on it for both sending and receiving using a select statement, // in which case the length of c.sendq and c.recvq is limited only by the // size of the select statement. // // For buffered channels, also: // c.qcount > 0 implies that c."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="go runtime chan"><meta property="og:description" content="src/runtime/chan.go:
// Invariants: // At least one of c.sendq and c.recvq is empty, // except for the case of an unbuffered channel with a single goroutine // blocked on it for both sending and receiving using a select statement, // in which case the length of c.sendq and c.recvq is limited only by the // size of the select statement. // // For buffered channels, also: // c.qcount > 0 implies that c."><meta property="og:type" content="article"><meta property="og:url" content="https://donnol.github.io/posts/2022/02/go_runtime_chan/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-11T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-11T00:00:00+00:00"><title>go runtime chan | 我的简单博客</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.09a284f5a03730d86dde350d2c062b1514e48fdfebba7763941c0674ef65748f.css integrity="sha256-CaKE9aA3MNht3jUNLAYrFRTkj9/rundjlBwGdO9ldI8=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.fd36217c0db6ca85357003d0b09540f1242c121d837736cc98a1f375dda4c11f.js integrity="sha256-/TYhfA22yoU1cAPQsJVA8SQsEh2DdzbMmKHzdd2kwR8=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PNRWGCH4KN"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PNRWGCH4KN",{anonymize_ip:!1})}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>我的简单博客</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-c8e9ae7896ddc3e931652e7edbcbefe2 class=toggle checked>
<label for=section-c8e9ae7896ddc3e931652e7edbcbefe2 class="flex justify-between"><a role=button>2022</a></label><ul><li><input type=checkbox id=section-3811be776c86ac852ad674f5dc19e532 class=toggle>
<label for=section-3811be776c86ac852ad674f5dc19e532 class="flex justify-between"><a role=button>07</a></label><ul><li><a href=https://donnol.github.io/posts/2022/07/jump_table/>Jump Table</a></li><li><a href=https://donnol.github.io/posts/2022/07/number_calculate/>数字计算之分摊</a></li></ul></li><li><input type=checkbox id=section-d9a952ec7a0fcb7a9ba717dc9bfce17b class=toggle>
<label for=section-d9a952ec7a0fcb7a9ba717dc9bfce17b class="flex justify-between"><a role=button>05</a></label><ul><li><a href=https://donnol.github.io/posts/2022/05/generic/>泛型</a></li><li><a href=https://donnol.github.io/posts/2022/05/find_go_version_the_app_use/>Find out which Go version built your binary</a></li><li><a href=https://donnol.github.io/posts/2022/05/k8s_how_to_keep_pods/>k8s是怎么维持pod的运行的呢？</a></li><li><a href=https://donnol.github.io/posts/2022/05/go_enum/>Go enum</a></li></ul></li><li><input type=checkbox id=section-98bace91040a47ec7d7a95076963fc62 class=toggle>
<label for=section-98bace91040a47ec7d7a95076963fc62 class="flex justify-between"><a role=button>04</a></label><ul><li><a href=https://donnol.github.io/posts/2022/04/go1.18_comparable/>Go1.18 comparable</a></li></ul></li><li><input type=checkbox id=section-821dedbe2a29b27962c9696b13382042 class=toggle>
<label for=section-821dedbe2a29b27962c9696b13382042 class="flex justify-between"><a role=button>03</a></label><ul><li><a href=https://donnol.github.io/posts/2022/03/kmp/>KMP</a></li></ul></li><li><input type=checkbox id=section-935ca4c1d23ab780a0809b4bc7c413bf class=toggle checked>
<label for=section-935ca4c1d23ab780a0809b4bc7c413bf class="flex justify-between"><a role=button>02</a></label><ul><li><a href=https://donnol.github.io/posts/2022/02/%E9%9C%9C%E4%B9%8B%E5%93%80%E4%BC%A4/>霜之哀伤</a></li><li><a href=https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/>goroutine vs tokio</a></li><li><a href=https://donnol.github.io/posts/2022/02/go_runtime_chan/ class=active>go runtime chan</a></li><li><a href=https://donnol.github.io/posts/2022/02/go_work/>go work</a></li><li><a href=https://donnol.github.io/posts/2022/02/distractions/>杂念</a></li></ul></li><li><input type=checkbox id=section-a7c5705090b10b47e082065e722e7e5c class=toggle>
<label for=section-a7c5705090b10b47e082065e722e7e5c class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2022/01/rust_safe/>Rust与安全</a></li><li><a href=https://donnol.github.io/posts/2022/01/wasmtime/>wasm运行时wasmtime</a></li><li><a href=https://donnol.github.io/posts/2022/01/container_encrypt/>容器镜像加密</a></li><li><a href=https://donnol.github.io/posts/2022/01/smart_contract/>智能合约</a></li><li><a href=https://donnol.github.io/posts/2022/01/learn_go_fast/>Go快速入门</a></li><li><a href=https://donnol.github.io/posts/2022/01/consensus/>consensus</a></li><li><a href=https://donnol.github.io/posts/2022/01/red_black_tree/>红黑树</a></li><li><a href=https://donnol.github.io/posts/2022/01/rust_commonly_used_crate/>Rust常用库</a></li><li><a href=https://donnol.github.io/posts/2022/01/cache/>缓存和数据库如何保持一致</a></li></ul></li></ul></li><li><input type=checkbox id=section-71121fe02c394c786aa5fdaffc9e5412 class=toggle>
<label for=section-71121fe02c394c786aa5fdaffc9e5412 class="flex justify-between"><a role=button>2021</a></label><ul><li><input type=checkbox id=section-393d931b698132759df1a7089df0fcc8 class=toggle>
<label for=section-393d931b698132759df1a7089df0fcc8 class="flex justify-between"><a role=button>12</a></label><ul><li><a href=https://donnol.github.io/posts/2021/12/ebpf/>ebpf</a></li><li><a href=https://donnol.github.io/posts/2021/12/time_wenzi/>时间和文字</a></li><li><a href=https://donnol.github.io/posts/2021/12/etcd/>etcd</a></li><li><a href=https://donnol.github.io/posts/2021/12/vscode-go-module/>vscode-go在go.mod在非根目录情况下失效的问题</a></li><li><a href=https://donnol.github.io/posts/2021/12/mqtt/>mqtt</a></li><li><a href=https://donnol.github.io/posts/2021/12/redis_sds/>redis sds</a></li><li><a href=https://donnol.github.io/posts/2021/12/k8s/>k8s</a></li><li><a href=https://donnol.github.io/posts/2021/12/ddia/>数据密集型应用设计</a></li><li><a href=https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/>burn cpu use golang</a></li><li><a href=https://donnol.github.io/posts/2021/12/docker_compose_extra_host/>docker compose使用extra host让容器访问主机服务</a></li><li><a href=https://donnol.github.io/posts/2021/12/dbeaver/>数据库管理工具之dbeaver</a></li><li><a href=https://donnol.github.io/posts/2021/12/domain/>Domain-oriented development</a></li><li><a href=https://donnol.github.io/posts/2021/12/github_action_deploy_hugo_blog/>github action deploy hugo blog</a></li></ul></li><li><input type=checkbox id=section-b59662e33ca9ad77b7d385cbee7785fe class=toggle>
<label for=section-b59662e33ca9ad77b7d385cbee7785fe class="flex justify-between"><a role=button>07</a></label><ul><li><a href=https://donnol.github.io/posts/2021/07/linux-epoll/>linux epoll</a></li></ul></li><li><input type=checkbox id=section-3b66512bb507cbdaa9cef9549f229fc1 class=toggle>
<label for=section-3b66512bb507cbdaa9cef9549f229fc1 class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2021/01/proxy-between-layer/>Go实现AOP</a></li><li><a href=https://donnol.github.io/posts/2021/01/hugo-blog/>hugo搭建博客</a></li><li><a href=https://donnol.github.io/posts/2021/01/pstree/>pstree进程树及说明</a></li></ul></li></ul></li><li><input type=checkbox id=section-6f89cc6c76d5375fc02e3f7e596280b9 class=toggle>
<label for=section-6f89cc6c76d5375fc02e3f7e596280b9 class="flex justify-between"><a role=button>2020</a></label><ul><li><input type=checkbox id=section-03db05476b76e7f4afe06dfa3e1b675b class=toggle>
<label for=section-03db05476b76e7f4afe06dfa3e1b675b class="flex justify-between"><a role=button>12</a></label><ul><li><a href=https://donnol.github.io/posts/2020/12/go-ctx/>go ctx</a></li></ul></li></ul></li><li><a href=https://donnol.github.io/posts/aboutme/about-me/>关于我</a></li></ul><ul><li><a href=https://github.com/donnol/blog target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>go runtime chan</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class=markdown><h1><a href=/posts/2022/02/go_runtime_chan/>go runtime chan</a></h1><h5>February 11, 2022</h5><div><a href=/categories/go/>go</a>,
<a href=/categories/runtime/>runtime</a>,
<a href=/categories/chan/>chan</a></div><div><a href=/tags/chan/>chan</a></div><p><code>src/runtime/chan.go</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Invariants:
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  At least one of c.sendq and c.recvq is empty,
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  except for the case of an unbuffered channel with a single goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  blocked on it for both sending and receiving using a select statement,
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  in which case the length of c.sendq and c.recvq is limited only by the
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  size of the select statement.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// For buffered channels, also:
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  c.qcount &gt; 0 implies that c.recvq is empty.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  c.qcount &lt; c.dataqsiz implies that c.sendq is empty.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在文件开头，说明了几个不变量：
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  c.sendq和c.recvq中至少有一个是空的，
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  除非，一个无缓冲管道在一个goroutine里阻塞了，这个管道的发送和接收都使用了一个select语句，这时
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  c.sendq和c.recvq的长度被select语句限制。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 对于缓冲管道，同样地：
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  c.qcount &gt; 0 表明c.recvq是空的。
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  c.qcount &lt; c.dataqsiz 表明c.sendq是空的。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 实际的chan类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hchan</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>qcount</span>   <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// total data in the queue - 队列里的数据总数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>dataqsiz</span> <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// size of the circular queue - 循环队列的大小，make时传进来的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>buf</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// points to an array of dataqsiz elements - dataqsiz元素组成的数组的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>elemsize</span> <span style=color:#66d9ef>uint16</span> <span style=color:#75715e>// 元素大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>closed</span>   <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// 是否关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>elemtype</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span> <span style=color:#75715e>// element type - 元素类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sendx</span>    <span style=color:#66d9ef>uint</span>   <span style=color:#75715e>// send index - 发送索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>recvx</span>    <span style=color:#66d9ef>uint</span>   <span style=color:#75715e>// receive index - 接收索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>recvq</span>    <span style=color:#a6e22e>waitq</span>  <span style=color:#75715e>// list of recv waiters - 等待接收者列表，表明这个管道的接收者；一个链表，里面的每个元素代表一个g；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sendq</span>    <span style=color:#a6e22e>waitq</span>  <span style=color:#75715e>// list of send waiters - 等待发送者列表，编码这个管道的发送者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// lock protects all fields in hchan, as well as several
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// fields in sudogs blocked on this channel.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Do not change another G&#39;s status while holding this lock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// (in particular, do not ready a G), as this can deadlock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// with stack shrinking.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>mutex</span> <span style=color:#75715e>// 保护chan里的所有字段，以及阻塞在本管道里的sudog；当持有这个锁时，不要改变其它G的状态，因为在栈收缩时可能引起死锁。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>waitq</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>first</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>last</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// sudog represents a g in a wait list, such as for sending/receiving
</span></span></span><span style=display:flex><span><span style=color:#75715e>// on a channel. - 代表了一个在等待列表的g
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// sudog is necessary because the g ↔ synchronization object relation
</span></span></span><span style=display:flex><span><span style=color:#75715e>// is many-to-many. A g can be on many wait lists, so there may be
</span></span></span><span style=display:flex><span><span style=color:#75715e>// many sudogs for one g; and many gs may be waiting on the same
</span></span></span><span style=display:flex><span><span style=color:#75715e>// synchronization object, so there may be many sudogs for one object.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - sudog是必须的，因为g和同步对象关系是多对多。一个g可以在多个等待列表里，因此一个g对应有多个sudog；
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 多个g可以等待同一个同步对象，因此一个对象会对应多个sudog。
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// sudogs are allocated from a special pool. Use acquireSudog and
</span></span></span><span style=display:flex><span><span style=color:#75715e>// releaseSudog to allocate and free them.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - sudog从一个特殊池子里分配，使用acquireSudog分配和releaseSudog释放它们。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>sudog</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The following fields are protected by the hchan.lock of the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// channel this sudog is blocking on. shrinkstack depends on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// this for sudogs involved in channel ops.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// - 以下字段由hchan.lock来保护。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span> <span style=color:#75715e>// 代表的g
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span> <span style=color:#75715e>// 链表中的下一个
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>prev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span> <span style=color:#75715e>// 链表中的上一个
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// data element (may point to stack) - 数据元素，可能是指向栈的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The following fields are never accessed concurrently.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// For channels, waitlink is only accessed by g.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// For semaphores, all fields (including the ones above)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// are only accessed when holding a semaRoot lock.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// - 以下字段永远不会被并发访问。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 对于管道，waitlink只会被g访问。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 对于信号量，所有字段（包括上面的）只有在持有semaRoot锁时才能被访问
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>acquiretime</span> <span style=color:#66d9ef>int64</span> <span style=color:#75715e>// 获取时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>releasetime</span> <span style=color:#66d9ef>int64</span> <span style=color:#75715e>// 释放时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>ticket</span>      <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// 票据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// isSelect indicates g is participating in a select, so
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// g.selectDone must be CAS&#39;d to win the wake-up race.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>isSelect</span> <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// 表明g是否参与到了一个select里，从而使得g.selectDone必须CAS地去赢得唤醒竞赛
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// success indicates whether communication over channel c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// succeeded. It is true if the goroutine was awoken because a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// value was delivered over channel c, and false if awoken
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// because c was closed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>success</span> <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// 表明管道的通信是否成功了，如果goroutine因为一个值被管道传送到来而唤醒即为成功
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>parent</span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span> <span style=color:#75715e>// semaRoot binary tree - 根信号量二叉树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>waitlink</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span> <span style=color:#75715e>// g.waiting list or semaRoot - g的等待列表或semaRoot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>waittail</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span> <span style=color:#75715e>// semaRoot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>c</span>        <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span> <span style=color:#75715e>// channel - 所属管道
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 新建
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makechan</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>chantype</span>, <span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// compiler checks this but be safe.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>16</span> { <span style=color:#75715e>// 管道的元素大小不能太大
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;makechan: invalid channel element type&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#75715e>// const hchanSize uintptr = 96
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>hchanSize</span><span style=color:#f92672>%</span><span style=color:#a6e22e>maxAlign</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>align</span> &gt; <span style=color:#a6e22e>maxAlign</span> { <span style=color:#75715e>// 对齐检查
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;makechan: bad alignment&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 元素大小乘以管道大小，计算出来所需内存大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>, uintptr(<span style=color:#a6e22e>size</span>)) 
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span><span style=color:#f92672>-</span><span style=color:#a6e22e>hchanSize</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>size</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;makechan: size out of range&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// buf points into the same allocation, elemtype is persistent.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>mem</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Queue or element size is zero.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Race detector uses this location for synchronization.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>ptrdata</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Elements do not contain pointers. -- 元素没有包含指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Allocate hchan and buf in one call.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span><span style=color:#f92672>+</span><span style=color:#a6e22e>mem</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>c</span>), <span style=color:#a6e22e>hchanSize</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Elements contain pointers. -- 元素包含指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = new(<span style=color:#a6e22e>hchan</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemsize</span> = uint16(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span> = <span style=color:#a6e22e>elem</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> = uint(<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lockInit</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>lockRankHchan</span>) <span style=color:#75715e>// 初始化锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>debugChan</span> {
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>&#34;makechan: chan=&#34;</span>, <span style=color:#a6e22e>c</span>, <span style=color:#e6db74>&#34;; elemsize=&#34;</span>, <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>, <span style=color:#e6db74>&#34;; dataqsiz=&#34;</span>, <span style=color:#a6e22e>size</span>, <span style=color:#e6db74>&#34;\n&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 发送
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sendDirect</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>sg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>src</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// src is on our stack, dst is a slot on another stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// - src是在我们的栈上，dst是另一个栈上的槽
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Once we read sg.elem out of sg, it will no longer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// be updated if the destination&#39;s stack gets copied (shrunk).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// So make sure that no preemption points can happen between read &amp; use.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>dst</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>typeBitsBulkBarrier</span>(<span style=color:#a6e22e>t</span>, uintptr(<span style=color:#a6e22e>dst</span>), uintptr(<span style=color:#a6e22e>src</span>), <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// No need for cgo write barrier checks because dst is always
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Go memory.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>src</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>size</span>) <span style=color:#75715e>// 移动src到dst
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 接收 -- 请看源码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>closechan</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;close of nil channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 已关闭的chan，如果再次关闭会panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;close of closed channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>racewritepc</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>(), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>abi</span>.<span style=color:#a6e22e>FuncPCABIInternal</span>(<span style=color:#a6e22e>closechan</span>))
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>racerelease</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> = <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 设为关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>glist</span> <span style=color:#a6e22e>gList</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 先释放接收者，再释放发送者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// release all readers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>() <span style=color:#75715e>// 逐个出队sudog
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span>) <span style=color:#75715e>// 清理元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>success</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>raceacquireg</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>gp</span>) <span style=color:#75715e>// 把关联的g存到glist里
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// release all writers (they will panic)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>dequeue</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>success</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>raceacquireg</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Ready all Gs now that we&#39;ve dropped the channel lock.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> !<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>empty</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>pop</span>() <span style=color:#75715e>// 逐个处理g
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>schedlink</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#ae81ff>3</span>) <span style=color:#75715e>// 因为我们已经释放了这些g所关联的chan，所以让这些g进入ready状态，准备运行 -- Mark gp ready to run.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>src/runtime/type.go</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Needs to be in sync with ../cmd/link/internal/ld/decodesym.go:/^func.commonsize,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ../cmd/compile/internal/reflectdata/reflect.go:/^func.dcommontype and
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ../reflect/type.go:/^type.rtype.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ../internal/reflectlite/type.go:/^type.rtype.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 这个类型必须与链接器、编译器、反射等地方的类型保持同步
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_type</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>size</span>       <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>ptrdata</span>    <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// size of memory prefix holding all pointers - 持有所有指针的内存前缀大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>hash</span>       <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// 哈希值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>tflag</span>      <span style=color:#a6e22e>tflag</span> <span style=color:#75715e>// 类型标记
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>align</span>      <span style=color:#66d9ef>uint8</span> <span style=color:#75715e>// 对齐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fieldAlign</span> <span style=color:#66d9ef>uint8</span> <span style=color:#75715e>// 字段对齐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>kind</span>       <span style=color:#66d9ef>uint8</span> <span style=color:#75715e>// 种类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// function for comparing objects of this type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// (ptr to object A, ptr to object B) -&gt; ==?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>equal</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// 比较本类型的两个对象的指针的方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// gcdata stores the GC type data for the garbage collector.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// If the KindGCProg bit is set in kind, gcdata is a GC program.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gcdata</span>    <span style=color:#f92672>*</span><span style=color:#66d9ef>byte</span> <span style=color:#75715e>// 存储了垃圾收集器所需的GC类型数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>str</span>       <span style=color:#a6e22e>nameOff</span> <span style=color:#75715e>// 名称偏移
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>ptrToThis</span> <span style=color:#a6e22e>typeOff</span> <span style=color:#75715e>// 类型偏移
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>