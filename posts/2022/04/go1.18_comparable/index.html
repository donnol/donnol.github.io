<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go 1.18 预定义接口类型 #  先看一个提案: proposal: spec: permit values to have type &ldquo;comparable&rdquo; &ndash; 允许值拥有comparable类型，我的理解是，现在的comparable只能用作泛型里的类型参数的约束，不能像普通类型那样使用，如下：
type Set[E comparable] []E // 可以用做类型参数的约束  // 使用go1.18编译，报错：interface is (or embeds) comparable var A comparable // 变量不可以使用`comparable`类型 那么，结合例子就能更好地理解这个提案了。
这个提案的主要目的就是让例子里的var A comparable成立，也就是允许comparable作为变量的类型，跟其它普通的接口类型(var E error)一样。
// proposal: spec: permit values to have type &#34;comparable&#34;  // As part of adding generics, Go 1.18 introduces a new predeclared interface type comparable. That interface type is implemented by any non-interface type that is comparable, and by any interface type that is or embeds comparable."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Go1.18 comparable"><meta property="og:description" content="Go 1.18 预定义接口类型 #  先看一个提案: proposal: spec: permit values to have type &ldquo;comparable&rdquo; &ndash; 允许值拥有comparable类型，我的理解是，现在的comparable只能用作泛型里的类型参数的约束，不能像普通类型那样使用，如下：
type Set[E comparable] []E // 可以用做类型参数的约束  // 使用go1.18编译，报错：interface is (or embeds) comparable var A comparable // 变量不可以使用`comparable`类型 那么，结合例子就能更好地理解这个提案了。
这个提案的主要目的就是让例子里的var A comparable成立，也就是允许comparable作为变量的类型，跟其它普通的接口类型(var E error)一样。
// proposal: spec: permit values to have type &#34;comparable&#34;  // As part of adding generics, Go 1.18 introduces a new predeclared interface type comparable. That interface type is implemented by any non-interface type that is comparable, and by any interface type that is or embeds comparable."><meta property="og:type" content="article"><meta property="og:url" content="https://donnol.github.io/posts/2022/04/go1.18_comparable/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-22T00:00:00+00:00"><meta property="article:modified_time" content="2022-04-22T00:00:00+00:00"><title>Go1.18 comparable | 我的简单博客</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.09a284f5a03730d86dde350d2c062b1514e48fdfebba7763941c0674ef65748f.css integrity="sha256-CaKE9aA3MNht3jUNLAYrFRTkj9/rundjlBwGdO9ldI8=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.4cb5a8281a304cabc1f701e81373e404dc3b72605fe15f963284554487458d99.js integrity="sha256-TLWoKBowTKvB9wHoE3PkBNw7cmBf4V+WMoRVRIdFjZk=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PNRWGCH4KN"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PNRWGCH4KN",{anonymize_ip:!1})}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>我的简单博客</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-c8e9ae7896ddc3e931652e7edbcbefe2 class=toggle checked>
<label for=section-c8e9ae7896ddc3e931652e7edbcbefe2 class="flex justify-between"><a role=button>2022</a></label><ul><li><input type=checkbox id=section-d9a952ec7a0fcb7a9ba717dc9bfce17b class=toggle>
<label for=section-d9a952ec7a0fcb7a9ba717dc9bfce17b class="flex justify-between"><a role=button>05</a></label><ul><li><a href=https://donnol.github.io/posts/2022/05/find_go_version_the_app_use/>Find out which Go version built your binary</a></li><li><a href=https://donnol.github.io/posts/2022/05/k8s_how_to_keep_pods/>k8s是怎么维持pod的运行的呢？</a></li><li><a href=https://donnol.github.io/posts/2022/05/go_enum/>Go enum</a></li></ul></li><li><input type=checkbox id=section-98bace91040a47ec7d7a95076963fc62 class=toggle checked>
<label for=section-98bace91040a47ec7d7a95076963fc62 class="flex justify-between"><a role=button>04</a></label><ul><li><a href=https://donnol.github.io/posts/2022/04/go1.18_comparable/ class=active>Go1.18 comparable</a></li></ul></li><li><input type=checkbox id=section-821dedbe2a29b27962c9696b13382042 class=toggle>
<label for=section-821dedbe2a29b27962c9696b13382042 class="flex justify-between"><a role=button>03</a></label><ul><li><a href=https://donnol.github.io/posts/2022/03/kmp/>KMP</a></li></ul></li><li><input type=checkbox id=section-935ca4c1d23ab780a0809b4bc7c413bf class=toggle>
<label for=section-935ca4c1d23ab780a0809b4bc7c413bf class="flex justify-between"><a role=button>02</a></label><ul><li><a href=https://donnol.github.io/posts/2022/02/%E9%9C%9C%E4%B9%8B%E5%93%80%E4%BC%A4/>霜之哀伤</a></li><li><a href=https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/>goroutine vs tokio</a></li><li><a href=https://donnol.github.io/posts/2022/02/go_runtime_chan/>go runtime chan</a></li><li><a href=https://donnol.github.io/posts/2022/02/go_work/>go work</a></li><li><a href=https://donnol.github.io/posts/2022/02/distractions/>杂念</a></li></ul></li><li><input type=checkbox id=section-a7c5705090b10b47e082065e722e7e5c class=toggle>
<label for=section-a7c5705090b10b47e082065e722e7e5c class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2022/01/rust_safe/>Rust与安全</a></li><li><a href=https://donnol.github.io/posts/2022/01/wasmtime/>wasm运行时wasmtime</a></li><li><a href=https://donnol.github.io/posts/2022/01/container_encrypt/>容器镜像加密</a></li><li><a href=https://donnol.github.io/posts/2022/01/smart_contract/>智能合约</a></li><li><a href=https://donnol.github.io/posts/2022/01/learn_go_fast/>Go快速入门</a></li><li><a href=https://donnol.github.io/posts/2022/01/consensus/>consensus</a></li><li><a href=https://donnol.github.io/posts/2022/01/red_black_tree/>红黑树</a></li><li><a href=https://donnol.github.io/posts/2022/01/rust_commonly_used_crate/>Rust常用库</a></li><li><a href=https://donnol.github.io/posts/2022/01/cache/>缓存和数据库如何保持一致</a></li></ul></li></ul></li><li><input type=checkbox id=section-71121fe02c394c786aa5fdaffc9e5412 class=toggle>
<label for=section-71121fe02c394c786aa5fdaffc9e5412 class="flex justify-between"><a role=button>2021</a></label><ul><li><input type=checkbox id=section-393d931b698132759df1a7089df0fcc8 class=toggle>
<label for=section-393d931b698132759df1a7089df0fcc8 class="flex justify-between"><a role=button>12</a></label><ul><li><a href=https://donnol.github.io/posts/2021/12/ebpf/>ebpf</a></li><li><a href=https://donnol.github.io/posts/2021/12/time_wenzi/>时间和文字</a></li><li><a href=https://donnol.github.io/posts/2021/12/etcd/>etcd</a></li><li><a href=https://donnol.github.io/posts/2021/12/vscode-go-module/>vscode-go在go.mod在非根目录情况下失效的问题</a></li><li><a href=https://donnol.github.io/posts/2021/12/mqtt/>mqtt</a></li><li><a href=https://donnol.github.io/posts/2021/12/redis_sds/>redis sds</a></li><li><a href=https://donnol.github.io/posts/2021/12/k8s/>k8s</a></li><li><a href=https://donnol.github.io/posts/2021/12/ddia/>数据密集型应用设计</a></li><li><a href=https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/>burn cpu use golang</a></li><li><a href=https://donnol.github.io/posts/2021/12/docker_compose_extra_host/>docker compose使用extra host让容器访问主机服务</a></li><li><a href=https://donnol.github.io/posts/2021/12/dbeaver/>数据库管理工具之dbeaver</a></li><li><a href=https://donnol.github.io/posts/2021/12/domain/>Domain-oriented development</a></li><li><a href=https://donnol.github.io/posts/2021/12/github_action_deploy_hugo_blog/>github action deploy hugo blog</a></li></ul></li><li><input type=checkbox id=section-b59662e33ca9ad77b7d385cbee7785fe class=toggle>
<label for=section-b59662e33ca9ad77b7d385cbee7785fe class="flex justify-between"><a role=button>07</a></label><ul><li><a href=https://donnol.github.io/posts/2021/07/linux-epoll/>linux epoll</a></li></ul></li><li><input type=checkbox id=section-3b66512bb507cbdaa9cef9549f229fc1 class=toggle>
<label for=section-3b66512bb507cbdaa9cef9549f229fc1 class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2021/01/proxy-between-layer/>Go实现AOP</a></li><li><a href=https://donnol.github.io/posts/2021/01/hugo-blog/>hugo搭建博客</a></li><li><a href=https://donnol.github.io/posts/2021/01/pstree/>pstree进程树及说明</a></li></ul></li></ul></li><li><input type=checkbox id=section-6f89cc6c76d5375fc02e3f7e596280b9 class=toggle>
<label for=section-6f89cc6c76d5375fc02e3f7e596280b9 class="flex justify-between"><a role=button>2020</a></label><ul><li><input type=checkbox id=section-03db05476b76e7f4afe06dfa3e1b675b class=toggle>
<label for=section-03db05476b76e7f4afe06dfa3e1b675b class="flex justify-between"><a role=button>12</a></label><ul><li><a href=https://donnol.github.io/posts/2020/12/go-ctx/>go ctx</a></li></ul></li></ul></li><li><a href=https://donnol.github.io/posts/aboutme/about-me/>关于我</a></li></ul><ul><li><a href=https://github.com/donnol/blog target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go1.18 comparable</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#go-118-预定义接口类型>Go 1.18 预定义接口类型</a><ul><li><a href=#反射的comparable>反射的<code>Comparable</code></a></li><li><a href=#gotypes的comparable>go/types的<code>Comparable</code></a></li><li><a href=#更新>更新</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1><a href=/posts/2022/04/go1.18_comparable/>Go1.18 comparable</a></h1><h5>April 22, 2022</h5><div><a href=/categories/go/>go</a></div><div><a href=/tags/comparable/>comparable</a></div><h1 id=go-118-预定义接口类型>Go 1.18 预定义接口类型
<a class=anchor href=#go-118-%e9%a2%84%e5%ae%9a%e4%b9%89%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b>#</a></h1><p>先看一个提案:
<a href=https://github.com/golang/go/issues/51338>proposal: spec: permit values to have type &ldquo;comparable&rdquo;</a> &ndash; 允许值拥有<code>comparable</code>类型，我的理解是，现在的<code>comparable</code>只能用作泛型里的类型参数的约束，不能像普通类型那样使用，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Set</span>[<span style=color:#a6e22e>E</span> <span style=color:#a6e22e>comparable</span>] []<span style=color:#a6e22e>E</span> <span style=color:#75715e>// 可以用做类型参数的约束
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用go1.18编译，报错：interface is (or embeds) comparable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>A</span> <span style=color:#a6e22e>comparable</span> <span style=color:#75715e>// 变量不可以使用`comparable`类型
</span></span></span></code></pre></div><p>那么，结合例子就能更好地理解这个提案了。</p><p>这个提案的主要目的就是让例子里的<code>var A comparable</code>成立，也就是允许<code>comparable</code>作为变量的类型，跟其它普通的接口类型(<code>var E error</code>)一样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// proposal: spec: permit values to have type &#34;comparable&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// As part of adding generics, Go 1.18 introduces a new predeclared interface type comparable. That interface type is implemented by any non-interface type that is comparable, and by any interface type that is or embeds comparable. Comparable non-interface types are numeric, string, boolean, pointer, and channel types, structs all of whose field types are comparable, and arrays whose element types are comparable. Slice, map, and function types are not comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -- 作为泛型的一部分，Go1.18引入了一个新的预定义接口类型：`comparable`。这个接口类型由任何可比较的非接口类型实现，和任何是`comparable`或内嵌了`comparable`的接口类型实现。可比较的非接口类型有：数值、字符串、布尔、指针、字段类型均是可比较的管道或结构体类型、元素是可比较的数组类型。切片、映射、函数类型均是不可比较的。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// In Go, interface types are comparable in the sense that they can be compared with the == and != operators. However, interface types do not in general implement the predeclared interface type comparable. An interface type only implements comparable if it is or embeds comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 在Go里面，接口类型是可比较的意味着它们可以用`==`和`!=`操作符进行比较。但是，接口类型一般来说没有实现预定义接口类型`comparable`。一个接口类型只有它是或内嵌了`comparable`时才实现了`comparable`。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Developing this distinction between the predeclared type comparable and the general language notion of comparable has been confusing; see #50646. The distinction makes it hard to write certain kinds of generic code; see #51257.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 出现的两个问题：[怎么在文档里说明哪些接口实现它了呢？](https://github.com/golang/go/issues/50646), [any是任意类型的意思，那必然比comparable大吧](https://github.com/golang/go/issues/51257)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 突然想到：如果我要把一个变量表示为不可比较的，怎么样可以用`comparable`来表示呢，`!comparable`?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// For a specific example, you can today write a generic Set type of some specific (comparable) element type and write functions that work on sets of any element type:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// type Set[E comparable] map[E]bool
</span></span></span><span style=display:flex><span><span style=color:#75715e>// func Union[E comparable](s1, s2 Set[E]) Set[E] { ... }
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// But there is no way today to instantiate this Set type to create a general set that works for any (comparable) value. That is, you can&#39;t write Set[any], because any does not satisfy the constraint comparable. You can get a very similar effect by writing map[any]bool, but then all the functions like Union have to be written anew for this new version.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// We can reduce this kind of problem by permitting comparable to be an ordinary type. It then becomes possible to write Set[comparable].
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// As an ordinary type, comparable would be an interface type that is implemented by any comparable type.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 作为一个普通类型，`comparable`是一个可以被任意`comparable`类型实现的接口类型。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Any comparable non-interface type could be assigned to a variable of type comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -- 任何可比较的非接口类型可以被分配到类型为`comparable`的变量。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A value of an interface type that is or embeds comparable could be assigned to a variable of type comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -- 接口类型是或内嵌了`comparable`的值可以被分配到类型为`comparable`的变量。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A type assertion to comparable, as in x.(comparable), would succeed if the dynamic type of x is a comparable type.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 类型断言，如`x.(comparable)`，当x的动态类型是一个`comparable`类型时可以成功。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Similarly for a type switch case comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 对`type switch`来说类似。
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>C</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>comparable</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#a6e22e>C</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>A</span> <span style=color:#a6e22e>comparable</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>.(<span style=color:#a6e22e>comparable</span>); <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>a</span>.(<span style=color:#66d9ef>type</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>comparable</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=反射的comparable>反射的<code>Comparable</code>
<a class=anchor href=#%e5%8f%8d%e5%b0%84%e7%9a%84comparable>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ReflectComparable</span>(<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>typ</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Comparable reports whether values of this type are comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Even if Comparable returns true, the comparison may still panic.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// For example, values of interface type are comparable,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// but the comparison will panic if their dynamic type is not comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// -- 即使返回true，也有可能panic。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 比如：接口类型的值是可比较的，但如果它们的动态类型是不可比较的，就会panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>typ</span>.<span style=color:#a6e22e>Comparable</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=gotypes的comparable>go/types的<code>Comparable</code>
<a class=anchor href=#gotypes%e7%9a%84comparable>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TypesComparable</span>() <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewChan</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>SendOnly</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Basic</span>{})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Comparable</span>(<span style=color:#a6e22e>t</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=更新>更新
<a class=anchor href=#%e6%9b%b4%e6%96%b0>#</a></h2><p><a href=https://github.com/golang/go/issues/52614>使comparable仅在类型集里没有任何一个不可比较类型时正确，否则依然在编译时可通过，但运行时panic</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Comparable</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>comparable</span>](<span style=color:#a6e22e>t1</span>, <span style=color:#a6e22e>t2</span> <span style=color:#a6e22e>T</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t1</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>t2</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IC</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span>() <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ComparableStruct</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>cs</span> <span style=color:#a6e22e>ComparableStruct</span>) <span style=color:#a6e22e>Name</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>cs</span>.<span style=color:#a6e22e>name</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>NotComparableStruct</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ncs</span> <span style=color:#a6e22e>NotComparableStruct</span>) <span style=color:#a6e22e>Name</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ncs</span>.<span style=color:#a6e22e>name</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#a6e22e>IC</span> = <span style=color:#a6e22e>ComparableStruct</span>{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;jd&#34;</span>}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>IC</span> = <span style=color:#a6e22e>NotComparableStruct</span>{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;jd&#34;</span>, <span style=color:#a6e22e>m</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>string</span>)}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 现在提案没实现，所以普通接口并未实现comparable，会编译报错: IC does not implement comparable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 如果提案通过，将会是编译通过，执行panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Comparable(a, b)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#go-118-预定义接口类型>Go 1.18 预定义接口类型</a><ul><li><a href=#反射的comparable>反射的<code>Comparable</code></a></li><li><a href=#gotypes的comparable>go/types的<code>Comparable</code></a></li><li><a href=#更新>更新</a></li></ul></li></ul></nav></div></aside></main></body></html>