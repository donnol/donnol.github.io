<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go 1.18 预定义接口类型 # 先看一个提案: proposal: spec: permit values to have type &ldquo;comparable&rdquo; &ndash; 允许值拥有comparable类型，我的理解是，现在的comparable只能用作泛型里的类型参数的约束，不能像普通类型那样使用，如下：
type Set[E comparable] []E // 可以用做类型参数的约束 // 使用go1.18编译，报错：interface is (or embeds) comparable var A comparable // 变量不可以使用`comparable`类型 那么，结合例子就能更好地理解这个提案了。
这个提案的主要目的就是让例子里的var A comparable成立，也就是允许comparable作为变量的类型，跟其它普通的接口类型(var E error)一样。
// proposal: spec: permit values to have type &#34;comparable&#34; // As part of adding generics, Go 1.18 introduces a new predeclared interface type comparable. That interface type is implemented by any non-interface type that is comparable, and by any interface type that is or embeds comparable."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Go1.18 comparable"><meta property="og:description" content="Go 1.18 预定义接口类型 # 先看一个提案: proposal: spec: permit values to have type &ldquo;comparable&rdquo; &ndash; 允许值拥有comparable类型，我的理解是，现在的comparable只能用作泛型里的类型参数的约束，不能像普通类型那样使用，如下：
type Set[E comparable] []E // 可以用做类型参数的约束 // 使用go1.18编译，报错：interface is (or embeds) comparable var A comparable // 变量不可以使用`comparable`类型 那么，结合例子就能更好地理解这个提案了。
这个提案的主要目的就是让例子里的var A comparable成立，也就是允许comparable作为变量的类型，跟其它普通的接口类型(var E error)一样。
// proposal: spec: permit values to have type &#34;comparable&#34; // As part of adding generics, Go 1.18 introduces a new predeclared interface type comparable. That interface type is implemented by any non-interface type that is comparable, and by any interface type that is or embeds comparable."><meta property="og:type" content="article"><meta property="og:url" content="https://donnol.github.io/posts/2022/04/go1.18_comparable/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-22T00:00:00+00:00"><meta property="article:modified_time" content="2022-04-22T00:00:00+00:00"><title>Go1.18 comparable | 我的简单博客</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.95d69eb6bad8b9707ff2b5d8d9e31ce70a1b84f2ed7ffaf665ffcf00aa7993bd.css integrity="sha256-ldaetrrYuXB/8rXY2eMc5wobhPLtf/r2Zf/PAKp5k70=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.ab808fd97ac13c945bb66eea85af28930190ddd94202e0e3760bb77a0fb46ec8.js integrity="sha256-q4CP2XrBPJRbtm7qha8okwGQ3dlCAuDjdgu3eg+0bsg=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PNRWGCH4KN"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PNRWGCH4KN",{anonymize_ip:!1})}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>我的简单博客</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-313b4fa1ecd54472a2ea5583fbdf1f19 class=toggle>
<label for=section-313b4fa1ecd54472a2ea5583fbdf1f19 class="flex justify-between"><a role=button>2023</a></label><ul><li><input type=checkbox id=section-75e43d01b9c10d59b4f0d748da793cbc class=toggle>
<label for=section-75e43d01b9c10d59b4f0d748da793cbc class="flex justify-between"><a role=button>10</a></label><ul><li><a href=https://donnol.github.io/posts/2023/10/mysql_count_distinct_with_over/>Mysql 8.0.33在使用窗口函数的同时不能用count(distinct *)</a></li><li><a href=https://donnol.github.io/posts/2023/10/wezterm/>Wezterm极简配置文件</a></li></ul></li><li><input type=checkbox id=section-0b57a28d58aa7ae4f9361e78128e313e class=toggle>
<label for=section-0b57a28d58aa7ae4f9361e78128e313e class="flex justify-between"><a role=button>09</a></label><ul><li><a href=https://donnol.github.io/posts/2023/09/%E9%9B%AA%E8%8A%B1id-%E6%97%B6%E9%92%9F%E5%9B%9E%E9%80%80%E9%97%AE%E9%A2%98/>雪花id的时钟回退问题</a></li><li><a href=https://donnol.github.io/posts/2023/09/go_escape_analysis/>Go escape analysis</a></li><li><a href=https://donnol.github.io/posts/2023/09/do/>What are you preparing to do?</a></li><li><a href=https://donnol.github.io/posts/2023/09/mysql/>查找并杀掉运行中事务</a></li><li><a href=https://donnol.github.io/posts/2023/09/goenv/>Vscode go cannot find GOROOT directory</a></li><li><a href=https://donnol.github.io/posts/2023/09/%E7%B3%BB%E7%BB%9F%E9%97%B4%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E4%BA%A4%E4%BA%92%E4%BB%A5%E5%AE%8C%E6%88%90%E4%BA%8B%E5%8A%A1/>不同系统之间通过网络对接</a></li><li><a href=https://donnol.github.io/posts/2023/09/your_life/>do</a></li><li><a href=https://donnol.github.io/posts/2023/09/go_empty_struct/>Go Empty Struct</a></li><li><a href=https://donnol.github.io/posts/2023/09/%E4%B8%BA%E4%BA%86%E4%BB%96%E6%98%AF%E8%87%AA%E5%B7%B1%E8%BD%AF%E5%BC%B1%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%9F%E5%8F%A3/>为了他是自己软弱的最大借口</a></li></ul></li><li><input type=checkbox id=section-84371ed03cc5366386daf5e9a8332b26 class=toggle>
<label for=section-84371ed03cc5366386daf5e9a8332b26 class="flex justify-between"><a role=button>07</a></label><ul><li><a href=https://donnol.github.io/posts/2023/07/jupyter/>Jupyter notebook</a></li><li><a href=https://donnol.github.io/posts/2023/07/vscode_traslate/>Vscode Translate</a></li><li><a href=https://donnol.github.io/posts/2023/07/windows_restart_remote_service/>Windows restart remote service</a></li><li><a href=https://donnol.github.io/posts/2023/07/error/>错误的定义和返回</a></li><li><a href=https://donnol.github.io/posts/2023/07/prometheus/>Prometheus start failed</a></li><li><a href=https://donnol.github.io/posts/2023/07/compare_order/>Compare and Order</a></li></ul></li><li><input type=checkbox id=section-d4163ac285f8c34dd8d1a10b98f2d580 class=toggle>
<label for=section-d4163ac285f8c34dd8d1a10b98f2d580 class="flex justify-between"><a role=button>06</a></label><ul><li><a href=https://donnol.github.io/posts/2023/06/sklearn/>ml sklearn</a></li><li><a href=https://donnol.github.io/posts/2023/06/route/>windows route</a></li><li><a href=https://donnol.github.io/posts/2023/06/wsl2/>wsl2初始化Mysql数据库速度非常慢</a></li></ul></li><li><input type=checkbox id=section-8c180e0ce17abb68ae87c9e39d004c01 class=toggle>
<label for=section-8c180e0ce17abb68ae87c9e39d004c01 class="flex justify-between"><a role=button>05</a></label><ul><li><a href=https://donnol.github.io/posts/2023/05/flutter_widget_element/>flutter Widget Element</a></li><li><a href=https://donnol.github.io/posts/2023/05/mysqlrouter/>mysqlrouter使用</a></li></ul></li><li><input type=checkbox id=section-479bac08fe89212eeabe2bdb9d86347a class=toggle>
<label for=section-479bac08fe89212eeabe2bdb9d86347a class="flex justify-between"><a role=button>04</a></label><ul><li><a href=https://donnol.github.io/posts/2023/04/nats/>NATS</a></li></ul></li><li><input type=checkbox id=section-950a92f3ca235700f7752b33a7d3d434 class=toggle>
<label for=section-950a92f3ca235700f7752b33a7d3d434 class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2023/01/go_generic_join/>Go Generic Join</a></li></ul></li><li><a href=https://donnol.github.io/posts/2023/11/go_template_dot/>Go Template Dot</a></li><li><a href=https://donnol.github.io/posts/2023/11/lllj/>Lllj</a></li><li><a href=https://donnol.github.io/posts/2023/11/%E4%B9%B0%E8%B5%8C%E6%8A%A2/>买赌抢</a></li><li><a href=https://donnol.github.io/posts/2023/11/%E5%90%91%E5%BE%80/>向往</a></li><li><a href=https://donnol.github.io/posts/2023/11/%E5%B1%95%E5%BC%80%E5%AE%8F%E4%BB%A5%E6%96%B9%E4%BE%BF%E9%98%85%E8%AF%BB/>展开宏以方便阅读</a></li><li><a href=https://donnol.github.io/posts/2023/11/%E7%90%86%E6%83%B3%E5%92%8C%E7%8E%B0%E5%AE%9E/>理想和现实</a></li><li><a href=https://donnol.github.io/posts/2023/12/%E8%A7%84%E7%9F%A9%E7%9A%84%E8%AE%A2%E7%AB%8B%E5%92%8C%E6%89%A7%E8%A1%8C/>规矩的订立和执行</a></li></ul></li><li><input type=checkbox id=section-c8e9ae7896ddc3e931652e7edbcbefe2 class=toggle checked>
<label for=section-c8e9ae7896ddc3e931652e7edbcbefe2 class="flex justify-between"><a role=button>2022</a></label><ul><li><input type=checkbox id=section-3811be776c86ac852ad674f5dc19e532 class=toggle>
<label for=section-3811be776c86ac852ad674f5dc19e532 class="flex justify-between"><a role=button>07</a></label><ul><li><a href=https://donnol.github.io/posts/2022/07/jump_table/>Jump Table</a></li><li><a href=https://donnol.github.io/posts/2022/07/number_calculate/>数字计算之分摊</a></li></ul></li><li><input type=checkbox id=section-d9a952ec7a0fcb7a9ba717dc9bfce17b class=toggle>
<label for=section-d9a952ec7a0fcb7a9ba717dc9bfce17b class="flex justify-between"><a role=button>05</a></label><ul><li><a href=https://donnol.github.io/posts/2022/05/generic/>泛型</a></li><li><a href=https://donnol.github.io/posts/2022/05/find_go_version_the_app_use/>Find out which Go version built your binary</a></li><li><a href=https://donnol.github.io/posts/2022/05/k8s_how_to_keep_pods/>k8s是怎么维持pod的运行的呢？</a></li><li><a href=https://donnol.github.io/posts/2022/05/go_enum/>Go enum</a></li></ul></li><li><input type=checkbox id=section-98bace91040a47ec7d7a95076963fc62 class=toggle checked>
<label for=section-98bace91040a47ec7d7a95076963fc62 class="flex justify-between"><a role=button>04</a></label><ul><li><a href=https://donnol.github.io/posts/2022/04/go1.18_comparable/ class=active>Go1.18 comparable</a></li></ul></li><li><input type=checkbox id=section-821dedbe2a29b27962c9696b13382042 class=toggle>
<label for=section-821dedbe2a29b27962c9696b13382042 class="flex justify-between"><a role=button>03</a></label><ul><li><a href=https://donnol.github.io/posts/2022/03/kmp/>KMP</a></li></ul></li><li><input type=checkbox id=section-935ca4c1d23ab780a0809b4bc7c413bf class=toggle>
<label for=section-935ca4c1d23ab780a0809b4bc7c413bf class="flex justify-between"><a role=button>02</a></label><ul><li><a href=https://donnol.github.io/posts/2022/02/%E9%9C%9C%E4%B9%8B%E5%93%80%E4%BC%A4/>霜之哀伤</a></li><li><a href=https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/>goroutine vs tokio</a></li><li><a href=https://donnol.github.io/posts/2022/02/go_runtime_chan/>go runtime chan</a></li><li><a href=https://donnol.github.io/posts/2022/02/go_work/>go work</a></li><li><a href=https://donnol.github.io/posts/2022/02/distractions/>杂念</a></li></ul></li><li><input type=checkbox id=section-a7c5705090b10b47e082065e722e7e5c class=toggle>
<label for=section-a7c5705090b10b47e082065e722e7e5c class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2022/01/rust_safe/>Rust与安全</a></li><li><a href=https://donnol.github.io/posts/2022/01/wasmtime/>wasm运行时wasmtime</a></li><li><a href=https://donnol.github.io/posts/2022/01/container_encrypt/>容器镜像加密</a></li><li><a href=https://donnol.github.io/posts/2022/01/smart_contract/>智能合约</a></li><li><a href=https://donnol.github.io/posts/2022/01/learn_go_fast/>Go快速入门</a></li><li><a href=https://donnol.github.io/posts/2022/01/consensus/>consensus</a></li><li><a href=https://donnol.github.io/posts/2022/01/red_black_tree/>红黑树</a></li><li><a href=https://donnol.github.io/posts/2022/01/rust_commonly_used_crate/>Rust常用库</a></li><li><a href=https://donnol.github.io/posts/2022/01/cache/>缓存和数据库如何保持一致</a></li></ul></li><li><input type=checkbox id=section-f8031d80c43eae0ab94501ccf76874e3 class=toggle>
<label for=section-f8031d80c43eae0ab94501ccf76874e3 class="flex justify-between"><a role=button>12</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-71121fe02c394c786aa5fdaffc9e5412 class=toggle>
<label for=section-71121fe02c394c786aa5fdaffc9e5412 class="flex justify-between"><a role=button>2021</a></label><ul><li><input type=checkbox id=section-393d931b698132759df1a7089df0fcc8 class=toggle>
<label for=section-393d931b698132759df1a7089df0fcc8 class="flex justify-between"><a role=button>12</a></label><ul><li><a href=https://donnol.github.io/posts/2021/12/ebpf/>ebpf</a></li><li><a href=https://donnol.github.io/posts/2021/12/time_wenzi/>时间和文字</a></li><li><a href=https://donnol.github.io/posts/2021/12/etcd/>etcd</a></li><li><a href=https://donnol.github.io/posts/2021/12/vscode-go-module/>vscode-go在go.mod在非根目录情况下失效的问题</a></li><li><a href=https://donnol.github.io/posts/2021/12/mqtt/>mqtt</a></li><li><a href=https://donnol.github.io/posts/2021/12/redis_sds/>redis sds</a></li><li><a href=https://donnol.github.io/posts/2021/12/k8s/>k8s</a></li><li><a href=https://donnol.github.io/posts/2021/12/ddia/>数据密集型应用设计</a></li><li><a href=https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/>burn cpu use golang</a></li><li><a href=https://donnol.github.io/posts/2021/12/docker_compose_extra_host/>docker compose使用extra host让容器访问主机服务</a></li><li><a href=https://donnol.github.io/posts/2021/12/dbeaver/>数据库管理工具之dbeaver</a></li><li><a href=https://donnol.github.io/posts/2021/12/domain/>Domain-oriented development</a></li><li><a href=https://donnol.github.io/posts/2021/12/github_action_deploy_hugo_blog/>github action deploy hugo blog</a></li></ul></li><li><input type=checkbox id=section-b59662e33ca9ad77b7d385cbee7785fe class=toggle>
<label for=section-b59662e33ca9ad77b7d385cbee7785fe class="flex justify-between"><a role=button>07</a></label><ul><li><a href=https://donnol.github.io/posts/2021/07/linux-epoll/>linux epoll</a></li></ul></li><li><input type=checkbox id=section-3b66512bb507cbdaa9cef9549f229fc1 class=toggle>
<label for=section-3b66512bb507cbdaa9cef9549f229fc1 class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2021/01/proxy-between-layer/>Go实现AOP</a></li><li><a href=https://donnol.github.io/posts/2021/01/hugo-blog/>hugo搭建博客</a></li><li><a href=https://donnol.github.io/posts/2021/01/pstree/>pstree进程树及说明</a></li></ul></li></ul></li><li><input type=checkbox id=section-6f89cc6c76d5375fc02e3f7e596280b9 class=toggle>
<label for=section-6f89cc6c76d5375fc02e3f7e596280b9 class="flex justify-between"><a role=button>2020</a></label><ul><li><input type=checkbox id=section-03db05476b76e7f4afe06dfa3e1b675b class=toggle>
<label for=section-03db05476b76e7f4afe06dfa3e1b675b class="flex justify-between"><a role=button>12</a></label><ul><li><a href=https://donnol.github.io/posts/2020/12/go-ctx/>go ctx</a></li></ul></li></ul></li><li><a href=https://donnol.github.io/posts/aboutme/about-me/>关于我</a></li></ul><ul><li><a href=https://github.com/donnol/blog target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Go1.18 comparable</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#go-118-预定义接口类型>Go 1.18 预定义接口类型</a><ul><li><a href=#反射的comparable>反射的<code>Comparable</code></a></li><li><a href=#gotypes的comparable>go/types的<code>Comparable</code></a></li><li><a href=#更新>更新</a></li><li><a href=#更新2022-11-18>更新（2022-11-18）</a><ul><li><a href=#情况>情况</a></li><li><a href=#提议>提议</a></li><li><a href=#编译时静态检查>编译时静态检查</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1><a href=/posts/2022/04/go1.18_comparable/>Go1.18 comparable</a></h1><h5>April 22, 2022</h5><div><a href=/categories/go/>go</a></div><div><a href=/tags/comparable/>comparable</a></div><h1 id=go-118-预定义接口类型>Go 1.18 预定义接口类型
<a class=anchor href=#go-118-%e9%a2%84%e5%ae%9a%e4%b9%89%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b>#</a></h1><p>先看一个提案:
<a href=https://github.com/golang/go/issues/51338>proposal: spec: permit values to have type &ldquo;comparable&rdquo;</a> &ndash; 允许值拥有<code>comparable</code>类型，我的理解是，现在的<code>comparable</code>只能用作泛型里的类型参数的约束，不能像普通类型那样使用，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Set</span>[<span style=color:#a6e22e>E</span> <span style=color:#a6e22e>comparable</span>] []<span style=color:#a6e22e>E</span> <span style=color:#75715e>// 可以用做类型参数的约束
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用go1.18编译，报错：interface is (or embeds) comparable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>A</span> <span style=color:#a6e22e>comparable</span> <span style=color:#75715e>// 变量不可以使用`comparable`类型
</span></span></span></code></pre></div><p>那么，结合例子就能更好地理解这个提案了。</p><p>这个提案的主要目的就是让例子里的<code>var A comparable</code>成立，也就是允许<code>comparable</code>作为变量的类型，跟其它普通的接口类型(<code>var E error</code>)一样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// proposal: spec: permit values to have type &#34;comparable&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// As part of adding generics, Go 1.18 introduces a new predeclared interface type comparable. That interface type is implemented by any non-interface type that is comparable, and by any interface type that is or embeds comparable. Comparable non-interface types are numeric, string, boolean, pointer, and channel types, structs all of whose field types are comparable, and arrays whose element types are comparable. Slice, map, and function types are not comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -- 作为泛型的一部分，Go1.18引入了一个新的预定义接口类型：`comparable`。这个接口类型由任何可比较的非接口类型实现，和任何是`comparable`或内嵌了`comparable`的接口类型实现。可比较的非接口类型有：数值、字符串、布尔、指针、字段类型均是可比较的管道或结构体类型、元素是可比较的数组类型。切片、映射、函数类型均是不可比较的。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// In Go, interface types are comparable in the sense that they can be compared with the == and != operators. However, interface types do not in general implement the predeclared interface type comparable. An interface type only implements comparable if it is or embeds comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 在Go里面，接口类型是可比较的意味着它们可以用`==`和`!=`操作符进行比较。但是，接口类型一般来说没有实现预定义接口类型`comparable`。一个接口类型只有它是或内嵌了`comparable`时才实现了`comparable`。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Developing this distinction between the predeclared type comparable and the general language notion of comparable has been confusing; see #50646. The distinction makes it hard to write certain kinds of generic code; see #51257.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 出现的两个问题：[怎么在文档里说明哪些接口实现它了呢？](https://github.com/golang/go/issues/50646), [any是任意类型的意思，那必然比comparable大吧](https://github.com/golang/go/issues/51257)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 突然想到：如果我要把一个变量表示为不可比较的，怎么样可以用`comparable`来表示呢，`!comparable`?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// For a specific example, you can today write a generic Set type of some specific (comparable) element type and write functions that work on sets of any element type:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// type Set[E comparable] map[E]bool
</span></span></span><span style=display:flex><span><span style=color:#75715e>// func Union[E comparable](s1, s2 Set[E]) Set[E] { ... }
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// But there is no way today to instantiate this Set type to create a general set that works for any (comparable) value. That is, you can&#39;t write Set[any], because any does not satisfy the constraint comparable. You can get a very similar effect by writing map[any]bool, but then all the functions like Union have to be written anew for this new version.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// We can reduce this kind of problem by permitting comparable to be an ordinary type. It then becomes possible to write Set[comparable].
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// As an ordinary type, comparable would be an interface type that is implemented by any comparable type.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 作为一个普通类型，`comparable`是一个可以被任意`comparable`类型实现的接口类型。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Any comparable non-interface type could be assigned to a variable of type comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -- 任何可比较的非接口类型可以被分配到类型为`comparable`的变量。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A value of an interface type that is or embeds comparable could be assigned to a variable of type comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -- 接口类型是或内嵌了`comparable`的值可以被分配到类型为`comparable`的变量。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A type assertion to comparable, as in x.(comparable), would succeed if the dynamic type of x is a comparable type.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 类型断言，如`x.(comparable)`，当x的动态类型是一个`comparable`类型时可以成功。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Similarly for a type switch case comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 对`type switch`来说类似。
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>C</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>comparable</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#a6e22e>C</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>A</span> <span style=color:#a6e22e>comparable</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>.(<span style=color:#a6e22e>comparable</span>); <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>a</span>.(<span style=color:#66d9ef>type</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>comparable</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=反射的comparable>反射的<code>Comparable</code>
<a class=anchor href=#%e5%8f%8d%e5%b0%84%e7%9a%84comparable>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ReflectComparable</span>(<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>typ</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Comparable reports whether values of this type are comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Even if Comparable returns true, the comparison may still panic.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// For example, values of interface type are comparable,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// but the comparison will panic if their dynamic type is not comparable.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// -- 即使返回true，也有可能panic。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 比如：接口类型的值是可比较的，但如果它们的动态类型是不可比较的，就会panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>typ</span>.<span style=color:#a6e22e>Comparable</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=gotypes的comparable>go/types的<code>Comparable</code>
<a class=anchor href=#gotypes%e7%9a%84comparable>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TypesComparable</span>() <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewChan</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>SendOnly</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Basic</span>{})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Comparable</span>(<span style=color:#a6e22e>t</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=更新>更新
<a class=anchor href=#%e6%9b%b4%e6%96%b0>#</a></h2><p><a href=https://github.com/golang/go/issues/52614>使comparable仅在类型集里没有任何一个不可比较类型时正确，否则依然在编译时可通过，但运行时panic</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Comparable</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>comparable</span>](<span style=color:#a6e22e>t1</span>, <span style=color:#a6e22e>t2</span> <span style=color:#a6e22e>T</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t1</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>t2</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IC</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span>() <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ComparableStruct</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>cs</span> <span style=color:#a6e22e>ComparableStruct</span>) <span style=color:#a6e22e>Name</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>cs</span>.<span style=color:#a6e22e>name</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>NotComparableStruct</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ncs</span> <span style=color:#a6e22e>NotComparableStruct</span>) <span style=color:#a6e22e>Name</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ncs</span>.<span style=color:#a6e22e>name</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#a6e22e>IC</span> = <span style=color:#a6e22e>ComparableStruct</span>{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;jd&#34;</span>}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>IC</span> = <span style=color:#a6e22e>NotComparableStruct</span>{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;jd&#34;</span>, <span style=color:#a6e22e>m</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>string</span>)}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 现在提案没实现，所以普通接口并未实现comparable，会编译报错: IC does not implement comparable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 如果提案通过，将会是编译通过，执行panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Comparable(a, b)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=更新2022-11-18>更新（2022-11-18）
<a class=anchor href=#%e6%9b%b4%e6%96%b02022-11-18>#</a></h2><p><a href=https://github.com/golang/go/issues/56548>临近1.20发布之时，新的提案来了</a></p><h3 id=情况>情况
<a class=anchor href=#%e6%83%85%e5%86%b5>#</a></h3><p>这个提案会兼容泛型加入前已有的规则。也就是能用<code>==</code>，但是有可能在运行时panic。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>M</span> <span style=color:#66d9ef>struct</span>{ <span style=color:#a6e22e>f</span> <span style=color:#a6e22e>any</span> }                        <span style=color:#75715e>// 注意看，f字段的类型为any
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>M</span>{<span style=color:#a6e22e>f</span>: <span style=color:#ae81ff>1</span>} <span style=color:#f92672>==</span> <span style=color:#a6e22e>M</span>{<span style=color:#a6e22e>f</span>: <span style=color:#ae81ff>2</span>})               <span style=color:#75715e>// 可编译通过，运行时正常执行：false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>M</span>{<span style=color:#a6e22e>f</span>: []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>}} <span style=color:#f92672>==</span> <span style=color:#a6e22e>M</span>{<span style=color:#a6e22e>f</span>: []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>2</span>}}) <span style=color:#75715e>// 可编译通过，运行时panic：panic: runtime error: comparing uncomparable type []int
</span></span></span></code></pre></div><p><a href=https://go.dev/play/p/69Un_xqq0cX>跑来看看</a></p><blockquote><p>If we want any to satisfy comparable, then constraint satisfaction can&rsquo;t be the same as interface implementation. A non-comparable type T (say []int) implements any, but T does not implement comparable (T is not in comparable&rsquo;s type set). Therefore any cannot possibly implement comparable (the implements relation is transitive - we cannot change that). So if we want any to satisfy the comparable constraint, then constraint satisfaction can&rsquo;t be the same as interface implementation.</p><p>&ndash; 如果想要any满足comparable，约束满足就不能跟接口实现一样。
&ndash; 这里用[]int类型举例，它是不可比较的（其实它可以与nil比较，不过也仅能与nil比较），它实现了any，但它没有实现comparable。所以按照这样下去，any是不能实现comparable的。
&ndash; 那么，如果我们想要any满足comparable约束，约束满足就不能跟接口实现一样。</p></blockquote><h3 id=提议>提议
<a class=anchor href=#%e6%8f%90%e8%ae%ae>#</a></h3><blockquote><p>We change the spec to use a different rule for constraint satisfaction than for interface implementation: we want spec-comparable types to satisfy comparable; i.e., we want to be able to use any type for which == is defined even if it may not be strictly comparable.</p><p>&ndash; 修改spec规范，对于<code>约束满足</code>使用跟<code>接口实现</code>不同的规则。约定<code>spec-comparable</code>类型满足<code>comparable</code>。</p><p>With this change, constraint satisfaction matches interface implementation but also contains an exception for spec-comparable types. This exception permits the use of interfaces as type arguments which require strict comparability.</p><p>&ndash; 这样修改之后，<code>约束满足</code>除了会有一个关于<code>spec-comparable</code>类型的异常外，基本上匹配<code>接口实现</code>。这个异常允许使用接口作为泛型的类型参数，这个类型参数要求<code>strict-comparability(严格的可比较)</code>。</p></blockquote><p>关于<code>spec-comparable</code>和<code>strict-comparable</code>:</p><blockquote><p>For clarity, in the following we use the term <code>strictly comparable</code> for the types in comparable, and spec-comparable for types of <code>comparable operands</code>. Strictly comparable types are spec-comparable, but not the other way around. Types that are not spec-comparable are simply not comparable.</p><p>&ndash; 在<code>comparable</code>里的类型即是<code>strictly comparable</code>的，支持比较符（==，!=）的类型是<code>spec-comparable</code>。
很明显，<code>Strictly comparable</code>类型一定是<code>spec-comparable</code>，但反过来就不一定。不是<code>spec-comparable</code>的类型就一定不是<code>comparable</code>(不能满足comparable约束)。</p></blockquote><p>关于<code>satisfy</code>:</p><blockquote><p>We also add a new paragraph defining what &ldquo;satisfy&rdquo; means:</p><blockquote><p>A type T satisfies a constraint interface C if</p><p>T implements C; or
C can be written in the form interface{ comparable; E }, where E is a basic interface and T is comparable and implements E.</p></blockquote><p>&ndash; 如果说类型T满足约束C：
&ndash; T实现了C；或者
&ndash; C可以被写为以下格式：interface{ comparable: E}，其中<code>E是一个基础接口(只有方法，没有type set)</code>并且<code>T满足comparable约束并实现了E</code>。</p></blockquote><h3 id=编译时静态检查>编译时静态检查
<a class=anchor href=#%e7%bc%96%e8%af%91%e6%97%b6%e9%9d%99%e6%80%81%e6%a3%80%e6%9f%a5>#</a></h3><p><strong>那如何在编译时确保某类型是可比较的呢？</strong></p><p>如果要在编译时确保某个类型是可比较的，可以
<a href=https://github.com/golang/go/issues/56548#issuecomment-1317673963>这样</a>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// we want to ensure that T is strictly comparable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// define a helper function with a type parameter P constrained by T
</span></span></span><span style=display:flex><span><span style=color:#75715e>// and use that type parameter with isComparable
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -- 把该类型T作为约束使用，并且对应的类型参数用于实例化一个使用了comparable约束的泛型函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TisComparable</span>[<span style=color:#a6e22e>P</span> <span style=color:#a6e22e>T</span>]() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>isComparable</span>[<span style=color:#a6e22e>P</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isComparable</span>[<span style=color:#a6e22e>_</span> <span style=color:#a6e22e>comparable</span>]() {}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#go-118-预定义接口类型>Go 1.18 预定义接口类型</a><ul><li><a href=#反射的comparable>反射的<code>Comparable</code></a></li><li><a href=#gotypes的comparable>go/types的<code>Comparable</code></a></li><li><a href=#更新>更新</a></li><li><a href=#更新2022-11-18>更新（2022-11-18）</a><ul><li><a href=#情况>情况</a></li><li><a href=#提议>提议</a></li><li><a href=#编译时静态检查>编译时静态检查</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>