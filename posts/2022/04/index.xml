<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>04 on 我的简单博客</title><link>https://donnol.github.io/posts/2022/04/</link><description>Recent content in 04 on 我的简单博客</description><generator>Hugo 0.125.1</generator><language>en</language><lastBuildDate>Fri, 22 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://donnol.github.io/posts/2022/04/index.xml" rel="self" type="application/rss+xml"/><item><title>Go1.18 comparable</title><link>https://donnol.github.io/posts/2022/04/go1.18_comparable/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://donnol.github.io/posts/2022/04/go1.18_comparable/</guid><description>Go 1.18 预定义接口类型 # 先看一个提案: proposal: spec: permit values to have type &amp;ldquo;comparable&amp;rdquo; &amp;ndash; 允许值拥有comparable类型，我的理解是，现在的comparable只能用作泛型里的类型参数的约束，不能像普通类型那样使用，如下：
type Set[E comparable] []E // 可以用做类型参数的约束 // 使用go1.18编译，报错：interface is (or embeds) comparable var A comparable // 变量不可以使用`comparable`类型 那么，结合例子就能更好地理解这个提案了。
这个提案的主要目的就是让例子里的var A comparable成立，也就是允许comparable作为变量的类型，跟其它普通的接口类型(var E error)一样。
// proposal: spec: permit values to have type &amp;#34;comparable&amp;#34; // As part of adding generics, Go 1.18 introduces a new predeclared interface type comparable. That interface type is implemented by any non-interface type that is comparable, and by any interface type that is or embeds comparable.</description></item></channel></rss>