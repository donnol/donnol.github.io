<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="linux epoll #   wiki
 手册
why #  what #  Linux内核的可扩展I/O事件通知机制。
于Linux 2.5.44首度登场，它设计目的旨在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能（举例来说：旧有的系统函数所花费的时间复杂度为O(n)，epoll的时间复杂度O(log n)）。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。
how #  epoll 通过使用红黑树(RB-tree)搜索被监控的文件描述符(file descriptor)。
在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。
int epoll_create(int size); 在内核中创建epoll实例并返回一个epoll文件描述符。
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 向 epfd 对应的内核epoll 实例添加、修改或删除对 fd 上事件 event 的监听。op 可以为 EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别对应的是添加新的事件，修改文件描述符上监听的事件类型，从实例上删除一个事件。如果 event 的 events 属性设置了 EPOLLET flag，那么监听该事件的方式是边缘触发。
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 当 timeout 为 0 时，epoll_wait 永远会立即返回。而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content>
<meta property="og:description" content="linux epoll #   wiki
 手册
why #  what #  Linux内核的可扩展I/O事件通知机制。
于Linux 2.5.44首度登场，它设计目的旨在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能（举例来说：旧有的系统函数所花费的时间复杂度为O(n)，epoll的时间复杂度O(log n)）。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。
how #  epoll 通过使用红黑树(RB-tree)搜索被监控的文件描述符(file descriptor)。
在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。
int epoll_create(int size); 在内核中创建epoll实例并返回一个epoll文件描述符。
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 向 epfd 对应的内核epoll 实例添加、修改或删除对 fd 上事件 event 的监听。op 可以为 EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别对应的是添加新的事件，修改文件描述符上监听的事件类型，从实例上删除一个事件。如果 event 的 events 属性设置了 EPOLLET flag，那么监听该事件的方式是边缘触发。
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 当 timeout 为 0 时，epoll_wait 永远会立即返回。而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://donnol.github.io/posts/2021/07/linux-epoll/"><meta property="article:section" content="posts">
<title>Linux Epoll | 我的简单博客</title>
<link rel=manifest href=/manifest.json>
<link rel=icon href=/favicon.png type=image/x-icon>
<link rel=stylesheet href=/book.min.09a284f5a03730d86dde350d2c062b1514e48fdfebba7763941c0674ef65748f.css integrity="sha256-CaKE9aA3MNht3jUNLAYrFRTkj9/rundjlBwGdO9ldI8=" crossorigin=anonymous>
<script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.139c27fdbab6d041578f6a28fda49f9f4e26832ea79007c2ed274971a7203409.js integrity="sha256-E5wn/bq20EFXj2oo/aSfn04mgy6nkAfC7SdJcacgNAk=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/><span>我的简单博客</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
<ul>
<li>
<input type=checkbox id=section-71121fe02c394c786aa5fdaffc9e5412 class=toggle checked>
<label for=section-71121fe02c394c786aa5fdaffc9e5412 class="flex justify-between">
<a role=button>2021</a>
</label>
<ul>
<li>
<input type=checkbox id=section-393d931b698132759df1a7089df0fcc8 class=toggle>
<label for=section-393d931b698132759df1a7089df0fcc8 class="flex justify-between">
<a role=button>12</a>
</label>
<ul>
<li>
<a href=https://donnol.github.io/posts/2021/12/domain/>Domain-oriented development</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/12/github_action_deploy_hugo_blog/>github action deploy hugo blog</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/12/etcd/>Etcd</a>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-3b66512bb507cbdaa9cef9549f229fc1 class=toggle>
<label for=section-3b66512bb507cbdaa9cef9549f229fc1 class="flex justify-between">
<a role=button>01</a>
</label>
<ul>
<li>
<a href=https://donnol.github.io/posts/2021/01/proxy-between-layer/>go实现AOP</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/01/hugo-blog/>hugo搭建博客</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/01/pstree/>pstree进程树及说明</a>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-b59662e33ca9ad77b7d385cbee7785fe class=toggle checked>
<label for=section-b59662e33ca9ad77b7d385cbee7785fe class="flex justify-between">
<a role=button>07</a>
</label>
<ul>
<li>
<a href=https://donnol.github.io/posts/2021/07/linux-epoll/ class=active>Linux Epoll</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-6f89cc6c76d5375fc02e3f7e596280b9 class=toggle>
<label for=section-6f89cc6c76d5375fc02e3f7e596280b9 class="flex justify-between">
<a role=button>2020</a>
</label>
<ul>
<li>
<input type=checkbox id=section-03db05476b76e7f4afe06dfa3e1b675b class=toggle>
<label for=section-03db05476b76e7f4afe06dfa3e1b675b class="flex justify-between">
<a role=button>12</a>
</label>
<ul>
<li>
<a href=https://donnol.github.io/posts/2020/12/go-ctx/>go ctx</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href=https://donnol.github.io/posts/aboutme/about-me/>About Me</a>
</li>
</ul>
<ul>
<li>
<a href=https://github.com/donnol/blog target=_blank rel=noopener>
Github
</a>
</li>
<li>
<a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>
Hugo Themes
</a>
</li>
</ul>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>Linux Epoll</strong>
<label for=toc-control>
<img src=/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li><a href=#linux-epoll>linux epoll</a>
<ul>
<li><a href=#why>why</a></li>
<li><a href=#what>what</a></li>
<li><a href=#how>how</a>
<ul>
<li><a href=#触发模式>触发模式</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</aside>
</header>
<article class=markdown>
<h1>
<a href=/posts/2021/07/linux-epoll/>Linux Epoll</a>
</h1>
<h1 id=linux-epoll>
linux epoll
<a class=anchor href=#linux-epoll>#</a>
</h1>
<p>
<a href=https://zh.wikipedia.org/wiki/Epoll>wiki</a></p>
<p>
<a href=https://man7.org/linux/man-pages/man7/epoll.7.html>手册</a></p>
<h2 id=why>
why
<a class=anchor href=#why>#</a>
</h2>
<h2 id=what>
what
<a class=anchor href=#what>#</a>
</h2>
<p>Linux内核的<strong>可扩展I/O事件通知机制</strong>。</p>
<p>于Linux 2.5.44首度登场，它设计目的旨在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能（举例来说：旧有的系统函数所花费的时间复杂度为O(n)，epoll的时间复杂度O(log n)）。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。</p>
<h2 id=how>
how
<a class=anchor href=#how>#</a>
</h2>
<p>epoll 通过使用红黑树(RB-tree)搜索被监控的文件描述符(file descriptor)。</p>
<p>在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_create</span>(<span style=color:#66d9ef>int</span> size);
</code></pre></div><p>在内核中创建epoll实例并返回一个epoll文件描述符。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_ctl</span>(<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>int</span> op, <span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>event);
</code></pre></div><p>向 epfd 对应的内核epoll 实例添加、修改或删除对 fd 上事件 event 的监听。op 可以为 EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别对应的是添加新的事件，修改文件描述符上监听的事件类型，从实例上删除一个事件。如果 event 的 events 属性设置了 EPOLLET flag，那么监听该事件的方式是边缘触发。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_wait</span>(<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>events, <span style=color:#66d9ef>int</span> maxevents, <span style=color:#66d9ef>int</span> timeout);
</code></pre></div><p>当 timeout 为 0 时，epoll_wait 永远会立即返回。而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。</p>
<h3 id=触发模式>
触发模式
<a class=anchor href=#%e8%a7%a6%e5%8f%91%e6%a8%a1%e5%bc%8f>#</a>
</h3>
<p>epoll提供<strong>边沿触发</strong>及<strong>状态触发</strong>模式。</p>
<p>在边沿触发模式中，<strong>epoll_wait仅会在新的事件首次被加入epoll队列时返回</strong>；在状态触发模式下，epoll_wait在<strong>事件状态未变更前</strong>将不断被触发。状态触发模式是默认的模式。</p>
<p>状态触发模式与边沿触发模式有<strong>读和写</strong>两种情况，我们先来考虑读的情况。假设我们注册了一个读事件到epoll实例上，epoll实例会<strong>通过epoll_wait返回值的形式通知我们哪些读事件已经就绪</strong>。简单地来说，在状态触发模式下，如果读事件未被处理，该事件对应的内核读缓冲器非空，则<strong>每次调用<code>epoll_wait</code>时返回的事件列表都会包含该事件</strong>，直到该事件对应的内核读缓冲器为空为止。而在边沿触发模式下，<strong>读事件就绪后只会通知一次</strong>，不会反复通知。</p>
<p>然后我们再考虑写的情况。状态触发模式下，只要文件描述符对应的内核写缓冲器未满，就会<strong>一直通知可写事件</strong>。而在边沿触发模式下，内核写缓冲器由满变为未满后，只会<strong>通知一次可写事件</strong>。</p>
<p>举例来说，倘若有一个已经于epoll注册之流水线接获资料，epoll_wait将返回，并发出资料读取的信号。现假设缓冲器的资料仅有部分被读取并处理，在level-triggered(状态触发)模式下，任何对epoll_wait之调用都将<strong>即刻返回</strong>，直到缓冲器中的资料全部被读取；然而，在edge-triggered(边缘触发)的情境下，epoll_wait<strong>仅会于再次接收到新资料</strong>(亦即，新资料被写入流水线)时返回。</p>
<h4 id=边沿触发模式>
边沿触发模式
<a class=anchor href=#%e8%be%b9%e6%b2%bf%e8%a7%a6%e5%8f%91%e6%a8%a1%e5%bc%8f>#</a>
</h4>
<p>边沿触发模式使得<strong>程序有可能在用户态缓存 IO 状态</strong>。nginx 使用的是边沿触发模式。</p>
<p>文件描述符有两种情况是推荐使用边沿触发模式的。</p>
<ol>
<li>read 或者 write 系统调用返回了 EAGAIN。</li>
<li>非阻塞的文件描述符。</li>
</ol>
<p>可能的缺陷：</p>
<p>如果 IO 空间很大，你要花很多时间才能把它一次读完，这可能会导致<strong>饥饿</strong>。举个例子，假设你在监听一个文件描述符列表，而<strong>某个文件描述符上有大量的输入</strong>（不间断的输入流），那么你<strong>在读完它的过程中就没空处理其他就绪的文件描述符</strong>。（因为边沿触发模式<strong>只会通知一次可读事件</strong>，所以你<strong>往往会想一次把它读完</strong>。）一种解决方案是，程序维护一个就绪队列，当 epoll 实例通知某文件描述符就绪时将它<strong>在就绪队列数据结构中标记为就绪</strong>，这样程序就会记得哪些文件描述符等待处理。Round-Robin 循环处理就绪队列中就绪的文件描述符即可。</p>
<p>如果你缓存了所有事件，那么一种可能的情况是 A 事件的发生让程序关闭了另一个文件描述符 B。但是内核的 epoll 实例并不知道这件事，需要你从 epoll 删除掉。</p>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//donno272.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#linux-epoll>linux epoll</a>
<ul>
<li><a href=#why>why</a></li>
<li><a href=#what>what</a></li>
<li><a href=#how>how</a>
<ul>
<li><a href=#触发模式>触发模式</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>