<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go实现AOP &ndash; 层间代理 # 假设有store，从数据库获取数据，其中有方法IUserStore.GetByID，传入id参数，返回用户信息:
type IUserStore interface { GetByID(ctx context.Context, id int) (User, error) } 另外有service，刚好有用户id并且需要拿到用户信息，于是依赖了上述IUserStore：
type IUserSrv interface { CheckUser(ctx context.Context, id int) error // 获取用户信息，然后检查用户某些属性 } type userImpl struct { userStore IUserStore } func (impl userImpl) CheckUser(ctx context.Context, id int) error { user, err := impl.userStore.GetByID(ctx, id) if err != nil { return err } // 使用user数据做一些操作 _ = user } 上面所描述的是一个最简单的情况，如果我们要在userImpl.CheckUser里对impl.userStore.GetByID方法调用添加耗时统计，依然十分简单。
func (impl userImpl) CheckUser(ctx context."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Go实现AOP"><meta property="og:description" content="Go实现AOP &ndash; 层间代理 # 假设有store，从数据库获取数据，其中有方法IUserStore.GetByID，传入id参数，返回用户信息:
type IUserStore interface { GetByID(ctx context.Context, id int) (User, error) } 另外有service，刚好有用户id并且需要拿到用户信息，于是依赖了上述IUserStore：
type IUserSrv interface { CheckUser(ctx context.Context, id int) error // 获取用户信息，然后检查用户某些属性 } type userImpl struct { userStore IUserStore } func (impl userImpl) CheckUser(ctx context.Context, id int) error { user, err := impl.userStore.GetByID(ctx, id) if err != nil { return err } // 使用user数据做一些操作 _ = user } 上面所描述的是一个最简单的情况，如果我们要在userImpl.CheckUser里对impl.userStore.GetByID方法调用添加耗时统计，依然十分简单。
func (impl userImpl) CheckUser(ctx context."><meta property="og:type" content="article"><meta property="og:url" content="https://donnol.github.io/posts/2021/01/proxy-between-layer/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-17T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-17T00:00:00+00:00"><title>Go实现AOP | 我的简单博客</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.95d69eb6bad8b9707ff2b5d8d9e31ce70a1b84f2ed7ffaf665ffcf00aa7993bd.css integrity="sha256-ldaetrrYuXB/8rXY2eMc5wobhPLtf/r2Zf/PAKp5k70=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.78166b9d46e23e0ea915cb6887a30b633e7bc4fad10c8b6b9f6fa532271c19ba.js integrity="sha256-eBZrnUbiPg6pFctoh6MLYz57xPrRDItrn2+lMiccGbo=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PNRWGCH4KN"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PNRWGCH4KN",{anonymize_ip:!1})}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>我的简单博客</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-313b4fa1ecd54472a2ea5583fbdf1f19 class=toggle>
<label for=section-313b4fa1ecd54472a2ea5583fbdf1f19 class="flex justify-between"><a role=button>2023</a></label><ul><li><input type=checkbox id=section-479bac08fe89212eeabe2bdb9d86347a class=toggle>
<label for=section-479bac08fe89212eeabe2bdb9d86347a class="flex justify-between"><a role=button>04</a></label><ul><li><a href=https://donnol.github.io/posts/2023/04/nats/>NATS</a></li></ul></li><li><input type=checkbox id=section-950a92f3ca235700f7752b33a7d3d434 class=toggle>
<label for=section-950a92f3ca235700f7752b33a7d3d434 class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2023/01/go_generic_join/>Go Generic Join</a></li></ul></li></ul></li><li><input type=checkbox id=section-c8e9ae7896ddc3e931652e7edbcbefe2 class=toggle>
<label for=section-c8e9ae7896ddc3e931652e7edbcbefe2 class="flex justify-between"><a role=button>2022</a></label><ul><li><input type=checkbox id=section-3811be776c86ac852ad674f5dc19e532 class=toggle>
<label for=section-3811be776c86ac852ad674f5dc19e532 class="flex justify-between"><a role=button>07</a></label><ul><li><a href=https://donnol.github.io/posts/2022/07/jump_table/>Jump Table</a></li><li><a href=https://donnol.github.io/posts/2022/07/number_calculate/>数字计算之分摊</a></li></ul></li><li><input type=checkbox id=section-d9a952ec7a0fcb7a9ba717dc9bfce17b class=toggle>
<label for=section-d9a952ec7a0fcb7a9ba717dc9bfce17b class="flex justify-between"><a role=button>05</a></label><ul><li><a href=https://donnol.github.io/posts/2022/05/generic/>泛型</a></li><li><a href=https://donnol.github.io/posts/2022/05/find_go_version_the_app_use/>Find out which Go version built your binary</a></li><li><a href=https://donnol.github.io/posts/2022/05/k8s_how_to_keep_pods/>k8s是怎么维持pod的运行的呢？</a></li><li><a href=https://donnol.github.io/posts/2022/05/go_enum/>Go enum</a></li></ul></li><li><input type=checkbox id=section-98bace91040a47ec7d7a95076963fc62 class=toggle>
<label for=section-98bace91040a47ec7d7a95076963fc62 class="flex justify-between"><a role=button>04</a></label><ul><li><a href=https://donnol.github.io/posts/2022/04/go1.18_comparable/>Go1.18 comparable</a></li></ul></li><li><input type=checkbox id=section-821dedbe2a29b27962c9696b13382042 class=toggle>
<label for=section-821dedbe2a29b27962c9696b13382042 class="flex justify-between"><a role=button>03</a></label><ul><li><a href=https://donnol.github.io/posts/2022/03/kmp/>KMP</a></li></ul></li><li><input type=checkbox id=section-935ca4c1d23ab780a0809b4bc7c413bf class=toggle>
<label for=section-935ca4c1d23ab780a0809b4bc7c413bf class="flex justify-between"><a role=button>02</a></label><ul><li><a href=https://donnol.github.io/posts/2022/02/%E9%9C%9C%E4%B9%8B%E5%93%80%E4%BC%A4/>霜之哀伤</a></li><li><a href=https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/>goroutine vs tokio</a></li><li><a href=https://donnol.github.io/posts/2022/02/go_runtime_chan/>go runtime chan</a></li><li><a href=https://donnol.github.io/posts/2022/02/go_work/>go work</a></li><li><a href=https://donnol.github.io/posts/2022/02/distractions/>杂念</a></li></ul></li><li><input type=checkbox id=section-a7c5705090b10b47e082065e722e7e5c class=toggle>
<label for=section-a7c5705090b10b47e082065e722e7e5c class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2022/01/rust_safe/>Rust与安全</a></li><li><a href=https://donnol.github.io/posts/2022/01/wasmtime/>wasm运行时wasmtime</a></li><li><a href=https://donnol.github.io/posts/2022/01/container_encrypt/>容器镜像加密</a></li><li><a href=https://donnol.github.io/posts/2022/01/smart_contract/>智能合约</a></li><li><a href=https://donnol.github.io/posts/2022/01/learn_go_fast/>Go快速入门</a></li><li><a href=https://donnol.github.io/posts/2022/01/consensus/>consensus</a></li><li><a href=https://donnol.github.io/posts/2022/01/red_black_tree/>红黑树</a></li><li><a href=https://donnol.github.io/posts/2022/01/rust_commonly_used_crate/>Rust常用库</a></li><li><a href=https://donnol.github.io/posts/2022/01/cache/>缓存和数据库如何保持一致</a></li></ul></li><li><input type=checkbox id=section-f8031d80c43eae0ab94501ccf76874e3 class=toggle>
<label for=section-f8031d80c43eae0ab94501ccf76874e3 class="flex justify-between"><a role=button>12</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-71121fe02c394c786aa5fdaffc9e5412 class=toggle checked>
<label for=section-71121fe02c394c786aa5fdaffc9e5412 class="flex justify-between"><a role=button>2021</a></label><ul><li><input type=checkbox id=section-393d931b698132759df1a7089df0fcc8 class=toggle>
<label for=section-393d931b698132759df1a7089df0fcc8 class="flex justify-between"><a role=button>12</a></label><ul><li><a href=https://donnol.github.io/posts/2021/12/ebpf/>ebpf</a></li><li><a href=https://donnol.github.io/posts/2021/12/time_wenzi/>时间和文字</a></li><li><a href=https://donnol.github.io/posts/2021/12/etcd/>etcd</a></li><li><a href=https://donnol.github.io/posts/2021/12/vscode-go-module/>vscode-go在go.mod在非根目录情况下失效的问题</a></li><li><a href=https://donnol.github.io/posts/2021/12/mqtt/>mqtt</a></li><li><a href=https://donnol.github.io/posts/2021/12/redis_sds/>redis sds</a></li><li><a href=https://donnol.github.io/posts/2021/12/k8s/>k8s</a></li><li><a href=https://donnol.github.io/posts/2021/12/ddia/>数据密集型应用设计</a></li><li><a href=https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/>burn cpu use golang</a></li><li><a href=https://donnol.github.io/posts/2021/12/docker_compose_extra_host/>docker compose使用extra host让容器访问主机服务</a></li><li><a href=https://donnol.github.io/posts/2021/12/dbeaver/>数据库管理工具之dbeaver</a></li><li><a href=https://donnol.github.io/posts/2021/12/domain/>Domain-oriented development</a></li><li><a href=https://donnol.github.io/posts/2021/12/github_action_deploy_hugo_blog/>github action deploy hugo blog</a></li></ul></li><li><input type=checkbox id=section-b59662e33ca9ad77b7d385cbee7785fe class=toggle>
<label for=section-b59662e33ca9ad77b7d385cbee7785fe class="flex justify-between"><a role=button>07</a></label><ul><li><a href=https://donnol.github.io/posts/2021/07/linux-epoll/>linux epoll</a></li></ul></li><li><input type=checkbox id=section-3b66512bb507cbdaa9cef9549f229fc1 class=toggle checked>
<label for=section-3b66512bb507cbdaa9cef9549f229fc1 class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2021/01/proxy-between-layer/ class=active>Go实现AOP</a></li><li><a href=https://donnol.github.io/posts/2021/01/hugo-blog/>hugo搭建博客</a></li><li><a href=https://donnol.github.io/posts/2021/01/pstree/>pstree进程树及说明</a></li></ul></li></ul></li><li><input type=checkbox id=section-6f89cc6c76d5375fc02e3f7e596280b9 class=toggle>
<label for=section-6f89cc6c76d5375fc02e3f7e596280b9 class="flex justify-between"><a role=button>2020</a></label><ul><li><input type=checkbox id=section-03db05476b76e7f4afe06dfa3e1b675b class=toggle>
<label for=section-03db05476b76e7f4afe06dfa3e1b675b class="flex justify-between"><a role=button>12</a></label><ul><li><a href=https://donnol.github.io/posts/2020/12/go-ctx/>go ctx</a></li></ul></li></ul></li><li><a href=https://donnol.github.io/posts/aboutme/about-me/>关于我</a></li></ul><ul><li><a href=https://github.com/donnol/blog target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go实现AOP</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#go实现aop----层间代理>Go实现AOP &ndash; 层间代理</a></li><li><a href=#接口mockaroundhttpsgithubcomdonnoltoolsblobmasterinjectproxygo><a href=https://github.com/donnol/tools/blob/master/inject/proxy.go>接口，Mock，Around</a></a></li><li><a href=#这里的示例httpsgithubcomdonnoltoolsblobmasterinjectproxy_testgo><a href=https://github.com/donnol/tools/blob/master/inject/proxy_test.go>这里的示例</a></a></li><li><a href=#代码生成替代反射>代码生成替代反射</a></li><li><a href=#对于任意函数调用通过替换ast节点来添加proxy>对于任意函数调用通过替换ast节点来添加Proxy</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1><a href=/posts/2021/01/proxy-between-layer/>Go实现AOP</a></h1><h5>January 17, 2021</h5><div><a href=/categories/go/>go</a></div><div><a href=/tags/aop/>aop</a>,
<a href=/tags/proxy/>proxy</a></div><h2 id=go实现aop----层间代理>Go实现AOP &ndash; 层间代理
<a class=anchor href=#go%e5%ae%9e%e7%8e%b0aop----%e5%b1%82%e9%97%b4%e4%bb%a3%e7%90%86>#</a></h2><p>假设有store，从数据库获取数据，其中有方法IUserStore.GetByID，传入id参数，返回用户信息:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IUserStore</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>GetByID</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>User</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>另外有service，刚好有用户id并且需要拿到用户信息，于是依赖了上述IUserStore：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IUserSrv</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CheckUser</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span> <span style=color:#75715e>// 获取用户信息，然后检查用户某些属性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>userImpl</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>userStore</span> <span style=color:#a6e22e>IUserStore</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>impl</span> <span style=color:#a6e22e>userImpl</span>) <span style=color:#a6e22e>CheckUser</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>impl</span>.<span style=color:#a6e22e>userStore</span>.<span style=color:#a6e22e>GetByID</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用user数据做一些操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>user</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面所描述的是一个最简单的情况，如果我们要在userImpl.CheckUser里对impl.userStore.GetByID方法调用添加耗时统计，依然十分简单。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>impl</span> <span style=color:#a6e22e>userImpl</span>) <span style=color:#a6e22e>CheckUser</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>begin</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>impl</span>.<span style=color:#a6e22e>userStore</span>.<span style=color:#a6e22e>GetByID</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>begin</span>)) <span style=color:#75715e>// 统计耗时
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用user数据做一些操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>user</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是，如果方法里调用的类似impl.userStore.GetByID的方法非常之多，逻辑非常之复杂时，这样一个一个的添加，必然非常麻烦、非常累。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>userImpl</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>userStore</span> <span style=color:#a6e22e>IUserStore</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 增加其它store
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>roleStore</span> <span style=color:#a6e22e>IRoleStore</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>impl</span> <span style=color:#a6e22e>userImpl</span>) <span style=color:#a6e22e>CheckUser</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>begin</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>impl</span>.<span style=color:#a6e22e>userStore</span>.<span style=color:#a6e22e>GetByID</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>begin</span>)) <span style=color:#75715e>// 统计耗时
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用user数据做一些操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>user</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取角色具体信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>begin</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>role</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>impl</span>.<span style=color:#a6e22e>roleStore</span>.<span style=color:#a6e22e>GetByID</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>RoleId</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>role</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>begin</span>)) <span style=color:#75715e>// 统计耗时
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 可能会有更多`Store`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>可以看到，当我们新增了<code>roleStore</code>之后，如果要分别统计不同<code>Store</code>的方法调用的耗时，将会非常麻烦。这时有人会说，那为什么不把耗时统计放到<code>Store</code>的方法实现里呢？或者使用一个方法来封装耗时统计：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WrapUsedTime</span>[<span style=color:#a6e22e>R</span> <span style=color:#a6e22e>any</span>](<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>() (<span style=color:#a6e22e>R</span>, <span style=color:#66d9ef>error</span>)) (<span style=color:#a6e22e>R</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>begin</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>begin</span>)) <span style=color:#75715e>// 统计耗时
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样做，当然可以。但是，依然很繁琐，特别是在业务很复杂，调用的方法很多的时候。</p><p>更重要的一点是，我们应该专注于业务逻辑的开发和测试，通用的东西应该交由框架来实现。这也是<code>AOP</code>(面向切面)思想的一个很重要的观点。</p><p><img src=/image/AOP.png alt=AOP></p><p>那么，为什么不用中间件呢？那是因为，中间件的函数签名是固定的，参数类型、参数个数、结果类型和结果个数都是需要事先确定的。但实际中的方法是各种各样的，类型和数量都不尽相同。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 比如，http包的HandlerFunc，它的签名就是这样的，两个参数，参数类型分别如下：ResponseWriter, *Request
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>HandlerFunc</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 而我们面临的是：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>GetById</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>uint64</span>) (<span style=color:#a6e22e>User</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ListByTime</span>(<span style=color:#a6e22e>begin</span>, <span style=color:#a6e22e>end</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>) ([]<span style=color:#a6e22e>User</span>, <span style=color:#66d9ef>error</span>)
</span></span></code></pre></div><p>这时，如果有一个代理能帮我们拦截<code>store</code>的方法调用，在调用前后添加上耗时统计，势必能大大提升我们的工作效率。</p><p>比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 将函数抽象为func(args []interface{}) []interface{}，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 用[]interface{}来装所有的参数和结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Around</span>(<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>args</span> []<span style=color:#66d9ef>interface</span>{}) []<span style=color:#66d9ef>interface</span>{}, <span style=color:#a6e22e>args</span> []<span style=color:#66d9ef>interface</span>{}) []<span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>begin</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>begin</span>)) <span style=color:#75715e>// 统计耗时
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这只是一个简单的包装函数，怎么能将它与上面的接口联系到一起呢？</p><h2 id=接口mockaroundhttpsgithubcomdonnoltoolsblobmasterinjectproxygo><a href=https://github.com/donnol/tools/blob/master/inject/proxy.go>接口，Mock，Around</a>
<a class=anchor href=#%e6%8e%a5%e5%8f%a3mockaroundhttpsgithubcomdonnoltoolsblobmasterinjectproxygo>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>impl</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>proxyImpl</span>) <span style=color:#a6e22e>around</span>(<span style=color:#a6e22e>provider</span> <span style=color:#a6e22e>any</span>, <span style=color:#a6e22e>mock</span> <span style=color:#a6e22e>any</span>, <span style=color:#a6e22e>arounder</span> <span style=color:#a6e22e>Arounder</span>) <span style=color:#a6e22e>any</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mock</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>provider</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mockValue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>mock</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mockType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mockValue</span>.<span style=color:#a6e22e>Type</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mockType</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Ptr</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>mockType</span>.<span style=color:#a6e22e>Elem</span>().<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Struct</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>provider</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// provider有参数，有返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>pv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>provider</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pvt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pv</span>.<span style=color:#a6e22e>Type</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pvt</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Func</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;provider不是函数&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 使用新的类型一样的函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 在注入的时候会被调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>MakeFunc</span>(<span style=color:#a6e22e>pvt</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>args</span> []<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>) []<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pv</span>.<span style=color:#a6e22e>Call</span>(<span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>result</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>firstOut</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>result</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>firstOutType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>firstOut</span>.<span style=color:#a6e22e>Type</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>mockType</span>.<span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>firstOutType</span>) {
</span></span><span style=display:flex><span>			panic(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;mock not Implements interface&#34;</span>))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 根据返回值的类型(mock)生成新的类型，其中新类型的方法均加上钩子
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 注意：生成的不是接口，是实现了接口的类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>firstOutType</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Interface</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>newValue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>mockType</span>.<span style=color:#a6e22e>Elem</span>()).<span style=color:#a6e22e>Elem</span>()
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>newValueType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newValue</span>.<span style=color:#a6e22e>Type</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// field设置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>newValueType</span>.<span style=color:#a6e22e>NumField</span>(); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>field</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newValue</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>fieldType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newValueType</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>name</span> = <span style=color:#a6e22e>fieldType</span>.<span style=color:#a6e22e>Name</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>suffix</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>MockFieldNameSuffixes</span> {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>name</span> = <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>TrimSuffix</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>suffix</span>)
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>method</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>firstOut</span>.<span style=color:#a6e22e>MethodByName</span>(<span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>methodType</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>firstOutType</span>.<span style=color:#a6e22e>MethodByName</span>(<span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>methodTag</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fieldType</span>.<span style=color:#a6e22e>Tag</span>.<span style=color:#a6e22e>Lookup</span>(<span style=color:#e6db74>&#34;method&#34;</span>)
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>						panic(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;找不到名称对应的方法&#34;</span>))
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>debug</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;tag: %+v\n&#34;</span>, <span style=color:#a6e22e>methodTag</span>)
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>name</span> = <span style=color:#a6e22e>methodTag</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>method</span> = <span style=color:#a6e22e>firstOut</span>.<span style=color:#a6e22e>MethodByName</span>(<span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>methodType</span>, <span style=color:#a6e22e>ok</span> = <span style=color:#a6e22e>firstOutType</span>.<span style=color:#a6e22e>MethodByName</span>(<span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>						panic(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;使用tag也找不到名称对应的方法&#34;</span>))
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>debug</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;method: %+v\n&#34;</span>, <span style=color:#a6e22e>method</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>pctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ProxyContext</span>{
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>PkgPath</span>:       <span style=color:#a6e22e>firstOutType</span>.<span style=color:#a6e22e>PkgPath</span>(),
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>InterfaceName</span>: <span style=color:#a6e22e>firstOutType</span>.<span style=color:#a6e22e>Name</span>(),
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>MethodName</span>:    <span style=color:#a6e22e>methodType</span>.<span style=color:#a6e22e>Name</span>,
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>debug</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;pctx: %+v\n&#34;</span>, <span style=color:#a6e22e>pctx</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>// newMethod会在实际请求时被调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#75715e>// 当被调用时，newMethod内部就会调用绑定好的Arounder，然后将原函数method和参数args传入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#75715e>// 在Around方法执行完后即可获得结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>newMethod</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>MakeFunc</span>(<span style=color:#a6e22e>methodType</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>args</span> []<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>) []<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span> {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>result</span> []<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>debug</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;args: %+v\n&#34;</span>, <span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>					<span style=color:#75715e>// Around是对整个结构的统一包装，如果需要对不同方法做不同处理，可以根据pctx里的方法名在Around接口的实现里做处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>					<span style=color:#a6e22e>result</span> = <span style=color:#a6e22e>arounder</span>.<span style=color:#a6e22e>Around</span>(<span style=color:#a6e22e>pctx</span>, <span style=color:#a6e22e>method</span>, <span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>debug</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;result: %+v\n&#34;</span>, <span style=color:#a6e22e>result</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
</span></span><span style=display:flex><span>				})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>field</span>.<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>newMethod</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>result</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#a6e22e>newValue</span>.<span style=color:#a6e22e>Addr</span>().<span style=color:#a6e22e>Convert</span>(<span style=color:#a6e22e>firstOutType</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
</span></span><span style=display:flex><span>	}).<span style=color:#a6e22e>Interface</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，主要的方法是<code>around(provider interface{}, mock interface{}, arounder Arounder) interface{}</code>，
其中<code>provider</code>参数是类似<code>NewXXX() IXXX</code>的函数，而<code>mock</code>是<code>IXXX接口</code>的一个实现，最后的<code>Arounder</code>是
拥有方法<code>Around(pctx ProxyContext, method reflect.Value, args []reflect.Value) []reflect.Value</code>的接口。</p><h2 id=这里的示例httpsgithubcomdonnoltoolsblobmasterinjectproxy_testgo><a href=https://github.com/donnol/tools/blob/master/inject/proxy_test.go>这里的示例</a>
<a class=anchor href=#%e8%bf%99%e9%87%8c%e7%9a%84%e7%a4%ba%e4%be%8bhttpsgithubcomdonnoltoolsblobmasterinjectproxy_testgo>#</a></h2><p>可以看到，mock结构是长这样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UserSrvMock</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CheckUserFunc</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>所以，为了提升开发效率，我还写了一个
<a href=https://github.com/donnol/tools>工具</a>，用来根据接口生成相应的<code>mock</code>结构体。</p><blockquote><p>安装：<code>go install github.com/donnol/tools/cmd/tbc@latest</code>.</p><p>使用：<code>tbc mock -p=github.com/dominikbraun/graph --mode=offsite</code>.</p><p>上述命令会解析<code>graph</code>包，获取包里的公开接口，然后生成对应的<code>Mock</code>结构体，生成的代码保存在当前目录的<code>mock.go</code>文件里。</p></blockquote><h2 id=代码生成替代反射>代码生成替代反射
<a class=anchor href=#%e4%bb%a3%e7%a0%81%e7%94%9f%e6%88%90%e6%9b%bf%e4%bb%a3%e5%8f%8d%e5%b0%84>#</a></h2><p>在上面描述的<code>Around</code>实现里，依赖了<code>reflect</code>包里的<code>reflect.Value.Call</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Call</span>(<span style=color:#a6e22e>in</span> []<span style=color:#a6e22e>Value</span>) []<span style=color:#a6e22e>Value</span>
</span></span></code></pre></div><p>而这个方法的性能是比直接方法调用差的，因此，能不能用代码生成来替代它呢？</p><p>再回过头来看一下，我们通过<code>provider</code>新建一个对象，这个对象带有我们需要使用的方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewIUserSrv</span>(<span style=color:#a6e22e>userStore</span> <span style=color:#a6e22e>IUserStore</span>) <span style=color:#a6e22e>IUserSrv</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>userImpl</span>{
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>userStore</span>: <span style=color:#a6e22e>userStore</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果我们把<code>provider</code>改为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewIUserSrv</span>(<span style=color:#a6e22e>userStore</span> <span style=color:#a6e22e>IUserStore</span>, <span style=color:#a6e22e>withProxy</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>IUserSrv</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>base</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>userImpl</span>{
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>userStore</span>: <span style=color:#a6e22e>userStore</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>withProxy</span> { <span style=color:#75715e>// 控制是否使用proxy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>getIUserSrvProxy</span>(<span style=color:#a6e22e>base</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>base</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIUserSrvProxy</span>(<span style=color:#a6e22e>base</span> <span style=color:#a6e22e>IUserSrv</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>UserSrvMock</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>UserSrvMock</span>{
</span></span><span style=display:flex><span>               <span style=color:#a6e22e>CheckUserFunc</span>: <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r0</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                       <span style=color:#75715e>// 这里不就可以添加逻辑了吗
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                       <span style=color:#a6e22e>r0</span> = <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>CheckUser</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                       <span style=color:#75715e>// 这里不就可以添加逻辑了吗
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r0</span>
</span></span><span style=display:flex><span>               },
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样，不就可以在调用该方法前后添加逻辑了吗？</p><p>如果接口的方法很多，并且添加的逻辑都一样，我们就需要考虑使用代码生成来提高开发效率了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 生成getIUserSrvProxy函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIUserSrvProxy</span>(<span style=color:#a6e22e>base</span> <span style=color:#a6e22e>IUserSrv</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>UserSrvMock</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>UserSrvMock</span>{
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>CheckUserFunc</span>: <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 通用逻辑：耗时统计
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#a6e22e>_gen_begin</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_gen_r0</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>_gen_ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>UserSrvMockCheckUserProxyContext</span> <span style=color:#75715e>// 生成Mock时一并生成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#a6e22e>_gen_cf</span>, <span style=color:#a6e22e>_gen_ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_gen_customCtxMap</span>[<span style=color:#a6e22e>_gen_ctx</span>.<span style=color:#a6e22e>Uniq</span>()] <span style=color:#75715e>// _gen_customCtxMap：全局map，存储用户自定义proxy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_gen_ok</span> {
</span></span><span style=display:flex><span>                                <span style=color:#75715e>// 收集参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#a6e22e>_gen_params</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>any</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                <span style=color:#a6e22e>_gen_params</span> = append(<span style=color:#a6e22e>_gen_params</span>, <span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                <span style=color:#a6e22e>_gen_params</span> = append(<span style=color:#a6e22e>_gen_params</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                <span style=color:#a6e22e>_gen_res</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_gen_cf</span>(<span style=color:#a6e22e>_gen_ctx</span>, <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>CheckUser</span>, <span style=color:#a6e22e>_gen_params</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                <span style=color:#75715e>// 结果断言
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#a6e22e>_gen_tmpr0</span>, <span style=color:#a6e22e>_gen_exist</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_gen_res</span>[<span style=color:#ae81ff>0</span>].(<span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_gen_exist</span> {
</span></span><span style=display:flex><span>                                        <span style=color:#a6e22e>_gen_r0</span> = <span style=color:#a6e22e>_gen_tmpr0</span>
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                                <span style=color:#75715e>// 原始调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#a6e22e>_gen_r0</span> = <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>CheckUser</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[ctx: %s]used time: %v\n&#34;</span>, <span style=color:#a6e22e>_gen_ctx</span>.<span style=color:#a6e22e>Uniq</span>(), <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>_gen_begin</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>_gen_r0</span>
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>userSrvMockCommonProxyContext</span> = <span style=color:#a6e22e>inject</span>.<span style=color:#a6e22e>ProxyContext</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>PkgPath</span>:       <span style=color:#e6db74>&#34;接口所在包路径，如：github.com/donnol/tools/inject&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>InterfaceName</span>: <span style=color:#e6db74>&#34;接口名，如：IUserSrv&#34;</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>UserSrvMockCheckUserProxyContext</span> = <span style=color:#66d9ef>func</span>() (<span style=color:#a6e22e>pctx</span> <span style=color:#a6e22e>inject</span>.<span style=color:#a6e22e>ProxyContext</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>pctx</span> = <span style=color:#a6e22e>userSrvMockCommonProxyContext</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>pctx</span>.<span style=color:#a6e22e>MethodName</span> = <span style=color:#e6db74>&#34;CheckUser&#34;</span> <span style=color:#75715e>// 方法名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_gen_customCtxMap</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>inject</span>.<span style=color:#a6e22e>CtxFunc</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 通过调用这个方法注册自定义proxy函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>RegisterProxyMethod</span>(<span style=color:#a6e22e>pctx</span> <span style=color:#a6e22e>inject</span>.<span style=color:#a6e22e>ProxyContext</span>, <span style=color:#a6e22e>cf</span> <span style=color:#a6e22e>inject</span>.<span style=color:#a6e22e>CtxFunc</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_gen_customCtxMap</span>[<span style=color:#a6e22e>pctx</span>.<span style=color:#a6e22e>Uniq</span>()] = <span style=color:#a6e22e>cf</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>RegisterProxyMethod</span>(<span style=color:#a6e22e>UserSrvMockCheckUserProxyContext</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>ProxyContext</span>, <span style=color:#a6e22e>method</span> <span style=color:#a6e22e>any</span>, <span style=color:#a6e22e>args</span> []<span style=color:#a6e22e>any</span>) (<span style=color:#a6e22e>res</span> []<span style=color:#a6e22e>any</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;custom call&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 从any断言回具体的函数、参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>method</span>.(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>a0</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>args</span>[<span style=color:#ae81ff>0</span>].(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>a1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>args</span>[<span style=color:#ae81ff>1</span>].(<span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>r1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>a0</span>, <span style=color:#a6e22e>a1</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>r1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最后，一个支持任意函数类型的、既能添加通用逻辑，又能添加定制逻辑的<code>proxy</code>就完成了。</p><h2 id=对于任意函数调用通过替换ast节点来添加proxy>对于任意函数调用通过替换ast节点来添加Proxy
<a class=anchor href=#%e5%af%b9%e4%ba%8e%e4%bb%bb%e6%84%8f%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e9%80%9a%e8%bf%87%e6%9b%bf%e6%8d%a2ast%e8%8a%82%e7%82%b9%e6%9d%a5%e6%b7%bb%e5%8a%a0proxy>#</a></h2><p><code>normal.go</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>proxy</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>A</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>any</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>args</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;arg, ctx: %v, id: %v, args: %+v\n&#34;</span>, <span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>C</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>args</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;b&#34;</span>, <span style=color:#e6db74>&#34;c&#34;</span>, <span style=color:#e6db74>&#34;d&#34;</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>A</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>args</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;err: %v\n&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;r1: %v\n&#34;</span>, <span style=color:#a6e22e>r1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上述代码中，<code>C</code>函数调用了<code>A</code>函数，那么，现在我想在这个调用前后添加耗时统计，该怎么办呢？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 添加耗时统计
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>C</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>begin</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>args</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;b&#34;</span>, <span style=color:#e6db74>&#34;c&#34;</span>, <span style=color:#e6db74>&#34;d&#34;</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>A</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>args</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;err: %v\n&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;r1: %v\n&#34;</span>, <span style=color:#a6e22e>r1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;used time: %v\n&#34;</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>begin</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果，我能生成一个<code>AProxy</code>函数，里面包含有耗时统计等逻辑，再把<code>C</code>对<code>A</code>的调用改为对<code>Aproxy</code>的调用，是不是就非常方便了呢！</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># 执行命令，生成代码</span>
</span></span><span style=display:flex><span>tbc genproxy -p ./parser/testtype/proxy/ --func A
</span></span></code></pre></div><p><code>gen_proxy.go</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>proxy</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 生成A的Proxy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>AProxy</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>any</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>args</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>begin</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r0</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r1</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r0</span>, <span style=color:#a6e22e>r1</span> = <span style=color:#a6e22e>A</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>args</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;used time: %v\n&#34;</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>begin</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r0</span>, <span style=color:#a6e22e>r1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>normal.go</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>proxy</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>A</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>any</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>args</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;arg, ctx: %v, id: %v, args: %+v\n&#34;</span>, <span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>C</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>args</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;b&#34;</span>, <span style=color:#e6db74>&#34;c&#34;</span>, <span style=color:#e6db74>&#34;d&#34;</span>}
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 此处对A的调用就被替换为对AProxy的调用了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>AProxy</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>args</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;err: %v\n&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;r1: %v\n&#34;</span>, <span style=color:#a6e22e>r1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不过，这种方式会修改用户编写的源代码，使用时请注意。</p><p><a href=https://github.com/donnol/tools/blob/feat/inject-proxy-caller/cmd/tbc/main.go#L404>代码实现详见</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#go实现aop----层间代理>Go实现AOP &ndash; 层间代理</a></li><li><a href=#接口mockaroundhttpsgithubcomdonnoltoolsblobmasterinjectproxygo><a href=https://github.com/donnol/tools/blob/master/inject/proxy.go>接口，Mock，Around</a></a></li><li><a href=#这里的示例httpsgithubcomdonnoltoolsblobmasterinjectproxy_testgo><a href=https://github.com/donnol/tools/blob/master/inject/proxy_test.go>这里的示例</a></a></li><li><a href=#代码生成替代反射>代码生成替代反射</a></li><li><a href=#对于任意函数调用通过替换ast节点来添加proxy>对于任意函数调用通过替换ast节点来添加Proxy</a></li></ul></li></ul></nav></div></aside></main></body></html>