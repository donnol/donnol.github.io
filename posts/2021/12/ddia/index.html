<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="第一章 可靠性、可扩展性、可维护性 #  数据密集型应用和计算密集型应用
 现今很多应用程序都是 数据密集型（data-intensive） 的，而非 计算密集型（compute-intensive） 的。因此CPU很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。
 数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程序都需要：
 存储数据，以便自己或其他应用程序之后能再次找到 （数据库（database））
记住开销昂贵操作的结果，加快读取速度（缓存（cache））
允许用户按关键字搜索数据，或以各种方式对数据进行过滤（搜索索引（search indexes））
向其他进程发送消息，进行异步处理（流处理（stream processing））
定期处理累积的大批量数据（批处理（batch processing））
 对应可选的组件在我映像中可以有：
数据库：mysql, postgresql
缓存: redis, memcached
搜索索引: elastic search, sonic, redis search
流处理: kafka, redis stream
批处理: linux cron, golang timer
  使用较小的通用组件创建了一个全新的、专用的数据系统。
 如何衡量一个系统的好坏 #  设计数据系统或服务时可能会遇到很多棘手的问题，例如：当系统出问题时，如何确保数据的正确性和完整性？当部分系统退化降级时，如何为客户提供始终如一的良好性能？当负载增加时，如何扩容应对？什么样的 API 才是好的 API？
  可靠性（Reliability）
 系统在困境（adversity）（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。
故障通常定义为系统的一部分状态偏离其标准，而失效则是系统作为一个整体停止向用户提供服务。故障的概率不可能降到零，因此最好设计容错机制以防因故障而导致失效。
硬件错误的解决：为了减少系统的故障率，第一反应通常都是增加单个硬件的冗余度，例如：磁盘可以组建 RAID，服务器可能有双路电源和热插拔 CPU，数据中心可能有电池和柴油发电机作为后备电源，某个组件挂掉时冗余组件可以立刻接管。
软件错误的解决：仔细考虑系统中的假设和交互；彻底的测试；进程隔离；允许进程崩溃并重启；测量、监控并分析生产环境中的系统行为。
人为错误的解决：
   可扩展性（Scalability）">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content="数据密集型应用设计">
<meta property="og:description" content="第一章 可靠性、可扩展性、可维护性 #  数据密集型应用和计算密集型应用
 现今很多应用程序都是 数据密集型（data-intensive） 的，而非 计算密集型（compute-intensive） 的。因此CPU很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。
 数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程序都需要：
 存储数据，以便自己或其他应用程序之后能再次找到 （数据库（database））
记住开销昂贵操作的结果，加快读取速度（缓存（cache））
允许用户按关键字搜索数据，或以各种方式对数据进行过滤（搜索索引（search indexes））
向其他进程发送消息，进行异步处理（流处理（stream processing））
定期处理累积的大批量数据（批处理（batch processing））
 对应可选的组件在我映像中可以有：
数据库：mysql, postgresql
缓存: redis, memcached
搜索索引: elastic search, sonic, redis search
流处理: kafka, redis stream
批处理: linux cron, golang timer
  使用较小的通用组件创建了一个全新的、专用的数据系统。
 如何衡量一个系统的好坏 #  设计数据系统或服务时可能会遇到很多棘手的问题，例如：当系统出问题时，如何确保数据的正确性和完整性？当部分系统退化降级时，如何为客户提供始终如一的良好性能？当负载增加时，如何扩容应对？什么样的 API 才是好的 API？
  可靠性（Reliability）
 系统在困境（adversity）（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。
故障通常定义为系统的一部分状态偏离其标准，而失效则是系统作为一个整体停止向用户提供服务。故障的概率不可能降到零，因此最好设计容错机制以防因故障而导致失效。
硬件错误的解决：为了减少系统的故障率，第一反应通常都是增加单个硬件的冗余度，例如：磁盘可以组建 RAID，服务器可能有双路电源和热插拔 CPU，数据中心可能有电池和柴油发电机作为后备电源，某个组件挂掉时冗余组件可以立刻接管。
软件错误的解决：仔细考虑系统中的假设和交互；彻底的测试；进程隔离；允许进程崩溃并重启；测量、监控并分析生产环境中的系统行为。
人为错误的解决：
   可扩展性（Scalability）">
<meta property="og:type" content="article">
<meta property="og:url" content="https://donnol.github.io/posts/2021/12/ddia/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-12-10T00:00:00+00:00">
<meta property="article:modified_time" content="2021-12-10T00:00:00+00:00">
<title>数据密集型应用设计 | 我的简单博客</title>
<link rel=manifest href=/manifest.json>
<link rel=icon href=/favicon.png type=image/x-icon>
<link rel=stylesheet href=/book.min.09a284f5a03730d86dde350d2c062b1514e48fdfebba7763941c0674ef65748f.css integrity="sha256-CaKE9aA3MNht3jUNLAYrFRTkj9/rundjlBwGdO9ldI8=" crossorigin=anonymous>
<script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.0a9d7dd85070560c4c61176279a7781749a8a8d71934549017d279dc9200588e.js integrity="sha256-Cp192FBwVgxMYRdiead4F0moqNcZNFSQF9J53JIAWI4=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/><span>我的简单博客</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
<ul>
<li>
<input type=checkbox id=section-71121fe02c394c786aa5fdaffc9e5412 class=toggle checked>
<label for=section-71121fe02c394c786aa5fdaffc9e5412 class="flex justify-between">
<a role=button>2021</a>
</label>
<ul>
<li>
<input type=checkbox id=section-393d931b698132759df1a7089df0fcc8 class=toggle checked>
<label for=section-393d931b698132759df1a7089df0fcc8 class="flex justify-between">
<a role=button>12</a>
</label>
<ul>
<li>
<a href=https://donnol.github.io/posts/2021/12/k8s/>k8s</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/12/ddia/ class=active>数据密集型应用设计</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/>burn cpu use golang</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/12/docker_compose_extra_host/>docker compose使用extra host让容器访问主机服务</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/12/dbeaver/>数据库管理工具之dbeaver</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/12/domain/>Domain-oriented development</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/12/github_action_deploy_hugo_blog/>github action deploy hugo blog</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/12/etcd/>Etcd</a>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-3b66512bb507cbdaa9cef9549f229fc1 class=toggle>
<label for=section-3b66512bb507cbdaa9cef9549f229fc1 class="flex justify-between">
<a role=button>01</a>
</label>
<ul>
<li>
<a href=https://donnol.github.io/posts/2021/01/proxy-between-layer/>go实现AOP</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/01/hugo-blog/>hugo搭建博客</a>
</li>
<li>
<a href=https://donnol.github.io/posts/2021/01/pstree/>pstree进程树及说明</a>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-b59662e33ca9ad77b7d385cbee7785fe class=toggle>
<label for=section-b59662e33ca9ad77b7d385cbee7785fe class="flex justify-between">
<a role=button>07</a>
</label>
<ul>
<li>
<a href=https://donnol.github.io/posts/2021/07/linux-epoll/>Linux Epoll</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-6f89cc6c76d5375fc02e3f7e596280b9 class=toggle>
<label for=section-6f89cc6c76d5375fc02e3f7e596280b9 class="flex justify-between">
<a role=button>2020</a>
</label>
<ul>
<li>
<input type=checkbox id=section-03db05476b76e7f4afe06dfa3e1b675b class=toggle>
<label for=section-03db05476b76e7f4afe06dfa3e1b675b class="flex justify-between">
<a role=button>12</a>
</label>
<ul>
<li>
<a href=https://donnol.github.io/posts/2020/12/go-ctx/>go ctx</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href=https://donnol.github.io/posts/aboutme/about-me/>关于我</a>
</li>
</ul>
<ul>
<li>
<a href=https://github.com/donnol/blog target=_blank rel=noopener>
Github
</a>
</li>
<li>
<a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>
Hugo Themes
</a>
</li>
</ul>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>数据密集型应用设计</strong>
<label for=toc-control>
<img src=/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li>
<ul>
<li><a href=#第一章-可靠性可扩展性可维护性>第一章 可靠性、可扩展性、可维护性</a>
<ul>
<li><a href=#如何衡量一个系统的好坏>如何衡量一个系统的好坏</a></li>
</ul>
</li>
<li><a href=#2pc两阶段提交>2PC（两阶段提交）</a></li>
<li><a href=#第十一章-流处理>第十一章 流处理</a>
<ul>
<li><a href=#命令和事件>命令和事件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</aside>
</header>
<article class=markdown>
<h1>
<a href=/posts/2021/12/ddia/>数据密集型应用设计</a>
</h1>
<h5>December 10, 2021</h5>
<h2 id=第一章-可靠性可扩展性可维护性>
第一章 可靠性、可扩展性、可维护性
<a class=anchor href=#%e7%ac%ac%e4%b8%80%e7%ab%a0-%e5%8f%af%e9%9d%a0%e6%80%a7%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7>#</a>
</h2>
<p>数据密集型应用和计算密集型应用</p>
<blockquote>
<p>现今很多应用程序都是 <strong>数据密集型（data-intensive）</strong> 的，而非 <strong>计算密集型（compute-intensive）</strong> 的。因此<strong>CPU</strong>很少成为这类应用的瓶颈，更大的问题通常来自<strong>数据量、数据复杂性、以及数据的变更速度</strong>。</p>
</blockquote>
<p>数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程序都需要：</p>
<blockquote>
<p>存储数据，以便自己或其他应用程序之后能再次找到 （<strong>数据库（database）</strong>）</p>
<p>记住开销昂贵操作的结果，加快读取速度（<strong>缓存（cache）</strong>）</p>
<p>允许用户按关键字搜索数据，或以各种方式对数据进行过滤（<strong>搜索索引（search indexes）</strong>）</p>
<p>向其他进程发送消息，进行异步处理（<strong>流处理（stream processing）</strong>）</p>
<p>定期处理累积的大批量数据（<strong>批处理（batch processing）</strong>）</p>
<blockquote>
<p>对应可选的组件在我映像中可以有：</p>
<p>数据库：mysql, postgresql</p>
<p>缓存: redis, memcached</p>
<p>搜索索引: elastic search, sonic, redis search</p>
<p>流处理: kafka, redis stream</p>
<p>批处理: linux cron, golang timer</p>
</blockquote>
</blockquote>
<p>使用较小的通用组件创建了一个全新的、专用的数据系统。</p>
<p>
<img src=/image/%e6%95%b0%e6%8d%ae%e5%af%86%e9%9b%86%e5%9e%8b%e5%ba%94%e7%94%a8%e4%b8%80%e8%88%ac%e6%b6%89%e5%8f%8a%e7%9a%84%e7%bb%84%e4%bb%b6.png alt=组件图></p>
<h3 id=如何衡量一个系统的好坏>
如何衡量一个系统的好坏
<a class=anchor href=#%e5%a6%82%e4%bd%95%e8%a1%a1%e9%87%8f%e4%b8%80%e4%b8%aa%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%a5%bd%e5%9d%8f>#</a>
</h3>
<p>设计数据系统或服务时可能会遇到很多棘手的问题，例如：当系统出问题时，如何确保数据的正确性和完整性？当部分系统退化降级时，如何为客户提供始终如一的良好性能？当负载增加时，如何扩容应对？什么样的 API 才是好的 API？</p>
<ol>
<li>
<p>可靠性（Reliability）</p>
<blockquote>
<p>系统<strong>在困境（adversity）（硬件故障、软件故障、人为错误）中仍可正常工作</strong>（正确完成功能，并能达到期望的性能水准）。</p>
<p><strong>故障</strong>通常定义为系统的一部分状态偏离其标准，而<strong>失效</strong>则是系统作为一个整体停止向用户提供服务。故障的概率不可能降到零，因此最好设计容错机制<strong>以防因故障而导致失效</strong>。</p>
<p>硬件错误的解决：为了减少系统的故障率，第一反应通常都是增加单个硬件的冗余度，例如：磁盘可以组建 RAID，服务器可能有双路电源和热插拔 CPU，数据中心可能有电池和柴油发电机作为后备电源，某个组件挂掉时冗余组件可以立刻接管。</p>
<p>软件错误的解决：仔细考虑系统中的假设和交互；彻底的测试；进程隔离；允许进程崩溃并重启；测量、监控并分析生产环境中的系统行为。</p>
<p>人为错误的解决：</p>
</blockquote>
</li>
<li>
<p>可扩展性（Scalability）</p>
<blockquote>
<p><strong>有合理的办法应对系统的增长</strong>（数据量、流量、复杂性）</p>
</blockquote>
</li>
<li>
<p>可维护性（Maintainability）</p>
<blockquote>
<p><strong>许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作</strong>（使系统保持现有行为，并适应新的应用场景）。</p>
</blockquote>
</li>
</ol>
<p>从人的角度看：可靠就是能共困苦，同富贵；可扩展就是学习能力强，心胸广阔；可维护就是对人对己无偏见、无特例。</p>
<h2 id=2pc两阶段提交>
2PC（两阶段提交）
<a class=anchor href=#2pc%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4>#</a>
</h2>
<p>2PC，two-phase commit，两阶段提交。</p>
<blockquote>
<p>一种用于实现跨多个节点的原子事务提交的算法，即确保所有节点提交或所有节点中止。</p>
</blockquote>
<p>
<img src=/image/2PC.png alt=2PC></p>
<blockquote>
<p>2PC 使用一个通常不会出现在单节点事务中的新组件：协调者（coordinator）（也称为事务管理器（transaction manager））。</p>
<p>正常情况下，2PC 事务以应用在多个数据库节点上读写数据开始。我们称这些数据库节点为参与者（participants）。</p>
<blockquote>
<p>当应用准备提交时，协调者开始阶段 1 ：它发送一个准备（prepare）请求到每个节点，询问它们是否能够提交。然后协调者会跟踪参与者的响应：</p>
<p>如果所有参与者都回答“是”，表示它们已经准备好提交，那么协调者在阶段 2 发出提交（commit）请求，然后提交真正发生。</p>
<p>如果任意一个参与者回复了“否”，则协调者在阶段 2 中向所有节点发送中止（abort）请求。</p>
</blockquote>
</blockquote>
<p>那如果在阶段 2 有事务提交失败了呢？</p>
<blockquote>
<p>在两阶段提交的情况下，准备(prepare 阶段)请求和提交(commit 阶段)请求当然也可以轻易丢失。 2PC 又有什么不同呢？</p>
</blockquote>
<p>
<img src=/image/2PC%e5%ae%8c%e6%95%b4%e6%b5%81%e7%a8%8b.png alt=2PC></p>
<h2 id=第十一章-流处理>
第十一章 流处理
<a class=anchor href=#%e7%ac%ac%e5%8d%81%e4%b8%80%e7%ab%a0-%e6%b5%81%e5%a4%84%e7%90%86>#</a>
</h2>
<blockquote>
<p>先回忆了批处理的特点：即输入是有界的，即已知和有限的大小，所以批处理知道它何时完成输入的读取。</p>
<p>实际上，很多数据是无界限的，因为它随着时间的推移而逐渐到达：你的用户在昨天和今天产生了数据，明天他们将继续产生更多的数据。除非你停业，否则这个过程永远都不会结束，所以数据集从来就不会以任何有意义的方式“完成”。</p>
<p>因此，批处理程序必须<strong>将数据人为地分成固定时间段的数据块</strong>，例如，在每天结束时处理一天的数据，或者在每小时结束时处理一小时的数据。</p>
<p>日常批处理中的问题是，输入的变更只会在一天之后的输出中反映出来，这对于许多急躁的用户来说太慢了。为了减少延迟，我们可以更频繁地运行处理 —— 比如说，在每秒钟的末尾 —— 或者甚至更连续一些，完全抛开固定的时间切片，<strong>当事件发生时就立即进行处理，这就是流处理（stream processing）背后的想法</strong>。</p>
</blockquote>
<p>在本章中，我们将<strong>把事件流（event stream）视为一种数据管理机制：无界限，增量处理</strong>，与上一章中批量数据相对应。</p>
<blockquote>
<p>原则上讲，文件或数据库就足以连接生产者和消费者：生产者将其生成的每个事件写入数据存储，且每个消费者定期轮询数据存储，检查自上次运行以来新出现的事件。这实际上正是批处理在每天结束时处理当天数据时所做的事情。</p>
<p><strong>但当我们想要进行低延迟的连续处理时，如果数据存储不是为这种用途专门设计的，那么轮询开销就会很大。轮询的越频繁，能返回新事件的请求比例就越低，而额外开销也就越高</strong>。相比之下，最好能在新事件出现时直接通知消费者。</p>
<p>数据库在传统上对这种通知机制支持的并不好，关系型数据库通常有 触发器（trigger） ，它们可以对变化作出反应（如，插入表中的一行），但是它们的功能非常有限，并且在数据库设计中有些后顾之忧。相应的是，已经开发了专门的工具来提供事件通知。</p>
</blockquote>
<p>两个问题：</p>
<ol>
<li>
<p>如果生产者发送消息的速度比消费者能够处理的速度快会发生什么？</p>
</li>
<li>
<p>如果节点崩溃或暂时脱机，会发生什么情况？ —— 是否会有消息丢失？</p>
</li>
</ol>
<h3 id=命令和事件>
命令和事件
<a class=anchor href=#%e5%91%bd%e4%bb%a4%e5%92%8c%e4%ba%8b%e4%bb%b6>#</a>
</h3>
<blockquote>
<p>事件溯源的哲学是仔细区分事件（event）和命令（command）。</p>
<p>当来自用户的请求刚到达时，它一开始是一个命令：在这个时间点上它仍然可能可能失败，比如，因为违反了一些完整性条件。应用必须首先验证它是否可以执行该命令。</p>
<p><strong>如果验证成功并且命令被接受，则它变为一个持久化且不可变的事件</strong>。</p>
<p>在事件生成的时刻，它就成为了事实（fact）。即使客户稍后决定更改或取消预订，他们之前曾预定了某个特定座位的事实仍然成立，而更改或取消是之后添加的单独的事件。</p>
</blockquote>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//donno272.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li>
<ul>
<li><a href=#第一章-可靠性可扩展性可维护性>第一章 可靠性、可扩展性、可维护性</a>
<ul>
<li><a href=#如何衡量一个系统的好坏>如何衡量一个系统的好坏</a></li>
</ul>
</li>
<li><a href=#2pc两阶段提交>2PC（两阶段提交）</a></li>
<li><a href=#第十一章-流处理>第十一章 流处理</a>
<ul>
<li><a href=#命令和事件>命令和事件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>