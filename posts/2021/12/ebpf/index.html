<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="ebpf: 扩展伯克利包过滤器。
下面的内容主要来源于 译文。
用处 #   目前，主要有两大组触发器。
第一组用于处理网络数据包和管理网络流量。它们是 XDP、流量控制事件及其他几个事件。
以下情况需要用到这些事件：
 创建简单但非常有效的防火墙。Cloudflare 和 Facebook 等公司使用 BPF 程序来过滤掉大量的寄生流量，并打击最大规模的 DDoS 攻击。由于处理发生在数据包生命的最早阶段，直接在内核中进行（BPF 程序的处理有时甚至可以直接推送到网卡中进行），因此可以通过这种方式处理巨量的流量。这些事情过去都是在专门的网络硬件上完成的。
创建更智能、更有针对性、但性能更好的防火墙——这些防火墙可以检查通过的流量是否符合公司的规则、是否存在漏洞模式等。例如，Facebook 在内部进行这种审计，而一些项目则对外销售这类产品。
创建智能负载均衡器。最突出的例子就是 Cilium 项目，它最常被用作 K8s 集群中的网格网络。Cilium 对流量进行管理、均衡、重定向和分析。所有这些都是在内核运行的小型 BPF 程序的帮助下完成的，以响应这个或那个与网络数据包或套接字相关的事件。
 这是第一组与网络问题相关并能够影响网络通信行为的触发器。第二组则与更普遍的可观察性相关；在大多数情况下，这组的程序无法影响任何事件，而只能“观察”。这才是我更感兴趣的。
这组的触发器有如下几个：
 perf 事件（perf events）——与性能和 perf Linux 分析器相关的事件：硬件处理器计数器、中断处理、小 / 大内存异常拦截等等。例如，我们可以设置一个处理程序，每当内核需要从 swap 读取内存页时，该处理程序就会运行。例如，想象有这样一个实用程序，它显示了当前所有使用 swap 的程序。
跟踪点（tracepoints）——内核源代码中的静态（由开发人员定义）位置，通过附加到这些位置，你可以从中提取静态信息（开发人员先前准备的信息）。在这种情况下，静态似乎是一件坏事，因为我说过，日志的缺点之一就是它们只包含了程序员最初放在那里的内容。从某种意义上说，这是正确的，但跟踪点有三个重要的优势：
 有相当多的跟踪点散落在内核中最有趣的地方
当它们不“开启”时，它们不使用任何资源
它们是 API 的一部分，它们是稳定的，不会改变。这非常重要，因为我们将提到的其他触发器缺少稳定的 API。
例如，假设有一个关于显示的实用程序，内核出于某种原因没有给它时间执行。你坐着纳闷为什么它这么慢，而 pprof 却没有显示任何什么有趣的东西。
 USDT——与跟踪点相同，但是它适用于用户空间的程序。也就是说，作为程序员，你可以将这些位置添加到你的程序中。并且许多大型且知名的程序和编程语言都已经采用了这些跟踪方法：例如 MySQL、或者 PHP 和 Python 语言。通常，它们的默认设置为“关闭”，如果要打开它们，需要使用 enable-dtrace 参数或类似的参数来重新构建解释器。是的，我们还可以在 Go 中注册这种类跟踪。你可能已经识别出参数名称中的单词 DTrace。关键在于，这些类型的静态跟踪是由 Solaris) 操作系统中诞生的同名系统所推广的。例如，想象一下，何时创建新线程、何时启动 GC 或与特定语言或系统相关的其他内容，我们都能够知道是怎样的一种场景。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="ebpf"><meta property="og:description" content="ebpf: 扩展伯克利包过滤器。
下面的内容主要来源于 译文。
用处 #   目前，主要有两大组触发器。
第一组用于处理网络数据包和管理网络流量。它们是 XDP、流量控制事件及其他几个事件。
以下情况需要用到这些事件：
 创建简单但非常有效的防火墙。Cloudflare 和 Facebook 等公司使用 BPF 程序来过滤掉大量的寄生流量，并打击最大规模的 DDoS 攻击。由于处理发生在数据包生命的最早阶段，直接在内核中进行（BPF 程序的处理有时甚至可以直接推送到网卡中进行），因此可以通过这种方式处理巨量的流量。这些事情过去都是在专门的网络硬件上完成的。
创建更智能、更有针对性、但性能更好的防火墙——这些防火墙可以检查通过的流量是否符合公司的规则、是否存在漏洞模式等。例如，Facebook 在内部进行这种审计，而一些项目则对外销售这类产品。
创建智能负载均衡器。最突出的例子就是 Cilium 项目，它最常被用作 K8s 集群中的网格网络。Cilium 对流量进行管理、均衡、重定向和分析。所有这些都是在内核运行的小型 BPF 程序的帮助下完成的，以响应这个或那个与网络数据包或套接字相关的事件。
 这是第一组与网络问题相关并能够影响网络通信行为的触发器。第二组则与更普遍的可观察性相关；在大多数情况下，这组的程序无法影响任何事件，而只能“观察”。这才是我更感兴趣的。
这组的触发器有如下几个：
 perf 事件（perf events）——与性能和 perf Linux 分析器相关的事件：硬件处理器计数器、中断处理、小 / 大内存异常拦截等等。例如，我们可以设置一个处理程序，每当内核需要从 swap 读取内存页时，该处理程序就会运行。例如，想象有这样一个实用程序，它显示了当前所有使用 swap 的程序。
跟踪点（tracepoints）——内核源代码中的静态（由开发人员定义）位置，通过附加到这些位置，你可以从中提取静态信息（开发人员先前准备的信息）。在这种情况下，静态似乎是一件坏事，因为我说过，日志的缺点之一就是它们只包含了程序员最初放在那里的内容。从某种意义上说，这是正确的，但跟踪点有三个重要的优势：
 有相当多的跟踪点散落在内核中最有趣的地方
当它们不“开启”时，它们不使用任何资源
它们是 API 的一部分，它们是稳定的，不会改变。这非常重要，因为我们将提到的其他触发器缺少稳定的 API。
例如，假设有一个关于显示的实用程序，内核出于某种原因没有给它时间执行。你坐着纳闷为什么它这么慢，而 pprof 却没有显示任何什么有趣的东西。
 USDT——与跟踪点相同，但是它适用于用户空间的程序。也就是说，作为程序员，你可以将这些位置添加到你的程序中。并且许多大型且知名的程序和编程语言都已经采用了这些跟踪方法：例如 MySQL、或者 PHP 和 Python 语言。通常，它们的默认设置为“关闭”，如果要打开它们，需要使用 enable-dtrace 参数或类似的参数来重新构建解释器。是的，我们还可以在 Go 中注册这种类跟踪。你可能已经识别出参数名称中的单词 DTrace。关键在于，这些类型的静态跟踪是由 Solaris) 操作系统中诞生的同名系统所推广的。例如，想象一下，何时创建新线程、何时启动 GC 或与特定语言或系统相关的其他内容，我们都能够知道是怎样的一种场景。"><meta property="og:type" content="article"><meta property="og:url" content="https://donnol.github.io/posts/2021/12/ebpf/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-24T00:00:00+00:00"><meta property="article:modified_time" content="2021-12-24T00:00:00+00:00"><title>ebpf | 我的简单博客</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.09a284f5a03730d86dde350d2c062b1514e48fdfebba7763941c0674ef65748f.css integrity="sha256-CaKE9aA3MNht3jUNLAYrFRTkj9/rundjlBwGdO9ldI8=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.bd4234df601a25034a70df494c95f73d96560c28ebfd0c8b8c02730c25fdfed7.js integrity="sha256-vUI032AaJQNKcN9JTJX3PZZWDCjr/QyLjAJzDCX9/tc=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PNRWGCH4KN"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PNRWGCH4KN",{anonymize_ip:!1})}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>我的简单博客</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-c8e9ae7896ddc3e931652e7edbcbefe2 class=toggle>
<label for=section-c8e9ae7896ddc3e931652e7edbcbefe2 class="flex justify-between"><a role=button>2022</a></label><ul><li><input type=checkbox id=section-d9a952ec7a0fcb7a9ba717dc9bfce17b class=toggle>
<label for=section-d9a952ec7a0fcb7a9ba717dc9bfce17b class="flex justify-between"><a role=button>05</a></label><ul><li><a href=https://donnol.github.io/posts/2022/05/generic/>泛型</a></li><li><a href=https://donnol.github.io/posts/2022/05/find_go_version_the_app_use/>Find out which Go version built your binary</a></li><li><a href=https://donnol.github.io/posts/2022/05/k8s_how_to_keep_pods/>k8s是怎么维持pod的运行的呢？</a></li><li><a href=https://donnol.github.io/posts/2022/05/go_enum/>Go enum</a></li></ul></li><li><input type=checkbox id=section-98bace91040a47ec7d7a95076963fc62 class=toggle>
<label for=section-98bace91040a47ec7d7a95076963fc62 class="flex justify-between"><a role=button>04</a></label><ul><li><a href=https://donnol.github.io/posts/2022/04/go1.18_comparable/>Go1.18 comparable</a></li></ul></li><li><input type=checkbox id=section-821dedbe2a29b27962c9696b13382042 class=toggle>
<label for=section-821dedbe2a29b27962c9696b13382042 class="flex justify-between"><a role=button>03</a></label><ul><li><a href=https://donnol.github.io/posts/2022/03/kmp/>KMP</a></li></ul></li><li><input type=checkbox id=section-935ca4c1d23ab780a0809b4bc7c413bf class=toggle>
<label for=section-935ca4c1d23ab780a0809b4bc7c413bf class="flex justify-between"><a role=button>02</a></label><ul><li><a href=https://donnol.github.io/posts/2022/02/%E9%9C%9C%E4%B9%8B%E5%93%80%E4%BC%A4/>霜之哀伤</a></li><li><a href=https://donnol.github.io/posts/2022/02/goroutine_vs_tokio/>goroutine vs tokio</a></li><li><a href=https://donnol.github.io/posts/2022/02/go_runtime_chan/>go runtime chan</a></li><li><a href=https://donnol.github.io/posts/2022/02/go_work/>go work</a></li><li><a href=https://donnol.github.io/posts/2022/02/distractions/>杂念</a></li></ul></li><li><input type=checkbox id=section-a7c5705090b10b47e082065e722e7e5c class=toggle>
<label for=section-a7c5705090b10b47e082065e722e7e5c class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2022/01/rust_safe/>Rust与安全</a></li><li><a href=https://donnol.github.io/posts/2022/01/wasmtime/>wasm运行时wasmtime</a></li><li><a href=https://donnol.github.io/posts/2022/01/container_encrypt/>容器镜像加密</a></li><li><a href=https://donnol.github.io/posts/2022/01/smart_contract/>智能合约</a></li><li><a href=https://donnol.github.io/posts/2022/01/learn_go_fast/>Go快速入门</a></li><li><a href=https://donnol.github.io/posts/2022/01/consensus/>consensus</a></li><li><a href=https://donnol.github.io/posts/2022/01/red_black_tree/>红黑树</a></li><li><a href=https://donnol.github.io/posts/2022/01/rust_commonly_used_crate/>Rust常用库</a></li><li><a href=https://donnol.github.io/posts/2022/01/cache/>缓存和数据库如何保持一致</a></li></ul></li></ul></li><li><input type=checkbox id=section-71121fe02c394c786aa5fdaffc9e5412 class=toggle checked>
<label for=section-71121fe02c394c786aa5fdaffc9e5412 class="flex justify-between"><a role=button>2021</a></label><ul><li><input type=checkbox id=section-393d931b698132759df1a7089df0fcc8 class=toggle checked>
<label for=section-393d931b698132759df1a7089df0fcc8 class="flex justify-between"><a role=button>12</a></label><ul><li><a href=https://donnol.github.io/posts/2021/12/ebpf/ class=active>ebpf</a></li><li><a href=https://donnol.github.io/posts/2021/12/time_wenzi/>时间和文字</a></li><li><a href=https://donnol.github.io/posts/2021/12/etcd/>etcd</a></li><li><a href=https://donnol.github.io/posts/2021/12/vscode-go-module/>vscode-go在go.mod在非根目录情况下失效的问题</a></li><li><a href=https://donnol.github.io/posts/2021/12/mqtt/>mqtt</a></li><li><a href=https://donnol.github.io/posts/2021/12/redis_sds/>redis sds</a></li><li><a href=https://donnol.github.io/posts/2021/12/k8s/>k8s</a></li><li><a href=https://donnol.github.io/posts/2021/12/ddia/>数据密集型应用设计</a></li><li><a href=https://donnol.github.io/posts/2021/12/burn_cpu_use_golang/>burn cpu use golang</a></li><li><a href=https://donnol.github.io/posts/2021/12/docker_compose_extra_host/>docker compose使用extra host让容器访问主机服务</a></li><li><a href=https://donnol.github.io/posts/2021/12/dbeaver/>数据库管理工具之dbeaver</a></li><li><a href=https://donnol.github.io/posts/2021/12/domain/>Domain-oriented development</a></li><li><a href=https://donnol.github.io/posts/2021/12/github_action_deploy_hugo_blog/>github action deploy hugo blog</a></li></ul></li><li><input type=checkbox id=section-b59662e33ca9ad77b7d385cbee7785fe class=toggle>
<label for=section-b59662e33ca9ad77b7d385cbee7785fe class="flex justify-between"><a role=button>07</a></label><ul><li><a href=https://donnol.github.io/posts/2021/07/linux-epoll/>linux epoll</a></li></ul></li><li><input type=checkbox id=section-3b66512bb507cbdaa9cef9549f229fc1 class=toggle>
<label for=section-3b66512bb507cbdaa9cef9549f229fc1 class="flex justify-between"><a role=button>01</a></label><ul><li><a href=https://donnol.github.io/posts/2021/01/proxy-between-layer/>Go实现AOP</a></li><li><a href=https://donnol.github.io/posts/2021/01/hugo-blog/>hugo搭建博客</a></li><li><a href=https://donnol.github.io/posts/2021/01/pstree/>pstree进程树及说明</a></li></ul></li></ul></li><li><input type=checkbox id=section-6f89cc6c76d5375fc02e3f7e596280b9 class=toggle>
<label for=section-6f89cc6c76d5375fc02e3f7e596280b9 class="flex justify-between"><a role=button>2020</a></label><ul><li><input type=checkbox id=section-03db05476b76e7f4afe06dfa3e1b675b class=toggle>
<label for=section-03db05476b76e7f4afe06dfa3e1b675b class="flex justify-between"><a role=button>12</a></label><ul><li><a href=https://donnol.github.io/posts/2020/12/go-ctx/>go ctx</a></li></ul></li></ul></li><li><a href=https://donnol.github.io/posts/aboutme/about-me/>关于我</a></li></ul><ul><li><a href=https://github.com/donnol/blog target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>ebpf</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#用处>用处</a></li><li><a href=#使用>使用</a><ul><li><a href=#go>Go</a></li><li><a href=#ciliumebpf>cilium/ebpf</a></li></ul></li><li><a href=#效果>效果</a></li><li><a href=#更多>更多</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1><a href=/posts/2021/12/ebpf/>ebpf</a></h1><h5>December 24, 2021</h5><div><a href=/categories/linux/>linux</a></div><div><a href=/tags/ebpf/>ebpf</a></div><p><a href=https://ebpf.io/>ebpf</a>: 扩展伯克利包过滤器。</p><p>下面的内容主要来源于
<a href=https://mp.weixin.qq.com/s/xxBQuj-iD103kWeicanUFA>译文</a>。</p><h2 id=用处>用处
<a class=anchor href=#%e7%94%a8%e5%a4%84>#</a></h2><blockquote><p>目前，主要有两大组触发器。</p><p>第一组用于处理网络数据包和管理网络流量。它们是 XDP、流量控制事件及其他几个事件。</p><p>以下情况需要用到这些事件：</p><blockquote><p>创建简单但非常有效的防火墙。Cloudflare 和 Facebook 等公司使用 BPF 程序来过滤掉大量的寄生流量，并打击最大规模的 DDoS 攻击。由于处理发生在数据包生命的最早阶段，直接在内核中进行（BPF 程序的处理有时甚至可以直接推送到网卡中进行），因此可以通过这种方式处理巨量的流量。这些事情过去都是在专门的网络硬件上完成的。</p><p>创建更智能、更有针对性、但性能更好的防火墙——这些防火墙可以检查通过的流量是否符合公司的规则、是否存在漏洞模式等。例如，Facebook 在内部进行这种审计，而一些项目则对外销售这类产品。</p><p>创建智能负载均衡器。最突出的例子就是 Cilium 项目，它最常被用作 K8s 集群中的网格网络。Cilium 对流量进行管理、均衡、重定向和分析。所有这些都是在内核运行的小型 BPF 程序的帮助下完成的，以响应这个或那个与网络数据包或套接字相关的事件。</p></blockquote><p>这是第一组与网络问题相关并能够影响网络通信行为的触发器。第二组则与更普遍的可观察性相关；在大多数情况下，这组的程序无法影响任何事件，而只能“观察”。这才是我更感兴趣的。</p><p>这组的触发器有如下几个：</p><blockquote><p>perf 事件（perf events）——与性能和 perf Linux 分析器相关的事件：硬件处理器计数器、中断处理、小 / 大内存异常拦截等等。例如，我们可以设置一个处理程序，每当内核需要从 swap 读取内存页时，该处理程序就会运行。例如，想象有这样一个实用程序，它显示了当前所有使用 swap 的程序。</p><p>跟踪点（tracepoints）——内核源代码中的静态（由开发人员定义）位置，通过附加到这些位置，你可以从中提取静态信息（开发人员先前准备的信息）。在这种情况下，静态似乎是一件坏事，因为我说过，日志的缺点之一就是它们只包含了程序员最初放在那里的内容。从某种意义上说，这是正确的，但跟踪点有三个重要的优势：</p></blockquote><p>有相当多的跟踪点散落在内核中最有趣的地方</p><p>当它们不“开启”时，它们不使用任何资源</p><p>它们是 API 的一部分，它们是稳定的，不会改变。这非常重要，因为我们将提到的其他触发器缺少稳定的 API。</p><p>例如，假设有一个关于显示的实用程序，内核出于某种原因没有给它时间执行。你坐着纳闷为什么它这么慢，而 pprof 却没有显示任何什么有趣的东西。</p><blockquote><p>USDT——与跟踪点相同，但是它适用于用户空间的程序。也就是说，作为程序员，你可以将这些位置添加到你的程序中。并且许多大型且知名的程序和编程语言都已经采用了这些跟踪方法：例如 MySQL、或者 PHP 和 Python 语言。通常，它们的默认设置为“关闭”，如果要打开它们，需要使用 enable-dtrace 参数或类似的参数来重新构建解释器。是的，我们还可以在 Go 中注册这种类跟踪。你可能已经识别出参数名称中的单词 DTrace。关键在于，这些类型的静态跟踪是由 Solaris) 操作系统中诞生的同名系统所推广的。例如，想象一下，何时创建新线程、何时启动 GC 或与特定语言或系统相关的其他内容，我们都能够知道是怎样的一种场景。</p></blockquote><p>这是另一种魔法开始的地方：</p><blockquote><p>Ftrace 触发器为我们提供了在内核的任何函数开始时运行 BPF 程序的选项。这是完全动态的。这意味着内核将在你选择的任何内核函数或者在所有内核函数开始执行之前，开始执行之前调用你的 BPF 函数。你可以连接到所有内核函数，并在输出时获取所有调用的有吸引力的可视化效果。</p><p>kprobes/uprobes 提供的功能与 ftrace 几乎相同，但在内核和用户空间中执行函数时，你可以选择将其附加到任何位置上。如果在函数的中间，变量上有一个“if”，并且能为这个变量建立一个值的直方图，那就不是问题。</p><p>kretprobes/uretprobes——这里的一切都类似于前面的触发器，但是它们可以在内核函数或用户空间中的函数返回时触发。这类触发器便于查看函数的返回内容以及测量执行所需的时间。例如，你可以找出“fork”系统调用返回的 PID。</p></blockquote><p>我再重复一遍，所有这些最奇妙之处在于，当我们的 BPF 程序为了响应这些触发器而被调用之后，我们可以很好地“环顾四周”：<strong>读取函数的参数，记录时间，读取变量，读取全局变量，进行堆栈跟踪，保存一些内容以备后用，将数据发送到用户空间进行处理，和 / 或从用户空间获取数据或一些其他控制命令以进行过滤</strong>。简直不可思议！</p></blockquote><h2 id=使用>使用
<a class=anchor href=#%e4%bd%bf%e7%94%a8>#</a></h2><p>先用<code>man bpf</code>看下它是怎么被定义的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>NAME
</span></span><span style=display:flex><span>    bpf <span style=color:#f92672>-</span> perform a command on an extended BPF map or program
</span></span><span style=display:flex><span>	<span style=color:#f92672>--</span> <span style=color:#960050;background-color:#1e0010>在</span>bpf map或程序里执行一个命令
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SYNOPSIS
</span></span><span style=display:flex><span>    <span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/bpf.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> bpf(<span style=color:#66d9ef>int</span> cmd, <span style=color:#66d9ef>union</span> bpf_attr <span style=color:#f92672>*</span>attr, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> size);
</span></span><span style=display:flex><span>	<span style=color:#f92672>--</span> bpf_attr里有些什么呢<span style=color:#960050;background-color:#1e0010>？</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DESCRIPTION
</span></span><span style=display:flex><span>    The  bpf() system call performs a range of operations related to extended Berkeley Packet
</span></span><span style=display:flex><span>    Filters.  Extended BPF (or eBPF) is similar to the original (<span style=color:#e6db74>&#34;classic&#34;</span>) BPF  (cBPF)  used
</span></span><span style=display:flex><span>    to  filter  network packets.  For both cBPF and eBPF programs, the kernel statically ana<span style=color:#960050;background-color:#1e0010>‐</span>
</span></span><span style=display:flex><span>    lyzes the programs before loading them, in order to ensure that they cannot harm the run<span style=color:#960050;background-color:#1e0010>‐</span>
</span></span><span style=display:flex><span>    ning system.
</span></span><span style=display:flex><span>	<span style=color:#f92672>--</span> <span style=color:#960050;background-color:#1e0010>在程序被加载之前分析它，确保它们不会伤害到运行中的系统。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    eBPF  extends cBPF in multiple ways, including the ability to call a fixed set of in<span style=color:#f92672>-</span>ker<span style=color:#960050;background-color:#1e0010>‐</span>
</span></span><span style=display:flex><span>    nel helper functions (via the BPF_CALL opcode extension  provided  by  eBPF)  and  access
</span></span><span style=display:flex><span>    shared data structures such as eBPF maps.
</span></span><span style=display:flex><span>	<span style=color:#f92672>--</span> ebpf在很多方面扩展了cbpf<span style=color:#960050;background-color:#1e0010>，包括可以调用固定的钩子函数的能力，可以访问共享的数据结构（如：</span>ebpf maps<span style=color:#960050;background-color:#1e0010>）。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Extended BPF Design<span style=color:#f92672>/</span>Architecture
</span></span><span style=display:flex><span>	eBPF  maps  are a generic data structure <span style=color:#66d9ef>for</span> storage of different data types.  Data types
</span></span><span style=display:flex><span>	are generally treated as binary blobs, so a user just specifies the size of the  key  and
</span></span><span style=display:flex><span>	the  size of the value at map<span style=color:#f92672>-</span>creation time.  In other words, a key<span style=color:#f92672>/</span>value <span style=color:#66d9ef>for</span> a given map
</span></span><span style=display:flex><span>	can have an arbitrary structure.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	A user process can create multiple maps (with key<span style=color:#f92672>/</span>value<span style=color:#f92672>-</span>pairs being opaque bytes of data)
</span></span><span style=display:flex><span>	and  access  them via file descriptors.  Different eBPF programs can access the same maps
</span></span><span style=display:flex><span>	in parallel.  It<span style=color:#960050;background-color:#1e0010>&#39;</span>s up to the user process and eBPF program to decide what they store  in<span style=color:#960050;background-color:#1e0010>‐</span>
</span></span><span style=display:flex><span>	side maps.
</span></span><span style=display:flex><span>	<span style=color:#f92672>--</span> <span style=color:#960050;background-color:#1e0010>一个用户进程可以创建多个</span>maps<span style=color:#960050;background-color:#1e0010>，然后通过文件描述符访问它们。不同的</span>ebpf程序可以并行访问同一个maps<span style=color:#960050;background-color:#1e0010>。由用户进程和</span>ebpf程序决定存储内容<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	There<span style=color:#960050;background-color:#1e0010>&#39;</span>s  one  special map type, called a program array.  This type of map stores file de<span style=color:#960050;background-color:#1e0010>‐</span>
</span></span><span style=display:flex><span>	scriptors referring to other eBPF programs.  When a lookup in the map is  performed,  the
</span></span><span style=display:flex><span>	program flow is redirected in<span style=color:#f92672>-</span>place to the beginning of another eBPF program and does not
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> back to the calling program.  The level of nesting has a fixed  limit  of  <span style=color:#ae81ff>32</span>,  so
</span></span><span style=display:flex><span>	that  infinite loops cannot be crafted.  At run time, the program file descriptors stored
</span></span><span style=display:flex><span>	in the map can be modified, so program functionality can be altered based on specific re<span style=color:#960050;background-color:#1e0010>‐</span>
</span></span><span style=display:flex><span>	quirements.   All  programs  referred to in a program<span style=color:#f92672>-</span>array map must have been previously
</span></span><span style=display:flex><span>	loaded into the kernel via bpf().  If a map lookup fails, the current  program  continues
</span></span><span style=display:flex><span>	its execution.  See BPF_MAP_TYPE_PROG_ARRAY below <span style=color:#66d9ef>for</span> further details.
</span></span><span style=display:flex><span>	<span style=color:#f92672>--</span> <span style=color:#960050;background-color:#1e0010>有一类特殊的</span>map类型<span style=color:#960050;background-color:#1e0010>，称为程序数组。这种类型的</span>map存储指向其它ebpf程序的文件描述符<span style=color:#960050;background-color:#1e0010>。当在</span>map里执行lookup时<span style=color:#960050;background-color:#1e0010>，程序流被重定向到另外的</span>ebpf程序的开头<span style=color:#960050;background-color:#1e0010>，并且不会返回到当前的</span>ebpf程序<span style=color:#960050;background-color:#1e0010>（调走之后就不回来了）。内嵌的最大层数限制为</span><span style=color:#ae81ff>32</span><span style=color:#960050;background-color:#1e0010>，因此不会出现无限循环。在运行时，程序储存在</span>map的文件描述符可以被修改<span style=color:#960050;background-color:#1e0010>，因此可以根据特定要求更改程序功能。在这种程序数组</span>map里的程序必须在之前已经用bpf()<span style=color:#960050;background-color:#1e0010>加载了进来。如果</span>lookup失败了<span style=color:#960050;background-color:#1e0010>，当前程序会继续执行。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	Generally,  eBPF  programs are loaded by the user process and automatically unloaded when
</span></span><span style=display:flex><span>	the process exits.  In some cases, <span style=color:#66d9ef>for</span> example, tc<span style=color:#f92672>-</span>bpf(<span style=color:#ae81ff>8</span>), the program will  <span style=color:#66d9ef>continue</span>  to
</span></span><span style=display:flex><span>	stay  alive  inside  the kernel even after the process that loaded the program exits.  In
</span></span><span style=display:flex><span>	that <span style=color:#66d9ef>case</span>, the tc subsystem holds a reference to the eBPF program after the file descrip<span style=color:#960050;background-color:#1e0010>‐</span>
</span></span><span style=display:flex><span>	tor  has been closed by the user<span style=color:#f92672>-</span>space program.  Thus, whether a specific program contin<span style=color:#960050;background-color:#1e0010>‐</span>
</span></span><span style=display:flex><span>	ues to live inside the kernel depends on how it is further attached  to  a  given  kernel
</span></span><span style=display:flex><span>	subsystem after it was loaded via bpf().
</span></span><span style=display:flex><span>	<span style=color:#f92672>--</span> <span style=color:#960050;background-color:#1e0010>一般地，</span>ebpf程序被用户进程加载<span style=color:#960050;background-color:#1e0010>，并随用户进程离开而自动卸载。不过有些特别的例子，比如：</span>tc<span style=color:#f92672>-</span>bpf<span style=color:#960050;background-color:#1e0010>，它在加载它的程序退出之后还会继续存活。</span>tc子系统会持有该ebpf程序的引用<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	Each  eBPF program is a set of instructions that is safe to run until its completion.  An
</span></span><span style=display:flex><span>	in<span style=color:#f92672>-</span>kernel verifier statically determines that the eBPF program terminates and is safe  to
</span></span><span style=display:flex><span>	execute.   During  verification,  the  kernel increments reference counts <span style=color:#66d9ef>for</span> each of the
</span></span><span style=display:flex><span>	maps that the eBPF program uses, so that the attached maps can<span style=color:#960050;background-color:#1e0010>&#39;</span>t  be  removed  until  the
</span></span><span style=display:flex><span>	program is unloaded.
</span></span><span style=display:flex><span>	<span style=color:#f92672>--</span> <span style=color:#960050;background-color:#1e0010>每个</span>ebpf程序都是一个指令集合<span style=color:#960050;background-color:#1e0010>，安全地执行直到完成。在程序验证期间，内核增加</span>ebpf使用的每个map的引用计数<span style=color:#960050;background-color:#1e0010>，使得</span>map不会被移除直到程序被卸载<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	eBPF  programs  can  be attached to different events.  These events can be the arrival of
</span></span><span style=display:flex><span>	network packets, tracing events, classification events by network  queueing   disciplines
</span></span><span style=display:flex><span>	(<span style=color:#66d9ef>for</span>  eBPF programs attached to a tc(<span style=color:#ae81ff>8</span>) classifier), and other types that may be added in
</span></span><span style=display:flex><span>	the future.  A new event triggers execution of the eBPF program, which may store informa<span style=color:#960050;background-color:#1e0010>‐</span>
</span></span><span style=display:flex><span>	tion  about  the event in eBPF maps.  Beyond storing data, eBPF programs may call a fixed
</span></span><span style=display:flex><span>	set of in<span style=color:#f92672>-</span>kernel helper functions.
</span></span><span style=display:flex><span>	<span style=color:#f92672>--</span> ebpf程序可以附加到不同的事件上<span style=color:#960050;background-color:#1e0010>。这些事件可以是网络包到达，事件追踪，按网络排队规则对事件进行分类，和其它未来将被加进来的事件。一个新的事件触发</span>ebpf程序的执行<span style=color:#960050;background-color:#1e0010>，可以存储事件的信息到</span>ebpf maps里<span style=color:#960050;background-color:#1e0010>。除了存储数据之外，</span>ebpf程序可以调用一系列固定的内核钩子函数<span style=color:#960050;background-color:#1e0010>。</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// union 多选一
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>union</span> bpf_attr {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> {    <span style=color:#75715e>/* Used by BPF_MAP_CREATE */</span>
</span></span><span style=display:flex><span>		__u32         map_type;
</span></span><span style=display:flex><span>		__u32         key_size;    <span style=color:#75715e>/* size of key in bytes */</span>
</span></span><span style=display:flex><span>		__u32         value_size;  <span style=color:#75715e>/* size of value in bytes */</span>
</span></span><span style=display:flex><span>		__u32         max_entries; <span style=color:#75715e>/* maximum number of entries
</span></span></span><span style=display:flex><span><span style=color:#75715e>										in a map */</span>
</span></span><span style=display:flex><span>	};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> {    <span style=color:#75715e>/* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY
</span></span></span><span style=display:flex><span><span style=color:#75715e>					commands */</span>
</span></span><span style=display:flex><span>		__u32         map_fd;
</span></span><span style=display:flex><span>		__aligned_u64 key;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>			__aligned_u64 value;
</span></span><span style=display:flex><span>			__aligned_u64 next_key;
</span></span><span style=display:flex><span>		};
</span></span><span style=display:flex><span>		__u64         flags;
</span></span><span style=display:flex><span>	};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> {    <span style=color:#75715e>/* Used by BPF_PROG_LOAD */</span>
</span></span><span style=display:flex><span>		__u32         prog_type;
</span></span><span style=display:flex><span>		__u32         insn_cnt;
</span></span><span style=display:flex><span>		__aligned_u64 insns;      <span style=color:#75715e>/* &#39;const struct bpf_insn *&#39; */</span>
</span></span><span style=display:flex><span>		__aligned_u64 license;    <span style=color:#75715e>/* &#39;const char *&#39; */</span>
</span></span><span style=display:flex><span>		__u32         log_level;  <span style=color:#75715e>/* verbosity level of verifier */</span>
</span></span><span style=display:flex><span>		__u32         log_size;   <span style=color:#75715e>/* size of user buffer */</span>
</span></span><span style=display:flex><span>		__aligned_u64 log_buf;    <span style=color:#75715e>/* user supplied &#39;char *&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>									buffer */</span>
</span></span><span style=display:flex><span>		__u32         kern_version;
</span></span><span style=display:flex><span>									<span style=color:#75715e>/* checked when prog_type=kprobe
</span></span></span><span style=display:flex><span><span style=color:#75715e>									(since Linux 4.1) */</span>
</span></span><span style=display:flex><span>	};
</span></span><span style=display:flex><span>} __attribute__((aligned(<span style=color:#ae81ff>8</span>)));
</span></span></code></pre></div><p>一个 BPF 程序，如果它通过验证，就会被加载到内核中。在那里，它将被 JIT 编译器<strong>编译成机器码</strong>，并在内核模式下运行，这时附加的触发器将会被激活。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>LOAD -&gt; READ -&gt; WRITE
</span></span></code></pre></div><p>循环缓冲区：内核写入，用户空间程序可以从中读取</p><p>BCC, bpftrace</p><h3 id=go>Go
<a class=anchor href=#go>#</a></h3><blockquote><p>目前，唯一能够编译成 BPF 机器可以理解的格式的编译器是 Clang。另一种流行的编译器 GСС仍然没有 BPF 后端。而能够编译成 BPF 的编程语言，只有 C 语言的一个非常受限的版本。</p><p>然而，BPF 程序还有一个在用户空间中的第二部分。这部分可以用 Go 来编写。</p></blockquote><p>BCC 允许你用 Python 编写这一部分，而 Python 是该工具的主要语言。同时，在主库中，BCC 还支持 Lua 和 C++，并且在辅库中，它还支持 Go。</p><p>除了 iovisor/gobpf 之外，我还发现了其他三个最新的项目，它们允许你在 Go 中编写用户空间（userland）部分。</p><ul><li><a href=https://github.com/golang/net/tree/master/bpf>https://github.com/golang/net/tree/master/bpf</a></li><li><a href=https://github.com/dropbox/goebpf>https://github.com/dropbox/goebpf</a></li><li><a href=https://github.com/cilium/ebpf>https://github.com/cilium/ebpf</a></li><li><a href=https://github.com/andrewkroh/go-ebpf>https://github.com/andrewkroh/go-ebpf</a></li></ul><h3 id=ciliumebpf>cilium/ebpf
<a class=anchor href=#ciliumebpf>#</a></h3><blockquote><p>eBPF is a pure Go library that provides utilities for loading, compiling, and debugging eBPF programs. It has minimal external dependencies and is intended to be used in long running processes.</p><p>eBPF是纯Go库，提供了加载、编译、调试eBPF程序的工具。它只有最小外部依赖，并且适合在长期运行的程序中使用。</p></blockquote><p>尝试执行示例：</p><ol><li>统计<code>sys_execve</code>系统调用的调用次数</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>go run -exec sudo ./kprobe
</span></span><span style=display:flex><span>go: downloading github.com/cilium/ebpf v0.7.1-0.20211126075831-9ead52e53c13
</span></span><span style=display:flex><span>go: downloading golang.org/x/sys v0.0.0-20211001092434-39dca1131b70
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>sudo<span style=color:#f92672>]</span> jd 的密码： 
</span></span><span style=display:flex><span>2021/12/24 14:38:52 Waiting <span style=color:#66d9ef>for</span> events..
</span></span><span style=display:flex><span>2021/12/24 14:38:53 sys_execve called <span style=color:#ae81ff>0</span> times
</span></span><span style=display:flex><span>2021/12/24 14:38:54 sys_execve called <span style=color:#ae81ff>0</span> times
</span></span><span style=display:flex><span>2021/12/24 14:38:55 sys_execve called <span style=color:#ae81ff>0</span> times
</span></span><span style=display:flex><span>2021/12/24 14:38:56 sys_execve called <span style=color:#ae81ff>0</span> times
</span></span><span style=display:flex><span>2021/12/24 14:38:57 sys_execve called <span style=color:#ae81ff>0</span> times
</span></span><span style=display:flex><span>2021/12/24 14:38:58 sys_execve called <span style=color:#ae81ff>0</span> times
</span></span><span style=display:flex><span>2021/12/24 14:38:59 sys_execve called <span style=color:#ae81ff>0</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:00 sys_execve called <span style=color:#ae81ff>0</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:01 sys_execve called <span style=color:#ae81ff>12</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:02 sys_execve called <span style=color:#ae81ff>12</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:03 sys_execve called <span style=color:#ae81ff>12</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:04 sys_execve called <span style=color:#ae81ff>12</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:05 sys_execve called <span style=color:#ae81ff>12</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:06 sys_execve called <span style=color:#ae81ff>12</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:07 sys_execve called <span style=color:#ae81ff>12</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:08 sys_execve called <span style=color:#ae81ff>12</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:09 sys_execve called <span style=color:#ae81ff>12</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:10 sys_execve called <span style=color:#ae81ff>12</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:11 sys_execve called <span style=color:#ae81ff>24</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:12 sys_execve called <span style=color:#ae81ff>24</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:13 sys_execve called <span style=color:#ae81ff>24</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:14 sys_execve called <span style=color:#ae81ff>24</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:15 sys_execve called <span style=color:#ae81ff>24</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:16 sys_execve called <span style=color:#ae81ff>24</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:17 sys_execve called <span style=color:#ae81ff>24</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:18 sys_execve called <span style=color:#ae81ff>24</span> times
</span></span><span style=display:flex><span>2021/12/24 14:39:19 sys_execve called <span style=color:#ae81ff>24</span> times
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#75715e>// 允许当前进程为eBPF资源锁住内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>rlimit</span>.<span style=color:#a6e22e>RemoveMemlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加载预编译程序，一般是编译c代码生成的o文件的字节内容
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>objs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bpfObjects</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>loadBpfObjects</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>objs</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>objs</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Open a Kprobe at the entry point of the kernel function and attach the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// pre-compiled program. Each time the kernel function enters, the program
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// will increment the execution counter by 1. The read loop below polls this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// map value once per second.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>kp</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>link</span>.<span style=color:#a6e22e>Kprobe</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>objs</span>.<span style=color:#a6e22e>KprobeExecve</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>kp</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 在执行Kprobe方法时，会将信息写入到objs的KprobeMap里，后续在用户程序即可通过它来查看所需信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>objs</span>.<span style=color:#a6e22e>KprobeMap</span>.<span style=color:#a6e22e>Lookup</span>(<span style=color:#a6e22e>mapKey</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>value</span>) <span style=color:#75715e>// 根据mapKey将值读取到value变量
</span></span></span></code></pre></div><h2 id=效果>效果
<a class=anchor href=#%e6%95%88%e6%9e%9c>#</a></h2><p>可以从一个<strong>正在运行</strong>的程序中获得几乎所有的信息，而<strong>无需停止或更改</strong>它。</p><blockquote><p>eBPF 带来的好处是无与伦比的。</p><blockquote><p>首先，从长期看，eBPF 这项新功能会减少未来的 feature creeping normality。 因为用户或开发者希望内核实现的功能，以后<strong>不需要再通过改内核的方式来实现了</strong>。 只需要一段 eBPF 代码，实时动态加载到内核就行了。</p><p>其次，因为 eBPF，内核也不会再引入那些影响 fast path 的蹩脚甚至 hardcode 代码 ，从而也避免了性能的下降。</p><p>第三，eBPF 还使得内核完全可编程，安全地可编程（fully and safely programmable ），用户编写的 eBPF 程序不会导致内核 crash。另外，eBPF 设计用来解决真实世界 中的线上问题，而且我们现在仍然在坚守这个初衷。</p></blockquote></blockquote><h2 id=更多>更多
<a class=anchor href=#%e6%9b%b4%e5%a4%9a>#</a></h2><p><a href=https://arthurchiao.art/blog/ebpf-and-k8s-zh/>k8s and ebpf</a></p><p><a href=https://cloudnative.to/blog/bpf-intro/>ebpf</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#用处>用处</a></li><li><a href=#使用>使用</a><ul><li><a href=#go>Go</a></li><li><a href=#ciliumebpf>cilium/ebpf</a></li></ul></li><li><a href=#效果>效果</a></li><li><a href=#更多>更多</a></li></ul></li></ul></nav></div></aside></main></body></html>